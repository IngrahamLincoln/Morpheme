"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "components_WebGLCanvas_js";
exports.ids = ["components_WebGLCanvas_js"];
exports.modules = {

/***/ "./components/ConnectorMaterial.js":
/*!*****************************************!*\
  !*** ./components/ConnectorMaterial.js ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConnectorMaterial: () => (/* binding */ ConnectorMaterial)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-three/drei */ \"@react-three/drei\");\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_react_three_drei__WEBPACK_IMPORTED_MODULE_1__);\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([three__WEBPACK_IMPORTED_MODULE_0__]);\nthree__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n// Define uniforms and shader code\n// Adapted for InstancedMesh with matrix-based positioning\nconst ConnectorMaterial = (0,_react_three_drei__WEBPACK_IMPORTED_MODULE_1__.shaderMaterial)(// Uniforms (global settings)\n{\n    u_radiusB: 0.4,\n    u_radiusA: 0.5,\n    u_spacing: 1.5,\n    u_resolution: new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(1, 1)\n}, // Vertex Shader - Pass instance visibility and world center\n/*glsl*/ `\n    // Instance attributes\n    attribute float a_instanceShowInner;\n    attribute float a_instanceShowOuter;\n\n    // Varyings to pass data to fragment shader\n    varying vec2 vUv;\n    varying vec2 vWorldPos;\n    varying vec2 vInstanceCenterWorld; // Pass instance center in world space\n    varying float v_showInner;\n    varying float v_showOuter;\n\n    void main() {\n      vUv = uv;\n      v_showInner = a_instanceShowInner;\n      v_showOuter = a_instanceShowOuter;\n\n      // World position of the vertex\n      vec4 worldPos = instanceMatrix * vec4(position, 1.0);\n      vWorldPos = worldPos.xy;\n      \n      // World position of the instance center (origin of the instance's local space)\n      vec4 instanceCenterWorld = instanceMatrix * vec4(0.0, 0.0, 0.0, 1.0);\n      vInstanceCenterWorld = instanceCenterWorld.xy;\n      \n      gl_Position = projectionMatrix * modelViewMatrix * worldPos;\n    }\n  `, // Fragment Shader - Use instance visibility and world center\n/*glsl*/ `\n    varying vec2 vUv;\n    varying vec2 vWorldPos;\n    varying vec2 vInstanceCenterWorld;\n    varying float v_showInner;\n    varying float v_showOuter;\n\n    uniform float u_radiusB; // Inner circle radius\n    uniform float u_radiusA; // Outer circle radius\n    uniform float u_spacing;\n    uniform vec2 u_resolution;\n\n    void main() {\n      // Calculate distance from pixel's world position to the instance's world center\n      float dist = length(vWorldPos - vInstanceCenterWorld);\n      \n      // Signed distance field for inner circle (radiusB)\n      float innerCircleSDF = dist - u_radiusB;\n      \n      // Signed distance field for outer circle (radiusA)\n      float outerCircleSDF = dist - u_radiusA;\n      \n      // Edge width for anti-aliasing\n      float edgeWidth = 0.01;\n      \n      // Line width for outlines\n      float lineWidth = 0.01;\n      \n      // Inner circle - use v_showInner (attribute)\n      float innerAlpha = 0.0;\n      bool isInnerVisible = v_showInner > 0.5;\n      if (isInnerVisible) {\n        // Full circle\n        innerAlpha = 1.0 - smoothstep(-edgeWidth, edgeWidth, innerCircleSDF);\n      } else {\n        // Just an outline\n        innerAlpha = (1.0 - smoothstep(-lineWidth/2.0, lineWidth/2.0, abs(innerCircleSDF) - lineWidth/2.0)) * 0.8;\n      }\n      \n      // Outer circle - use v_showOuter (attribute)\n      float ringAlpha = 0.0;\n      bool isOuterVisible = v_showOuter > 0.5;\n      // Always render outer circle as outline only, never filled\n      ringAlpha = (1.0 - smoothstep(-lineWidth/2.0, lineWidth/2.0, abs(outerCircleSDF) - lineWidth/2.0)) * 0.8;\n      \n      // Combine both shapes\n      float finalAlpha = max(innerAlpha, ringAlpha * 0.7);\n      \n      // If nearly transparent, discard the pixel\n      if (finalAlpha < 0.01) discard;\n      \n      // Create different colors based on instance visibility\n      vec3 innerColor = isInnerVisible ? vec3(0.0) : vec3(0.3); // Black when on, gray when outline\n      vec3 ringColor = vec3(0.5);  // Always light gray for outer circle outline\n      \n      // Determine final color\n      vec3 color = vec3(1.0); // Default white (shouldn't be visible)\n      if(abs(innerCircleSDF) < lineWidth / 2.0 + edgeWidth && !isInnerVisible) {\n        color = innerColor; // Inner outline\n      } else if (abs(outerCircleSDF) < lineWidth / 2.0 + edgeWidth) {\n         color = ringColor; // Outer outline - always render as outline\n      } else if (innerCircleSDF < 0.0 && isInnerVisible) {\n        color = innerColor; // Inner fill\n      } \n      // Removed the else if for outer circle fill since we never want it filled\n\n      // Output with calculated alpha\n      gl_FragColor = vec4(color, finalAlpha);\n    }\n  `);\n// Add a unique key for HMR purposes with R3F\nConnectorMaterial.key = three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.generateUUID();\n\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL0Nvbm5lY3Rvck1hdGVyaWFsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBK0I7QUFDb0I7QUFFbkQsa0NBQWtDO0FBQ2xDLDBEQUEwRDtBQUUxRCxNQUFNRSxvQkFBb0JELGlFQUFjQSxDQUN0Qyw2QkFBNkI7QUFDN0I7SUFDRUUsV0FBVztJQUNYQyxXQUFXO0lBQ1hDLFdBQVc7SUFDWEMsY0FBYyxJQUFJTiwwQ0FBYSxDQUFDLEdBQUc7QUFDckMsR0FDQSw0REFBNEQ7QUFDNUQsTUFBTSxHQUFFLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQTJCVCxDQUFDLEVBQ0QsNkRBQTZEO0FBQzdELE1BQU0sR0FBRSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFxRVQsQ0FBQztBQUdILDZDQUE2QztBQUM3Q0Usa0JBQWtCTSxHQUFHLEdBQUdSLDRDQUFlLENBQUNVLFlBQVk7QUFFdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWJnbC1kb3QtZ3JpZC1tdnAvLi9jb21wb25lbnRzL0Nvbm5lY3Rvck1hdGVyaWFsLmpzPzQxNDIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgc2hhZGVyTWF0ZXJpYWwgfSBmcm9tICdAcmVhY3QtdGhyZWUvZHJlaSc7XG5cbi8vIERlZmluZSB1bmlmb3JtcyBhbmQgc2hhZGVyIGNvZGVcbi8vIEFkYXB0ZWQgZm9yIEluc3RhbmNlZE1lc2ggd2l0aCBtYXRyaXgtYmFzZWQgcG9zaXRpb25pbmdcblxuY29uc3QgQ29ubmVjdG9yTWF0ZXJpYWwgPSBzaGFkZXJNYXRlcmlhbChcbiAgLy8gVW5pZm9ybXMgKGdsb2JhbCBzZXR0aW5ncylcbiAge1xuICAgIHVfcmFkaXVzQjogMC40LCAvLyBJbm5lciBjaXJjbGUgcmFkaXVzXG4gICAgdV9yYWRpdXNBOiAwLjUsIC8vIE91dGVyIGNpcmNsZSByYWRpdXNcbiAgICB1X3NwYWNpbmc6IDEuNSxcbiAgICB1X3Jlc29sdXRpb246IG5ldyBUSFJFRS5WZWN0b3IyKDEsIDEpLFxuICB9LFxuICAvLyBWZXJ0ZXggU2hhZGVyIC0gUGFzcyBpbnN0YW5jZSB2aXNpYmlsaXR5IGFuZCB3b3JsZCBjZW50ZXJcbiAgLypnbHNsKi9gXG4gICAgLy8gSW5zdGFuY2UgYXR0cmlidXRlc1xuICAgIGF0dHJpYnV0ZSBmbG9hdCBhX2luc3RhbmNlU2hvd0lubmVyO1xuICAgIGF0dHJpYnV0ZSBmbG9hdCBhX2luc3RhbmNlU2hvd091dGVyO1xuXG4gICAgLy8gVmFyeWluZ3MgdG8gcGFzcyBkYXRhIHRvIGZyYWdtZW50IHNoYWRlclxuICAgIHZhcnlpbmcgdmVjMiB2VXY7XG4gICAgdmFyeWluZyB2ZWMyIHZXb3JsZFBvcztcbiAgICB2YXJ5aW5nIHZlYzIgdkluc3RhbmNlQ2VudGVyV29ybGQ7IC8vIFBhc3MgaW5zdGFuY2UgY2VudGVyIGluIHdvcmxkIHNwYWNlXG4gICAgdmFyeWluZyBmbG9hdCB2X3Nob3dJbm5lcjtcbiAgICB2YXJ5aW5nIGZsb2F0IHZfc2hvd091dGVyO1xuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgdlV2ID0gdXY7XG4gICAgICB2X3Nob3dJbm5lciA9IGFfaW5zdGFuY2VTaG93SW5uZXI7XG4gICAgICB2X3Nob3dPdXRlciA9IGFfaW5zdGFuY2VTaG93T3V0ZXI7XG5cbiAgICAgIC8vIFdvcmxkIHBvc2l0aW9uIG9mIHRoZSB2ZXJ0ZXhcbiAgICAgIHZlYzQgd29ybGRQb3MgPSBpbnN0YW5jZU1hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XG4gICAgICB2V29ybGRQb3MgPSB3b3JsZFBvcy54eTtcbiAgICAgIFxuICAgICAgLy8gV29ybGQgcG9zaXRpb24gb2YgdGhlIGluc3RhbmNlIGNlbnRlciAob3JpZ2luIG9mIHRoZSBpbnN0YW5jZSdzIGxvY2FsIHNwYWNlKVxuICAgICAgdmVjNCBpbnN0YW5jZUNlbnRlcldvcmxkID0gaW5zdGFuY2VNYXRyaXggKiB2ZWM0KDAuMCwgMC4wLCAwLjAsIDEuMCk7XG4gICAgICB2SW5zdGFuY2VDZW50ZXJXb3JsZCA9IGluc3RhbmNlQ2VudGVyV29ybGQueHk7XG4gICAgICBcbiAgICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHdvcmxkUG9zO1xuICAgIH1cbiAgYCxcbiAgLy8gRnJhZ21lbnQgU2hhZGVyIC0gVXNlIGluc3RhbmNlIHZpc2liaWxpdHkgYW5kIHdvcmxkIGNlbnRlclxuICAvKmdsc2wqL2BcbiAgICB2YXJ5aW5nIHZlYzIgdlV2O1xuICAgIHZhcnlpbmcgdmVjMiB2V29ybGRQb3M7XG4gICAgdmFyeWluZyB2ZWMyIHZJbnN0YW5jZUNlbnRlcldvcmxkO1xuICAgIHZhcnlpbmcgZmxvYXQgdl9zaG93SW5uZXI7XG4gICAgdmFyeWluZyBmbG9hdCB2X3Nob3dPdXRlcjtcblxuICAgIHVuaWZvcm0gZmxvYXQgdV9yYWRpdXNCOyAvLyBJbm5lciBjaXJjbGUgcmFkaXVzXG4gICAgdW5pZm9ybSBmbG9hdCB1X3JhZGl1c0E7IC8vIE91dGVyIGNpcmNsZSByYWRpdXNcbiAgICB1bmlmb3JtIGZsb2F0IHVfc3BhY2luZztcbiAgICB1bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uO1xuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgLy8gQ2FsY3VsYXRlIGRpc3RhbmNlIGZyb20gcGl4ZWwncyB3b3JsZCBwb3NpdGlvbiB0byB0aGUgaW5zdGFuY2UncyB3b3JsZCBjZW50ZXJcbiAgICAgIGZsb2F0IGRpc3QgPSBsZW5ndGgodldvcmxkUG9zIC0gdkluc3RhbmNlQ2VudGVyV29ybGQpO1xuICAgICAgXG4gICAgICAvLyBTaWduZWQgZGlzdGFuY2UgZmllbGQgZm9yIGlubmVyIGNpcmNsZSAocmFkaXVzQilcbiAgICAgIGZsb2F0IGlubmVyQ2lyY2xlU0RGID0gZGlzdCAtIHVfcmFkaXVzQjtcbiAgICAgIFxuICAgICAgLy8gU2lnbmVkIGRpc3RhbmNlIGZpZWxkIGZvciBvdXRlciBjaXJjbGUgKHJhZGl1c0EpXG4gICAgICBmbG9hdCBvdXRlckNpcmNsZVNERiA9IGRpc3QgLSB1X3JhZGl1c0E7XG4gICAgICBcbiAgICAgIC8vIEVkZ2Ugd2lkdGggZm9yIGFudGktYWxpYXNpbmdcbiAgICAgIGZsb2F0IGVkZ2VXaWR0aCA9IDAuMDE7XG4gICAgICBcbiAgICAgIC8vIExpbmUgd2lkdGggZm9yIG91dGxpbmVzXG4gICAgICBmbG9hdCBsaW5lV2lkdGggPSAwLjAxO1xuICAgICAgXG4gICAgICAvLyBJbm5lciBjaXJjbGUgLSB1c2Ugdl9zaG93SW5uZXIgKGF0dHJpYnV0ZSlcbiAgICAgIGZsb2F0IGlubmVyQWxwaGEgPSAwLjA7XG4gICAgICBib29sIGlzSW5uZXJWaXNpYmxlID0gdl9zaG93SW5uZXIgPiAwLjU7XG4gICAgICBpZiAoaXNJbm5lclZpc2libGUpIHtcbiAgICAgICAgLy8gRnVsbCBjaXJjbGVcbiAgICAgICAgaW5uZXJBbHBoYSA9IDEuMCAtIHNtb290aHN0ZXAoLWVkZ2VXaWR0aCwgZWRnZVdpZHRoLCBpbm5lckNpcmNsZVNERik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBKdXN0IGFuIG91dGxpbmVcbiAgICAgICAgaW5uZXJBbHBoYSA9ICgxLjAgLSBzbW9vdGhzdGVwKC1saW5lV2lkdGgvMi4wLCBsaW5lV2lkdGgvMi4wLCBhYnMoaW5uZXJDaXJjbGVTREYpIC0gbGluZVdpZHRoLzIuMCkpICogMC44O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBPdXRlciBjaXJjbGUgLSB1c2Ugdl9zaG93T3V0ZXIgKGF0dHJpYnV0ZSlcbiAgICAgIGZsb2F0IHJpbmdBbHBoYSA9IDAuMDtcbiAgICAgIGJvb2wgaXNPdXRlclZpc2libGUgPSB2X3Nob3dPdXRlciA+IDAuNTtcbiAgICAgIC8vIEFsd2F5cyByZW5kZXIgb3V0ZXIgY2lyY2xlIGFzIG91dGxpbmUgb25seSwgbmV2ZXIgZmlsbGVkXG4gICAgICByaW5nQWxwaGEgPSAoMS4wIC0gc21vb3Roc3RlcCgtbGluZVdpZHRoLzIuMCwgbGluZVdpZHRoLzIuMCwgYWJzKG91dGVyQ2lyY2xlU0RGKSAtIGxpbmVXaWR0aC8yLjApKSAqIDAuODtcbiAgICAgIFxuICAgICAgLy8gQ29tYmluZSBib3RoIHNoYXBlc1xuICAgICAgZmxvYXQgZmluYWxBbHBoYSA9IG1heChpbm5lckFscGhhLCByaW5nQWxwaGEgKiAwLjcpO1xuICAgICAgXG4gICAgICAvLyBJZiBuZWFybHkgdHJhbnNwYXJlbnQsIGRpc2NhcmQgdGhlIHBpeGVsXG4gICAgICBpZiAoZmluYWxBbHBoYSA8IDAuMDEpIGRpc2NhcmQ7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBkaWZmZXJlbnQgY29sb3JzIGJhc2VkIG9uIGluc3RhbmNlIHZpc2liaWxpdHlcbiAgICAgIHZlYzMgaW5uZXJDb2xvciA9IGlzSW5uZXJWaXNpYmxlID8gdmVjMygwLjApIDogdmVjMygwLjMpOyAvLyBCbGFjayB3aGVuIG9uLCBncmF5IHdoZW4gb3V0bGluZVxuICAgICAgdmVjMyByaW5nQ29sb3IgPSB2ZWMzKDAuNSk7ICAvLyBBbHdheXMgbGlnaHQgZ3JheSBmb3Igb3V0ZXIgY2lyY2xlIG91dGxpbmVcbiAgICAgIFxuICAgICAgLy8gRGV0ZXJtaW5lIGZpbmFsIGNvbG9yXG4gICAgICB2ZWMzIGNvbG9yID0gdmVjMygxLjApOyAvLyBEZWZhdWx0IHdoaXRlIChzaG91bGRuJ3QgYmUgdmlzaWJsZSlcbiAgICAgIGlmKGFicyhpbm5lckNpcmNsZVNERikgPCBsaW5lV2lkdGggLyAyLjAgKyBlZGdlV2lkdGggJiYgIWlzSW5uZXJWaXNpYmxlKSB7XG4gICAgICAgIGNvbG9yID0gaW5uZXJDb2xvcjsgLy8gSW5uZXIgb3V0bGluZVxuICAgICAgfSBlbHNlIGlmIChhYnMob3V0ZXJDaXJjbGVTREYpIDwgbGluZVdpZHRoIC8gMi4wICsgZWRnZVdpZHRoKSB7XG4gICAgICAgICBjb2xvciA9IHJpbmdDb2xvcjsgLy8gT3V0ZXIgb3V0bGluZSAtIGFsd2F5cyByZW5kZXIgYXMgb3V0bGluZVxuICAgICAgfSBlbHNlIGlmIChpbm5lckNpcmNsZVNERiA8IDAuMCAmJiBpc0lubmVyVmlzaWJsZSkge1xuICAgICAgICBjb2xvciA9IGlubmVyQ29sb3I7IC8vIElubmVyIGZpbGxcbiAgICAgIH0gXG4gICAgICAvLyBSZW1vdmVkIHRoZSBlbHNlIGlmIGZvciBvdXRlciBjaXJjbGUgZmlsbCBzaW5jZSB3ZSBuZXZlciB3YW50IGl0IGZpbGxlZFxuXG4gICAgICAvLyBPdXRwdXQgd2l0aCBjYWxjdWxhdGVkIGFscGhhXG4gICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLCBmaW5hbEFscGhhKTtcbiAgICB9XG4gIGBcbik7XG5cbi8vIEFkZCBhIHVuaXF1ZSBrZXkgZm9yIEhNUiBwdXJwb3NlcyB3aXRoIFIzRlxuQ29ubmVjdG9yTWF0ZXJpYWwua2V5ID0gVEhSRUUuTWF0aFV0aWxzLmdlbmVyYXRlVVVJRCgpO1xuXG5leHBvcnQgeyBDb25uZWN0b3JNYXRlcmlhbCB9OyAiXSwibmFtZXMiOlsiVEhSRUUiLCJzaGFkZXJNYXRlcmlhbCIsIkNvbm5lY3Rvck1hdGVyaWFsIiwidV9yYWRpdXNCIiwidV9yYWRpdXNBIiwidV9zcGFjaW5nIiwidV9yZXNvbHV0aW9uIiwiVmVjdG9yMiIsImtleSIsIk1hdGhVdGlscyIsImdlbmVyYXRlVVVJRCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./components/ConnectorMaterial.js\n");

/***/ }),

/***/ "./components/GridConnectorMaterial.js":
/*!*********************************************!*\
  !*** ./components/GridConnectorMaterial.js ***!
  \*********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GridConnectorMaterial: () => (/* binding */ GridConnectorMaterial)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-three/drei */ \"@react-three/drei\");\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_react_three_drei__WEBPACK_IMPORTED_MODULE_1__);\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([three__WEBPACK_IMPORTED_MODULE_0__]);\nthree__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n// This material handles the connector shapes between active points on the grid\nconst GridConnectorMaterial = (0,_react_three_drei__WEBPACK_IMPORTED_MODULE_1__.shaderMaterial)(// Uniforms\n{\n    u_radiusB: 0.4,\n    u_radiusA: 0.5,\n    u_spacing: 1.0,\n    u_thickness: 0.2,\n    u_curvature: 0.5,\n    u_resolution: new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(1, 1),\n    u_activeConnector: 0,\n    u_gridState: new three__WEBPACK_IMPORTED_MODULE_0__.DataTexture(new Float32Array(4), 2, 2, three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat, three__WEBPACK_IMPORTED_MODULE_0__.FloatType)\n}, // Vertex Shader\n/*glsl*/ `\n    varying vec2 vUv;\n    varying vec2 vWorldPos;\n\n    void main() {\n      vUv = uv;\n      \n      // World position of the vertex\n      vec4 worldPos = modelMatrix * vec4(position, 1.0);\n      vWorldPos = worldPos.xy;\n      \n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n  `, // Fragment Shader\n/*glsl*/ `\n    varying vec2 vUv;\n    varying vec2 vWorldPos;\n\n    uniform float u_radiusB; // Inner circle radius (black circle)\n    uniform float u_radiusA; // Outer circle radius (for connector shape)\n    uniform float u_spacing;\n    uniform float u_thickness; // Controls connector thickness\n    uniform float u_curvature; // Controls the curve shape\n    uniform vec2 u_resolution;\n    uniform float u_activeConnector; // 0 = none, 1 = red (AB), 2 = blue (CD)\n    uniform sampler2D u_gridState;\n\n    // Helper function to get circle state from the grid state texture\n    vec4 getGridState(int row, int col) {\n      return texture2D(u_gridState, vec2(float(col) + 0.5, float(row) + 0.5) / 2.0);\n    }\n\n    // Helper function to calculate distance to a circle\n    float distToCircle(vec2 point, vec2 center) {\n      return length(point - center);\n    }\n\n    // Create a smooth minimum function to blend the connector\n    float smin(float a, float b, float k) {\n      float h = max(k - abs(a - b), 0.0) / k;\n      return min(a, b) - h * h * k * 0.25;\n    }\n\n    void main() {\n      // If no connector is active, discard immediately\n      if (u_activeConnector < 0.5) {\n        discard;\n        return;\n      }\n      \n      // Calculate grid positions (2x2 grid)\n      float gridOffset = u_spacing * 0.5;\n      vec2 center_A = vec2(-gridOffset, gridOffset);   // Top-left (A)\n      vec2 center_B = vec2(gridOffset, -gridOffset);   // Bottom-right (B)\n      vec2 center_C = vec2(-gridOffset, -gridOffset);  // Bottom-left (C)\n      vec2 center_D = vec2(gridOffset, gridOffset);    // Top-right (D)\n\n      // Calculate distances from current pixel to each circle center\n      float dist_A = distToCircle(vWorldPos, center_A);\n      float dist_B = distToCircle(vWorldPos, center_B);\n      float dist_C = distToCircle(vWorldPos, center_C);\n      float dist_D = distToCircle(vWorldPos, center_D);\n\n      // Get circle states\n      vec4 stateA = getGridState(0, 0); // Top-left\n      vec4 stateB = getGridState(1, 1); // Bottom-right\n      vec4 stateC = getGridState(1, 0); // Bottom-left\n      vec4 stateD = getGridState(0, 1); // Top-right\n\n      // Check if relevant circles are active \n      bool circleAInnerActive = stateA.r > 0.5; // Top-left inner circle\n      bool circleBInnerActive = stateB.r > 0.5; // Bottom-right inner circle\n      bool circleCInnerActive = stateC.r > 0.5; // Bottom-left inner circle\n      bool circleDInnerActive = stateD.r > 0.5; // Top-right inner circle\n      \n      // Determine which connector to draw based on active connector state\n      bool drawABConnector = u_activeConnector == 1.0;\n      bool drawCDConnector = u_activeConnector == 2.0;\n      \n      // Verify the required circles are active for the selected connector\n      if (drawABConnector && (!circleAInnerActive || !circleBInnerActive)) {\n        discard;\n        return;\n      }\n      \n      if (drawCDConnector && (!circleCInnerActive || !circleDInnerActive)) {\n        discard;\n        return;\n      }\n      \n      // Distance fields for the inner black circles\n      float sdfA = dist_A - u_radiusB;\n      float sdfB = dist_B - u_radiusB;\n      float sdfC = dist_C - u_radiusB;\n      float sdfD = dist_D - u_radiusB;\n      \n      // We only continue if we're outside the relevant black circles\n      bool outsideRelevantCircles = true;\n      \n      if (drawABConnector) {\n        outsideRelevantCircles = (sdfA > 0.0) && (sdfB > 0.0);\n      }\n      \n      if (drawCDConnector) {\n        outsideRelevantCircles = (sdfC > 0.0) && (sdfD > 0.0);\n      }\n      \n      if (!outsideRelevantCircles) {\n        discard;\n        return;\n      }\n      \n      // Check if inside influence areas\n      bool insideInfluenceArea = false;\n      \n      if (drawABConnector) {\n        // For Red AB connector:\n        // Must be outside inner B circles (we already checked this with outsideRelevantCircles)\n        // Must be outside outer A circles (represented by the gray circles)\n        // Notice how we're checking if we're outside both outer A circles (C and D)\n        insideInfluenceArea = (dist_C > u_radiusA) && (dist_D > u_radiusA);\n      }\n      \n      if (drawCDConnector) {\n        // For Blue CD connector:\n        // Must be outside inner A circles (we already checked this with outsideRelevantCircles)\n        // Must be outside outer B circles (represented by the gray circles)\n        // Notice how we're checking if we're outside both outer B circles (A and B)\n        insideInfluenceArea = (dist_A > u_radiusA) && (dist_B > u_radiusA);\n      }\n      \n      if (!insideInfluenceArea) {\n        discard;\n        return;\n      }\n      \n      // Calculate vector between the active circles\n      vec2 activeDirection;\n      vec2 startCenter;\n      vec2 endCenter;\n      float distStart;\n      float distEnd;\n      \n      if (drawABConnector) {\n        activeDirection = center_B - center_A;\n        startCenter = center_A;\n        endCenter = center_B;\n        distStart = dist_A;\n        distEnd = dist_B;\n      }\n      \n      if (drawCDConnector) {\n        activeDirection = center_D - center_C;\n        startCenter = center_C;\n        endCenter = center_D;\n        distStart = dist_C;\n        distEnd = dist_D;\n      }\n      \n      // Continue with existing connector logic, but use the active centers\n      float lengthAB = length(activeDirection);\n      vec2 AB_normalized = activeDirection / lengthAB;\n      \n      // Project current point onto line\n      vec2 AP = vWorldPos - startCenter;\n      float projection = dot(AP, AB_normalized);\n      \n      // Create a field that represents the \"pathway\" between the two circles\n      // This creates a curved shape that narrows in the middle\n      float pathwayField;\n      \n      // For the first part of the curvature range, use distance-based shape\n      if (u_curvature < 0.5) {\n        // Method 1: Path with varying width based on projection along AB\n        \n        // Only proceed if the pixel is reasonably near the AB line\n        if (projection >= -u_radiusA && projection <= lengthAB + u_radiusA) {\n          // Calculate perpendicular distance from point to AB line\n          vec2 perpendicular = AP - projection * AB_normalized;\n          float perpDistance = length(perpendicular);\n          \n          // Base width based on thickness\n          float baseWidth = u_thickness * u_radiusA;\n          float midPoint = lengthAB * 0.5;\n          float distFromMid = abs(projection - midPoint);\n          \n          // Make narrower in middle based on curvature\n          float t = distFromMid / midPoint; // 0 at center, 1 at endpoints\n          float narrowingFactor = mix(0.5, 0.9, u_curvature * 2.0); // More narrow at higher curvature\n          float widthCurve = 1.0 - pow(t, 1.5) * narrowingFactor;\n          \n          // Calculate the adjusted width based on position\n          float adjustedWidth;\n          \n          if (projection < 0.0) {\n            // Near endpoint A - blend with circle\n            adjustedWidth = mix(u_radiusA * 0.8, baseWidth, 1.0 + projection / u_radiusA);\n          } else if (projection > lengthAB) {\n            // Near endpoint B - blend with circle\n            adjustedWidth = mix(u_radiusA * 0.8, baseWidth, 1.0 - (projection - lengthAB) / u_radiusA);\n          } else {\n            // Between endpoints - use curved width\n            adjustedWidth = baseWidth * widthCurve;\n          }\n          \n          // If within the adjusted width, we're in the connector\n          if (perpDistance < adjustedWidth) {\n            // Set color based on which connector is being drawn\n            if (drawABConnector) {\n              gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); // Red for AB connector\n            } else {\n              gl_FragColor = vec4(0.0, 0.5, 1.0, 1.0); // Blue for CD connector\n            }\n            return;\n          }\n        }\n      }\n      else {\n        // Method 2: Use hyperbolic distance field for higher curvature\n        // Normalize distances for better control\n        float d1 = max(0.0, distStart - u_radiusB) / u_radiusA; \n        float d2 = max(0.0, distEnd - u_radiusB) / u_radiusA;\n        \n        // Create hyperbolic field (product of distances)\n        pathwayField = d1 * d2;\n        \n        // Adjust field strength based on distance to make shape more compact\n        float distanceScale = 3.0 / lengthAB;\n        pathwayField *= distanceScale;\n        \n        // Thickness controls the threshold\n        float threshold = u_thickness * 0.2 * mix(1.0, 2.0, u_curvature - 0.5);\n        \n        // Check if within the field threshold\n        if (pathwayField < threshold) {\n          // Only show connector between the circles (not extending out the other sides)\n          float dotProductA = dot(AP, AB_normalized);\n          float dotProductB = dot(vWorldPos - endCenter, -AB_normalized);\n          \n          if (dotProductA >= -u_radiusB * 0.5 && dotProductB >= -u_radiusB * 0.5) {\n            // Set color based on which connector is being drawn\n            if (drawABConnector) {\n              gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); // Red for AB connector\n            } else {\n              gl_FragColor = vec4(0.0, 0.5, 1.0, 1.0); // Blue for CD connector\n            }\n            return;\n          }\n        }\n      }\n      \n      // If we got here, the pixel is outside the connector shape\n      discard;\n    }\n  `);\n// Add a unique key for HMR purposes with R3F\nGridConnectorMaterial.key = three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.generateUUID();\n\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL0dyaWRDb25uZWN0b3JNYXRlcmlhbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQStCO0FBQ29CO0FBRW5ELCtFQUErRTtBQUMvRSxNQUFNRSx3QkFBd0JELGlFQUFjQSxDQUMxQyxXQUFXO0FBQ1g7SUFDRUUsV0FBVztJQUNYQyxXQUFXO0lBQ1hDLFdBQVc7SUFDWEMsYUFBYTtJQUNiQyxhQUFhO0lBQ2JDLGNBQWMsSUFBSVIsMENBQWEsQ0FBQyxHQUFHO0lBQ25DVSxtQkFBbUI7SUFDbkJDLGFBQWEsSUFBSVgsOENBQWlCLENBQ2hDLElBQUlhLGFBQWEsSUFDakIsR0FDQSxHQUNBYiw2Q0FBZ0IsRUFDaEJBLDRDQUFlO0FBRW5CLEdBQ0EsZ0JBQWdCO0FBQ2hCLE1BQU0sR0FBRSxDQUFDOzs7Ozs7Ozs7Ozs7O0VBYVQsQ0FBQyxFQUNELGtCQUFrQjtBQUNsQixNQUFNLEdBQUUsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBZ1BULENBQUM7QUFHSCw2Q0FBNkM7QUFDN0NFLHNCQUFzQmMsR0FBRyxHQUFHaEIsNENBQWUsQ0FBQ2tCLFlBQVk7QUFFdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWJnbC1kb3QtZ3JpZC1tdnAvLi9jb21wb25lbnRzL0dyaWRDb25uZWN0b3JNYXRlcmlhbC5qcz9iMjFkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcbmltcG9ydCB7IHNoYWRlck1hdGVyaWFsIH0gZnJvbSAnQHJlYWN0LXRocmVlL2RyZWknO1xuXG4vLyBUaGlzIG1hdGVyaWFsIGhhbmRsZXMgdGhlIGNvbm5lY3RvciBzaGFwZXMgYmV0d2VlbiBhY3RpdmUgcG9pbnRzIG9uIHRoZSBncmlkXG5jb25zdCBHcmlkQ29ubmVjdG9yTWF0ZXJpYWwgPSBzaGFkZXJNYXRlcmlhbChcbiAgLy8gVW5pZm9ybXNcbiAge1xuICAgIHVfcmFkaXVzQjogMC40LCAvLyBJbm5lciBjaXJjbGUgcmFkaXVzIChibGFjayBjaXJjbGUpXG4gICAgdV9yYWRpdXNBOiAwLjUsIC8vIE91dGVyIGNpcmNsZSByYWRpdXMgKGZvciBjb25uZWN0b3Igc2hhcGUgY2FsY3VsYXRpb24pXG4gICAgdV9zcGFjaW5nOiAxLjAsIC8vIEdyaWQgc3BhY2luZ1xuICAgIHVfdGhpY2tuZXNzOiAwLjIsIC8vIENvbm5lY3RvciB0aGlja25lc3MgY29udHJvbFxuICAgIHVfY3VydmF0dXJlOiAwLjUsIC8vIENvbnRyb2xzIHRoZSBjdXJ2YXR1cmUgb2YgdGhlIGNvbm5lY3RvclxuICAgIHVfcmVzb2x1dGlvbjogbmV3IFRIUkVFLlZlY3RvcjIoMSwgMSksXG4gICAgdV9hY3RpdmVDb25uZWN0b3I6IDAsIC8vIDAgPSBub25lLCAxID0gcmVkIChBQiksIDIgPSBibHVlIChDRClcbiAgICB1X2dyaWRTdGF0ZTogbmV3IFRIUkVFLkRhdGFUZXh0dXJlKCAvLyBXaWxsIHN0b3JlIGdyaWQgc3RhdGUgaW4gYSB0ZXh0dXJlXG4gICAgICBuZXcgRmxvYXQzMkFycmF5KDQpLCAvLyBSR0JBIHZhbHVlcyBwZXIgY2VsbFxuICAgICAgMiwgLy8gd2lkdGggKGZvciAyeDIgZ3JpZClcbiAgICAgIDIsIC8vIGhlaWdodCAoZm9yIDJ4MiBncmlkKVxuICAgICAgVEhSRUUuUkdCQUZvcm1hdCxcbiAgICAgIFRIUkVFLkZsb2F0VHlwZVxuICAgICksXG4gIH0sXG4gIC8vIFZlcnRleCBTaGFkZXJcbiAgLypnbHNsKi9gXG4gICAgdmFyeWluZyB2ZWMyIHZVdjtcbiAgICB2YXJ5aW5nIHZlYzIgdldvcmxkUG9zO1xuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgdlV2ID0gdXY7XG4gICAgICBcbiAgICAgIC8vIFdvcmxkIHBvc2l0aW9uIG9mIHRoZSB2ZXJ0ZXhcbiAgICAgIHZlYzQgd29ybGRQb3MgPSBtb2RlbE1hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XG4gICAgICB2V29ybGRQb3MgPSB3b3JsZFBvcy54eTtcbiAgICAgIFxuICAgICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTtcbiAgICB9XG4gIGAsXG4gIC8vIEZyYWdtZW50IFNoYWRlclxuICAvKmdsc2wqL2BcbiAgICB2YXJ5aW5nIHZlYzIgdlV2O1xuICAgIHZhcnlpbmcgdmVjMiB2V29ybGRQb3M7XG5cbiAgICB1bmlmb3JtIGZsb2F0IHVfcmFkaXVzQjsgLy8gSW5uZXIgY2lyY2xlIHJhZGl1cyAoYmxhY2sgY2lyY2xlKVxuICAgIHVuaWZvcm0gZmxvYXQgdV9yYWRpdXNBOyAvLyBPdXRlciBjaXJjbGUgcmFkaXVzIChmb3IgY29ubmVjdG9yIHNoYXBlKVxuICAgIHVuaWZvcm0gZmxvYXQgdV9zcGFjaW5nO1xuICAgIHVuaWZvcm0gZmxvYXQgdV90aGlja25lc3M7IC8vIENvbnRyb2xzIGNvbm5lY3RvciB0aGlja25lc3NcbiAgICB1bmlmb3JtIGZsb2F0IHVfY3VydmF0dXJlOyAvLyBDb250cm9scyB0aGUgY3VydmUgc2hhcGVcbiAgICB1bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uO1xuICAgIHVuaWZvcm0gZmxvYXQgdV9hY3RpdmVDb25uZWN0b3I7IC8vIDAgPSBub25lLCAxID0gcmVkIChBQiksIDIgPSBibHVlIChDRClcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1X2dyaWRTdGF0ZTtcblxuICAgIC8vIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgY2lyY2xlIHN0YXRlIGZyb20gdGhlIGdyaWQgc3RhdGUgdGV4dHVyZVxuICAgIHZlYzQgZ2V0R3JpZFN0YXRlKGludCByb3csIGludCBjb2wpIHtcbiAgICAgIHJldHVybiB0ZXh0dXJlMkQodV9ncmlkU3RhdGUsIHZlYzIoZmxvYXQoY29sKSArIDAuNSwgZmxvYXQocm93KSArIDAuNSkgLyAyLjApO1xuICAgIH1cblxuICAgIC8vIEhlbHBlciBmdW5jdGlvbiB0byBjYWxjdWxhdGUgZGlzdGFuY2UgdG8gYSBjaXJjbGVcbiAgICBmbG9hdCBkaXN0VG9DaXJjbGUodmVjMiBwb2ludCwgdmVjMiBjZW50ZXIpIHtcbiAgICAgIHJldHVybiBsZW5ndGgocG9pbnQgLSBjZW50ZXIpO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBhIHNtb290aCBtaW5pbXVtIGZ1bmN0aW9uIHRvIGJsZW5kIHRoZSBjb25uZWN0b3JcbiAgICBmbG9hdCBzbWluKGZsb2F0IGEsIGZsb2F0IGIsIGZsb2F0IGspIHtcbiAgICAgIGZsb2F0IGggPSBtYXgoayAtIGFicyhhIC0gYiksIDAuMCkgLyBrO1xuICAgICAgcmV0dXJuIG1pbihhLCBiKSAtIGggKiBoICogayAqIDAuMjU7XG4gICAgfVxuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgLy8gSWYgbm8gY29ubmVjdG9yIGlzIGFjdGl2ZSwgZGlzY2FyZCBpbW1lZGlhdGVseVxuICAgICAgaWYgKHVfYWN0aXZlQ29ubmVjdG9yIDwgMC41KSB7XG4gICAgICAgIGRpc2NhcmQ7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2FsY3VsYXRlIGdyaWQgcG9zaXRpb25zICgyeDIgZ3JpZClcbiAgICAgIGZsb2F0IGdyaWRPZmZzZXQgPSB1X3NwYWNpbmcgKiAwLjU7XG4gICAgICB2ZWMyIGNlbnRlcl9BID0gdmVjMigtZ3JpZE9mZnNldCwgZ3JpZE9mZnNldCk7ICAgLy8gVG9wLWxlZnQgKEEpXG4gICAgICB2ZWMyIGNlbnRlcl9CID0gdmVjMihncmlkT2Zmc2V0LCAtZ3JpZE9mZnNldCk7ICAgLy8gQm90dG9tLXJpZ2h0IChCKVxuICAgICAgdmVjMiBjZW50ZXJfQyA9IHZlYzIoLWdyaWRPZmZzZXQsIC1ncmlkT2Zmc2V0KTsgIC8vIEJvdHRvbS1sZWZ0IChDKVxuICAgICAgdmVjMiBjZW50ZXJfRCA9IHZlYzIoZ3JpZE9mZnNldCwgZ3JpZE9mZnNldCk7ICAgIC8vIFRvcC1yaWdodCAoRClcblxuICAgICAgLy8gQ2FsY3VsYXRlIGRpc3RhbmNlcyBmcm9tIGN1cnJlbnQgcGl4ZWwgdG8gZWFjaCBjaXJjbGUgY2VudGVyXG4gICAgICBmbG9hdCBkaXN0X0EgPSBkaXN0VG9DaXJjbGUodldvcmxkUG9zLCBjZW50ZXJfQSk7XG4gICAgICBmbG9hdCBkaXN0X0IgPSBkaXN0VG9DaXJjbGUodldvcmxkUG9zLCBjZW50ZXJfQik7XG4gICAgICBmbG9hdCBkaXN0X0MgPSBkaXN0VG9DaXJjbGUodldvcmxkUG9zLCBjZW50ZXJfQyk7XG4gICAgICBmbG9hdCBkaXN0X0QgPSBkaXN0VG9DaXJjbGUodldvcmxkUG9zLCBjZW50ZXJfRCk7XG5cbiAgICAgIC8vIEdldCBjaXJjbGUgc3RhdGVzXG4gICAgICB2ZWM0IHN0YXRlQSA9IGdldEdyaWRTdGF0ZSgwLCAwKTsgLy8gVG9wLWxlZnRcbiAgICAgIHZlYzQgc3RhdGVCID0gZ2V0R3JpZFN0YXRlKDEsIDEpOyAvLyBCb3R0b20tcmlnaHRcbiAgICAgIHZlYzQgc3RhdGVDID0gZ2V0R3JpZFN0YXRlKDEsIDApOyAvLyBCb3R0b20tbGVmdFxuICAgICAgdmVjNCBzdGF0ZUQgPSBnZXRHcmlkU3RhdGUoMCwgMSk7IC8vIFRvcC1yaWdodFxuXG4gICAgICAvLyBDaGVjayBpZiByZWxldmFudCBjaXJjbGVzIGFyZSBhY3RpdmUgXG4gICAgICBib29sIGNpcmNsZUFJbm5lckFjdGl2ZSA9IHN0YXRlQS5yID4gMC41OyAvLyBUb3AtbGVmdCBpbm5lciBjaXJjbGVcbiAgICAgIGJvb2wgY2lyY2xlQklubmVyQWN0aXZlID0gc3RhdGVCLnIgPiAwLjU7IC8vIEJvdHRvbS1yaWdodCBpbm5lciBjaXJjbGVcbiAgICAgIGJvb2wgY2lyY2xlQ0lubmVyQWN0aXZlID0gc3RhdGVDLnIgPiAwLjU7IC8vIEJvdHRvbS1sZWZ0IGlubmVyIGNpcmNsZVxuICAgICAgYm9vbCBjaXJjbGVESW5uZXJBY3RpdmUgPSBzdGF0ZUQuciA+IDAuNTsgLy8gVG9wLXJpZ2h0IGlubmVyIGNpcmNsZVxuICAgICAgXG4gICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggY29ubmVjdG9yIHRvIGRyYXcgYmFzZWQgb24gYWN0aXZlIGNvbm5lY3RvciBzdGF0ZVxuICAgICAgYm9vbCBkcmF3QUJDb25uZWN0b3IgPSB1X2FjdGl2ZUNvbm5lY3RvciA9PSAxLjA7XG4gICAgICBib29sIGRyYXdDRENvbm5lY3RvciA9IHVfYWN0aXZlQ29ubmVjdG9yID09IDIuMDtcbiAgICAgIFxuICAgICAgLy8gVmVyaWZ5IHRoZSByZXF1aXJlZCBjaXJjbGVzIGFyZSBhY3RpdmUgZm9yIHRoZSBzZWxlY3RlZCBjb25uZWN0b3JcbiAgICAgIGlmIChkcmF3QUJDb25uZWN0b3IgJiYgKCFjaXJjbGVBSW5uZXJBY3RpdmUgfHwgIWNpcmNsZUJJbm5lckFjdGl2ZSkpIHtcbiAgICAgICAgZGlzY2FyZDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoZHJhd0NEQ29ubmVjdG9yICYmICghY2lyY2xlQ0lubmVyQWN0aXZlIHx8ICFjaXJjbGVESW5uZXJBY3RpdmUpKSB7XG4gICAgICAgIGRpc2NhcmQ7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gRGlzdGFuY2UgZmllbGRzIGZvciB0aGUgaW5uZXIgYmxhY2sgY2lyY2xlc1xuICAgICAgZmxvYXQgc2RmQSA9IGRpc3RfQSAtIHVfcmFkaXVzQjtcbiAgICAgIGZsb2F0IHNkZkIgPSBkaXN0X0IgLSB1X3JhZGl1c0I7XG4gICAgICBmbG9hdCBzZGZDID0gZGlzdF9DIC0gdV9yYWRpdXNCO1xuICAgICAgZmxvYXQgc2RmRCA9IGRpc3RfRCAtIHVfcmFkaXVzQjtcbiAgICAgIFxuICAgICAgLy8gV2Ugb25seSBjb250aW51ZSBpZiB3ZSdyZSBvdXRzaWRlIHRoZSByZWxldmFudCBibGFjayBjaXJjbGVzXG4gICAgICBib29sIG91dHNpZGVSZWxldmFudENpcmNsZXMgPSB0cnVlO1xuICAgICAgXG4gICAgICBpZiAoZHJhd0FCQ29ubmVjdG9yKSB7XG4gICAgICAgIG91dHNpZGVSZWxldmFudENpcmNsZXMgPSAoc2RmQSA+IDAuMCkgJiYgKHNkZkIgPiAwLjApO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoZHJhd0NEQ29ubmVjdG9yKSB7XG4gICAgICAgIG91dHNpZGVSZWxldmFudENpcmNsZXMgPSAoc2RmQyA+IDAuMCkgJiYgKHNkZkQgPiAwLjApO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoIW91dHNpZGVSZWxldmFudENpcmNsZXMpIHtcbiAgICAgICAgZGlzY2FyZDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiBpbnNpZGUgaW5mbHVlbmNlIGFyZWFzXG4gICAgICBib29sIGluc2lkZUluZmx1ZW5jZUFyZWEgPSBmYWxzZTtcbiAgICAgIFxuICAgICAgaWYgKGRyYXdBQkNvbm5lY3Rvcikge1xuICAgICAgICAvLyBGb3IgUmVkIEFCIGNvbm5lY3RvcjpcbiAgICAgICAgLy8gTXVzdCBiZSBvdXRzaWRlIGlubmVyIEIgY2lyY2xlcyAod2UgYWxyZWFkeSBjaGVja2VkIHRoaXMgd2l0aCBvdXRzaWRlUmVsZXZhbnRDaXJjbGVzKVxuICAgICAgICAvLyBNdXN0IGJlIG91dHNpZGUgb3V0ZXIgQSBjaXJjbGVzIChyZXByZXNlbnRlZCBieSB0aGUgZ3JheSBjaXJjbGVzKVxuICAgICAgICAvLyBOb3RpY2UgaG93IHdlJ3JlIGNoZWNraW5nIGlmIHdlJ3JlIG91dHNpZGUgYm90aCBvdXRlciBBIGNpcmNsZXMgKEMgYW5kIEQpXG4gICAgICAgIGluc2lkZUluZmx1ZW5jZUFyZWEgPSAoZGlzdF9DID4gdV9yYWRpdXNBKSAmJiAoZGlzdF9EID4gdV9yYWRpdXNBKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKGRyYXdDRENvbm5lY3Rvcikge1xuICAgICAgICAvLyBGb3IgQmx1ZSBDRCBjb25uZWN0b3I6XG4gICAgICAgIC8vIE11c3QgYmUgb3V0c2lkZSBpbm5lciBBIGNpcmNsZXMgKHdlIGFscmVhZHkgY2hlY2tlZCB0aGlzIHdpdGggb3V0c2lkZVJlbGV2YW50Q2lyY2xlcylcbiAgICAgICAgLy8gTXVzdCBiZSBvdXRzaWRlIG91dGVyIEIgY2lyY2xlcyAocmVwcmVzZW50ZWQgYnkgdGhlIGdyYXkgY2lyY2xlcylcbiAgICAgICAgLy8gTm90aWNlIGhvdyB3ZSdyZSBjaGVja2luZyBpZiB3ZSdyZSBvdXRzaWRlIGJvdGggb3V0ZXIgQiBjaXJjbGVzIChBIGFuZCBCKVxuICAgICAgICBpbnNpZGVJbmZsdWVuY2VBcmVhID0gKGRpc3RfQSA+IHVfcmFkaXVzQSkgJiYgKGRpc3RfQiA+IHVfcmFkaXVzQSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmICghaW5zaWRlSW5mbHVlbmNlQXJlYSkge1xuICAgICAgICBkaXNjYXJkO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENhbGN1bGF0ZSB2ZWN0b3IgYmV0d2VlbiB0aGUgYWN0aXZlIGNpcmNsZXNcbiAgICAgIHZlYzIgYWN0aXZlRGlyZWN0aW9uO1xuICAgICAgdmVjMiBzdGFydENlbnRlcjtcbiAgICAgIHZlYzIgZW5kQ2VudGVyO1xuICAgICAgZmxvYXQgZGlzdFN0YXJ0O1xuICAgICAgZmxvYXQgZGlzdEVuZDtcbiAgICAgIFxuICAgICAgaWYgKGRyYXdBQkNvbm5lY3Rvcikge1xuICAgICAgICBhY3RpdmVEaXJlY3Rpb24gPSBjZW50ZXJfQiAtIGNlbnRlcl9BO1xuICAgICAgICBzdGFydENlbnRlciA9IGNlbnRlcl9BO1xuICAgICAgICBlbmRDZW50ZXIgPSBjZW50ZXJfQjtcbiAgICAgICAgZGlzdFN0YXJ0ID0gZGlzdF9BO1xuICAgICAgICBkaXN0RW5kID0gZGlzdF9CO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoZHJhd0NEQ29ubmVjdG9yKSB7XG4gICAgICAgIGFjdGl2ZURpcmVjdGlvbiA9IGNlbnRlcl9EIC0gY2VudGVyX0M7XG4gICAgICAgIHN0YXJ0Q2VudGVyID0gY2VudGVyX0M7XG4gICAgICAgIGVuZENlbnRlciA9IGNlbnRlcl9EO1xuICAgICAgICBkaXN0U3RhcnQgPSBkaXN0X0M7XG4gICAgICAgIGRpc3RFbmQgPSBkaXN0X0Q7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENvbnRpbnVlIHdpdGggZXhpc3RpbmcgY29ubmVjdG9yIGxvZ2ljLCBidXQgdXNlIHRoZSBhY3RpdmUgY2VudGVyc1xuICAgICAgZmxvYXQgbGVuZ3RoQUIgPSBsZW5ndGgoYWN0aXZlRGlyZWN0aW9uKTtcbiAgICAgIHZlYzIgQUJfbm9ybWFsaXplZCA9IGFjdGl2ZURpcmVjdGlvbiAvIGxlbmd0aEFCO1xuICAgICAgXG4gICAgICAvLyBQcm9qZWN0IGN1cnJlbnQgcG9pbnQgb250byBsaW5lXG4gICAgICB2ZWMyIEFQID0gdldvcmxkUG9zIC0gc3RhcnRDZW50ZXI7XG4gICAgICBmbG9hdCBwcm9qZWN0aW9uID0gZG90KEFQLCBBQl9ub3JtYWxpemVkKTtcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIGEgZmllbGQgdGhhdCByZXByZXNlbnRzIHRoZSBcInBhdGh3YXlcIiBiZXR3ZWVuIHRoZSB0d28gY2lyY2xlc1xuICAgICAgLy8gVGhpcyBjcmVhdGVzIGEgY3VydmVkIHNoYXBlIHRoYXQgbmFycm93cyBpbiB0aGUgbWlkZGxlXG4gICAgICBmbG9hdCBwYXRod2F5RmllbGQ7XG4gICAgICBcbiAgICAgIC8vIEZvciB0aGUgZmlyc3QgcGFydCBvZiB0aGUgY3VydmF0dXJlIHJhbmdlLCB1c2UgZGlzdGFuY2UtYmFzZWQgc2hhcGVcbiAgICAgIGlmICh1X2N1cnZhdHVyZSA8IDAuNSkge1xuICAgICAgICAvLyBNZXRob2QgMTogUGF0aCB3aXRoIHZhcnlpbmcgd2lkdGggYmFzZWQgb24gcHJvamVjdGlvbiBhbG9uZyBBQlxuICAgICAgICBcbiAgICAgICAgLy8gT25seSBwcm9jZWVkIGlmIHRoZSBwaXhlbCBpcyByZWFzb25hYmx5IG5lYXIgdGhlIEFCIGxpbmVcbiAgICAgICAgaWYgKHByb2plY3Rpb24gPj0gLXVfcmFkaXVzQSAmJiBwcm9qZWN0aW9uIDw9IGxlbmd0aEFCICsgdV9yYWRpdXNBKSB7XG4gICAgICAgICAgLy8gQ2FsY3VsYXRlIHBlcnBlbmRpY3VsYXIgZGlzdGFuY2UgZnJvbSBwb2ludCB0byBBQiBsaW5lXG4gICAgICAgICAgdmVjMiBwZXJwZW5kaWN1bGFyID0gQVAgLSBwcm9qZWN0aW9uICogQUJfbm9ybWFsaXplZDtcbiAgICAgICAgICBmbG9hdCBwZXJwRGlzdGFuY2UgPSBsZW5ndGgocGVycGVuZGljdWxhcik7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQmFzZSB3aWR0aCBiYXNlZCBvbiB0aGlja25lc3NcbiAgICAgICAgICBmbG9hdCBiYXNlV2lkdGggPSB1X3RoaWNrbmVzcyAqIHVfcmFkaXVzQTtcbiAgICAgICAgICBmbG9hdCBtaWRQb2ludCA9IGxlbmd0aEFCICogMC41O1xuICAgICAgICAgIGZsb2F0IGRpc3RGcm9tTWlkID0gYWJzKHByb2plY3Rpb24gLSBtaWRQb2ludCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gTWFrZSBuYXJyb3dlciBpbiBtaWRkbGUgYmFzZWQgb24gY3VydmF0dXJlXG4gICAgICAgICAgZmxvYXQgdCA9IGRpc3RGcm9tTWlkIC8gbWlkUG9pbnQ7IC8vIDAgYXQgY2VudGVyLCAxIGF0IGVuZHBvaW50c1xuICAgICAgICAgIGZsb2F0IG5hcnJvd2luZ0ZhY3RvciA9IG1peCgwLjUsIDAuOSwgdV9jdXJ2YXR1cmUgKiAyLjApOyAvLyBNb3JlIG5hcnJvdyBhdCBoaWdoZXIgY3VydmF0dXJlXG4gICAgICAgICAgZmxvYXQgd2lkdGhDdXJ2ZSA9IDEuMCAtIHBvdyh0LCAxLjUpICogbmFycm93aW5nRmFjdG9yO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgYWRqdXN0ZWQgd2lkdGggYmFzZWQgb24gcG9zaXRpb25cbiAgICAgICAgICBmbG9hdCBhZGp1c3RlZFdpZHRoO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChwcm9qZWN0aW9uIDwgMC4wKSB7XG4gICAgICAgICAgICAvLyBOZWFyIGVuZHBvaW50IEEgLSBibGVuZCB3aXRoIGNpcmNsZVxuICAgICAgICAgICAgYWRqdXN0ZWRXaWR0aCA9IG1peCh1X3JhZGl1c0EgKiAwLjgsIGJhc2VXaWR0aCwgMS4wICsgcHJvamVjdGlvbiAvIHVfcmFkaXVzQSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChwcm9qZWN0aW9uID4gbGVuZ3RoQUIpIHtcbiAgICAgICAgICAgIC8vIE5lYXIgZW5kcG9pbnQgQiAtIGJsZW5kIHdpdGggY2lyY2xlXG4gICAgICAgICAgICBhZGp1c3RlZFdpZHRoID0gbWl4KHVfcmFkaXVzQSAqIDAuOCwgYmFzZVdpZHRoLCAxLjAgLSAocHJvamVjdGlvbiAtIGxlbmd0aEFCKSAvIHVfcmFkaXVzQSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEJldHdlZW4gZW5kcG9pbnRzIC0gdXNlIGN1cnZlZCB3aWR0aFxuICAgICAgICAgICAgYWRqdXN0ZWRXaWR0aCA9IGJhc2VXaWR0aCAqIHdpZHRoQ3VydmU7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIElmIHdpdGhpbiB0aGUgYWRqdXN0ZWQgd2lkdGgsIHdlJ3JlIGluIHRoZSBjb25uZWN0b3JcbiAgICAgICAgICBpZiAocGVycERpc3RhbmNlIDwgYWRqdXN0ZWRXaWR0aCkge1xuICAgICAgICAgICAgLy8gU2V0IGNvbG9yIGJhc2VkIG9uIHdoaWNoIGNvbm5lY3RvciBpcyBiZWluZyBkcmF3blxuICAgICAgICAgICAgaWYgKGRyYXdBQkNvbm5lY3Rvcikge1xuICAgICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDEuMCwgMC4wLCAwLjAsIDEuMCk7IC8vIFJlZCBmb3IgQUIgY29ubmVjdG9yXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuMCwgMC41LCAxLjAsIDEuMCk7IC8vIEJsdWUgZm9yIENEIGNvbm5lY3RvclxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIE1ldGhvZCAyOiBVc2UgaHlwZXJib2xpYyBkaXN0YW5jZSBmaWVsZCBmb3IgaGlnaGVyIGN1cnZhdHVyZVxuICAgICAgICAvLyBOb3JtYWxpemUgZGlzdGFuY2VzIGZvciBiZXR0ZXIgY29udHJvbFxuICAgICAgICBmbG9hdCBkMSA9IG1heCgwLjAsIGRpc3RTdGFydCAtIHVfcmFkaXVzQikgLyB1X3JhZGl1c0E7IFxuICAgICAgICBmbG9hdCBkMiA9IG1heCgwLjAsIGRpc3RFbmQgLSB1X3JhZGl1c0IpIC8gdV9yYWRpdXNBO1xuICAgICAgICBcbiAgICAgICAgLy8gQ3JlYXRlIGh5cGVyYm9saWMgZmllbGQgKHByb2R1Y3Qgb2YgZGlzdGFuY2VzKVxuICAgICAgICBwYXRod2F5RmllbGQgPSBkMSAqIGQyO1xuICAgICAgICBcbiAgICAgICAgLy8gQWRqdXN0IGZpZWxkIHN0cmVuZ3RoIGJhc2VkIG9uIGRpc3RhbmNlIHRvIG1ha2Ugc2hhcGUgbW9yZSBjb21wYWN0XG4gICAgICAgIGZsb2F0IGRpc3RhbmNlU2NhbGUgPSAzLjAgLyBsZW5ndGhBQjtcbiAgICAgICAgcGF0aHdheUZpZWxkICo9IGRpc3RhbmNlU2NhbGU7XG4gICAgICAgIFxuICAgICAgICAvLyBUaGlja25lc3MgY29udHJvbHMgdGhlIHRocmVzaG9sZFxuICAgICAgICBmbG9hdCB0aHJlc2hvbGQgPSB1X3RoaWNrbmVzcyAqIDAuMiAqIG1peCgxLjAsIDIuMCwgdV9jdXJ2YXR1cmUgLSAwLjUpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgaWYgd2l0aGluIHRoZSBmaWVsZCB0aHJlc2hvbGRcbiAgICAgICAgaWYgKHBhdGh3YXlGaWVsZCA8IHRocmVzaG9sZCkge1xuICAgICAgICAgIC8vIE9ubHkgc2hvdyBjb25uZWN0b3IgYmV0d2VlbiB0aGUgY2lyY2xlcyAobm90IGV4dGVuZGluZyBvdXQgdGhlIG90aGVyIHNpZGVzKVxuICAgICAgICAgIGZsb2F0IGRvdFByb2R1Y3RBID0gZG90KEFQLCBBQl9ub3JtYWxpemVkKTtcbiAgICAgICAgICBmbG9hdCBkb3RQcm9kdWN0QiA9IGRvdCh2V29ybGRQb3MgLSBlbmRDZW50ZXIsIC1BQl9ub3JtYWxpemVkKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoZG90UHJvZHVjdEEgPj0gLXVfcmFkaXVzQiAqIDAuNSAmJiBkb3RQcm9kdWN0QiA+PSAtdV9yYWRpdXNCICogMC41KSB7XG4gICAgICAgICAgICAvLyBTZXQgY29sb3IgYmFzZWQgb24gd2hpY2ggY29ubmVjdG9yIGlzIGJlaW5nIGRyYXduXG4gICAgICAgICAgICBpZiAoZHJhd0FCQ29ubmVjdG9yKSB7XG4gICAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMS4wLCAwLjAsIDAuMCwgMS4wKTsgLy8gUmVkIGZvciBBQiBjb25uZWN0b3JcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4wLCAwLjUsIDEuMCwgMS4wKTsgLy8gQmx1ZSBmb3IgQ0QgY29ubmVjdG9yXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIElmIHdlIGdvdCBoZXJlLCB0aGUgcGl4ZWwgaXMgb3V0c2lkZSB0aGUgY29ubmVjdG9yIHNoYXBlXG4gICAgICBkaXNjYXJkO1xuICAgIH1cbiAgYFxuKTtcblxuLy8gQWRkIGEgdW5pcXVlIGtleSBmb3IgSE1SIHB1cnBvc2VzIHdpdGggUjNGXG5HcmlkQ29ubmVjdG9yTWF0ZXJpYWwua2V5ID0gVEhSRUUuTWF0aFV0aWxzLmdlbmVyYXRlVVVJRCgpO1xuXG5leHBvcnQgeyBHcmlkQ29ubmVjdG9yTWF0ZXJpYWwgfTsgIl0sIm5hbWVzIjpbIlRIUkVFIiwic2hhZGVyTWF0ZXJpYWwiLCJHcmlkQ29ubmVjdG9yTWF0ZXJpYWwiLCJ1X3JhZGl1c0IiLCJ1X3JhZGl1c0EiLCJ1X3NwYWNpbmciLCJ1X3RoaWNrbmVzcyIsInVfY3VydmF0dXJlIiwidV9yZXNvbHV0aW9uIiwiVmVjdG9yMiIsInVfYWN0aXZlQ29ubmVjdG9yIiwidV9ncmlkU3RhdGUiLCJEYXRhVGV4dHVyZSIsIkZsb2F0MzJBcnJheSIsIlJHQkFGb3JtYXQiLCJGbG9hdFR5cGUiLCJrZXkiLCJNYXRoVXRpbHMiLCJnZW5lcmF0ZVVVSUQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/GridConnectorMaterial.js\n");

/***/ }),

/***/ "./components/SimpleConnectorMaterial.js":
/*!***********************************************!*\
  !*** ./components/SimpleConnectorMaterial.js ***!
  \***********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SimpleConnectorMaterial: () => (/* binding */ SimpleConnectorMaterial)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-three/drei */ \"@react-three/drei\");\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_react_three_drei__WEBPACK_IMPORTED_MODULE_1__);\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([three__WEBPACK_IMPORTED_MODULE_0__]);\nthree__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n// A very simple connector material for debugging\nconst SimpleConnectorMaterial = (0,_react_three_drei__WEBPACK_IMPORTED_MODULE_1__.shaderMaterial)(// Uniforms\n{\n    u_radiusB: 0.4,\n    u_radiusA: 0.5,\n    u_boxSize: 0.5,\n    u_spacing: 0.89,\n    u_activeConnector: 0,\n    u_gridState: new three__WEBPACK_IMPORTED_MODULE_0__.DataTexture(new Float32Array(4), 2, 2, three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat, three__WEBPACK_IMPORTED_MODULE_0__.FloatType)\n}, // Vertex Shader\n/*glsl*/ `\n    varying vec2 vUv;\n    varying vec2 vWorldPos;\n\n    void main() {\n      vUv = uv;\n\n      // World position of the vertex\n      vec4 worldPos = modelMatrix * vec4(position, 1.0);\n      vWorldPos = worldPos.xy;\n\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n  `, // Fragment Shader\n/*glsl*/ `\n    varying vec2 vUv;\n    varying vec2 vWorldPos; // Pixel position in world space\n\n    uniform float u_radiusB; // Radius for target circles B1, B2\n    uniform float u_radiusA; // Radius for defining circles A1, A2\n    uniform float u_boxSize; // Receive box size from JS\n    uniform float u_spacing; // Grid spacing between centers\n    uniform float u_activeConnector; // 0 = none, 1 = red (AB), 2 = blue (CD)\n    uniform sampler2D u_gridState; // Grid state texture\n\n    // Helper function to get circle state from the grid state texture\n    vec4 getGridState(int row, int col) {\n      return texture2D(u_gridState, vec2(float(col) + 0.5, float(row) + 0.5) / 2.0);\n    }\n\n    // SDF for a 2D circle\n    float sdCircle( vec2 p, vec2 c, float r ) {\n        return length(p-c) - r;\n    }\n\n    // SDF for a 2D Box\n    // p: point, c: center, b: half-size\n    float sdBox( vec2 p, vec2 c, vec2 b ) {\n        vec2 q = abs(p - c) - b;\n        return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n    }\n\n    // Smooth minimum function (use log/exp, base-e is fine)\n    float smin( float a, float b, float k ) {\n        float h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n        return mix( b, a, h ) - k*h*(1.0-h);\n        // Alternative formulation using exp:\n        // k = max(k, 0.0001); // Ensure k is positive\n        // return -log(exp(-k*a) + exp(-k*b))/k;\n    }\n\n    void main() {\n      // If no connector is active, discard immediately\n      if (u_activeConnector < 0.5) {\n        discard;\n        return;\n      }\n      \n      // Check if relevant circles are active\n      vec4 stateA = getGridState(0, 0); // Top-left\n      vec4 stateB = getGridState(1, 1); // Bottom-right\n      vec4 stateC = getGridState(1, 0); // Bottom-left  \n      vec4 stateD = getGridState(0, 1); // Top-right\n      \n      // Check if inner circles are active (red channel = inner circle)\n      bool circleB1Active = stateA.r > 0.5; // Top-left inner circle\n      bool circleB2Active = stateB.r > 0.5; // Bottom-right inner circle\n      bool circleA1Active = stateC.r > 0.5; // Bottom-left inner circle\n      bool circleA2Active = stateD.r > 0.5; // Top-right inner circle\n      \n      // Determine which connector to draw based on active connector state\n      bool drawRedConnector = u_activeConnector == 1.0;\n      bool drawBlueConnector = u_activeConnector == 2.0;\n      \n      // Verify the required circles are active for the selected connector\n      if (drawRedConnector && (!circleB1Active || !circleB2Active)) {\n        discard;\n        return;\n      }\n      \n      if (drawBlueConnector && (!circleA1Active || !circleA2Active)) {\n        discard;\n        return;\n      }\n    \n      // Calculate offset based on half the grid spacing\n      float offset = u_spacing * 0.5;\n      \n      // Define circle centers dynamically based on grid spacing\n      vec2 centerB1 = vec2(-offset, offset);    // Top-left\n      vec2 centerB2 = vec2(offset, -offset);    // Bottom-right\n      vec2 centerA1 = vec2(-offset, -offset);   // Bottom-left\n      vec2 centerA2 = vec2(offset, offset);     // Top-right\n\n      // Calculate SDFs for each circle - both inner and outer radii\n      // Inner circles (B radius)\n      float sdB1Inner = sdCircle(vWorldPos, centerB1, u_radiusB);\n      float sdB2Inner = sdCircle(vWorldPos, centerB2, u_radiusB);\n      float sdA1Inner = sdCircle(vWorldPos, centerA1, u_radiusB);\n      float sdA2Inner = sdCircle(vWorldPos, centerA2, u_radiusB);\n      \n      // Outer circles (A radius)\n      float sdB1Outer = sdCircle(vWorldPos, centerB1, u_radiusA);\n      float sdB2Outer = sdCircle(vWorldPos, centerB2, u_radiusA);\n      float sdA1Outer = sdCircle(vWorldPos, centerA1, u_radiusA);\n      float sdA2Outer = sdCircle(vWorldPos, centerA2, u_radiusA);\n      \n      // Calculate SDF for a bounding box using the uniform size\n      vec2 boxCenter = vec2(0.0);\n      vec2 boxHalfSize = vec2(u_boxSize);\n      float sdfBoundingBox = sdBox(vWorldPos, boxCenter, boxHalfSize);\n      \n      // Calculate connector shapes based on the new specifications\n      \n      // Red connector (B1-B2 diagonal):\n      // - Must be outside inner B circles (B1 and B2)\n      // - Must be outside outer A circles (A1 and A2)\n      float sdRedConnector = 1.0;\n      if (drawRedConnector) {\n        bool outsideInnerB = (sdB1Inner > 0.0) && (sdB2Inner > 0.0);\n        bool outsideOuterA = (sdA1Outer > 0.0) && (sdA2Outer > 0.0);\n        \n        if (outsideInnerB && outsideOuterA && sdfBoundingBox < 0.0) {\n          sdRedConnector = -1.0; // Inside the connector\n        }\n      }\n      \n      // Blue connector (A1-A2 diagonal):\n      // - Must be outside inner A circles (A1 and A2)\n      // - Must be outside outer B circles (B1 and B2)\n      float sdBlueConnector = 1.0;\n      if (drawBlueConnector) {\n        bool outsideInnerA = (sdA1Inner > 0.0) && (sdA2Inner > 0.0);\n        bool outsideOuterB = (sdB1Outer > 0.0) && (sdB2Outer > 0.0);\n        \n        if (outsideInnerA && outsideOuterB && sdfBoundingBox < 0.0) {\n          sdBlueConnector = -1.0; // Inside the connector\n        }\n      }\n      \n      // Determine if we're inside either connector\n      if (sdRedConnector < 0.0 || sdBlueConnector < 0.0) {\n        // Choose color based on which connector we're inside\n        if (sdRedConnector < 0.0) {\n          // Red connector\n          gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); // Red\n        } else {\n          // Blue connector\n          gl_FragColor = vec4(0.0, 0.5, 1.0, 1.0); // Blue\n        }\n      } else {\n        discard; // Outside both connectors\n      }\n    }\n  `);\n// Add a unique key for HMR purposes with R3F\nSimpleConnectorMaterial.key = three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.generateUUID();\n\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL1NpbXBsZUNvbm5lY3Rvck1hdGVyaWFsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBK0I7QUFDb0I7QUFFbkQsaURBQWlEO0FBQ2pELE1BQU1FLDBCQUEwQkQsaUVBQWNBLENBQzVDLFdBQVc7QUFDWDtJQUNFRSxXQUFXO0lBQ1hDLFdBQVc7SUFDWEMsV0FBVztJQUNYQyxXQUFXO0lBQ1hDLG1CQUFtQjtJQUNuQkMsYUFBYSxJQUFJUiw4Q0FBaUIsQ0FDaEMsSUFBSVUsYUFBYSxJQUNqQixHQUNBLEdBQ0FWLDZDQUFnQixFQUNoQkEsNENBQWU7QUFHbkIsR0FDQSxnQkFBZ0I7QUFDaEIsTUFBTSxHQUFFLENBQUM7Ozs7Ozs7Ozs7Ozs7RUFhVCxDQUFDLEVBQ0Qsa0JBQWtCO0FBQ2xCLE1BQU0sR0FBRSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQTRJVCxDQUFDO0FBR0gsNkNBQTZDO0FBQzdDRSx3QkFBd0JXLEdBQUcsR0FBR2IsNENBQWUsQ0FBQ2UsWUFBWTtBQUV2QiIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYmdsLWRvdC1ncmlkLW12cC8uL2NvbXBvbmVudHMvU2ltcGxlQ29ubmVjdG9yTWF0ZXJpYWwuanM/M2Y4YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyBzaGFkZXJNYXRlcmlhbCB9IGZyb20gJ0ByZWFjdC10aHJlZS9kcmVpJztcblxuLy8gQSB2ZXJ5IHNpbXBsZSBjb25uZWN0b3IgbWF0ZXJpYWwgZm9yIGRlYnVnZ2luZ1xuY29uc3QgU2ltcGxlQ29ubmVjdG9yTWF0ZXJpYWwgPSBzaGFkZXJNYXRlcmlhbChcbiAgLy8gVW5pZm9ybXNcbiAge1xuICAgIHVfcmFkaXVzQjogMC40LCAvLyBSYWRpdXMgZm9yIHRhcmdldCBjaXJjbGVzIEIxLCBCMiAoaW5uZXIpXG4gICAgdV9yYWRpdXNBOiAwLjUsIC8vIFJhZGl1cyBmb3IgZGVmaW5pbmcgY2lyY2xlcyBBMSwgQTIgKG91dGVyKVxuICAgIHVfYm94U2l6ZTogMC41LCAvLyBEZWZhdWx0IGhhbGYtc2l6ZSBmb3IgdGhlIGJvdW5kaW5nIGJveCBcbiAgICB1X3NwYWNpbmc6IDAuODksIC8vIEdyaWQgc3BhY2luZyBiZXR3ZWVuIGNlbnRlcnNcbiAgICB1X2FjdGl2ZUNvbm5lY3RvcjogMCwgLy8gMCA9IG5vbmUsIDEgPSByZWQgKEFCKSwgMiA9IGJsdWUgKENEKVxuICAgIHVfZ3JpZFN0YXRlOiBuZXcgVEhSRUUuRGF0YVRleHR1cmUoIC8vIEFkZCBncmlkIHN0YXRlIHRleHR1cmVcbiAgICAgIG5ldyBGbG9hdDMyQXJyYXkoNCksIC8vIFJHQkEgdmFsdWVzIHBlciBjZWxsXG4gICAgICAyLCAvLyB3aWR0aCAoZm9yIDJ4MiBncmlkKVxuICAgICAgMiwgLy8gaGVpZ2h0IChmb3IgMngyIGdyaWQpXG4gICAgICBUSFJFRS5SR0JBRm9ybWF0LFxuICAgICAgVEhSRUUuRmxvYXRUeXBlXG4gICAgKVxuICAgIC8vIHVfdGhpY2tuZXNzLCB1X2N1cnZhdHVyZSwgdV9yZXNvbHV0aW9uIGFyZSByZW1vdmVkIGFzIHRoZXkgYXJlIG5vdCBuZWVkZWQgZm9yIHRoaXMgU0RGIGxvZ2ljXG4gIH0sXG4gIC8vIFZlcnRleCBTaGFkZXJcbiAgLypnbHNsKi9gXG4gICAgdmFyeWluZyB2ZWMyIHZVdjtcbiAgICB2YXJ5aW5nIHZlYzIgdldvcmxkUG9zO1xuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgdlV2ID0gdXY7XG5cbiAgICAgIC8vIFdvcmxkIHBvc2l0aW9uIG9mIHRoZSB2ZXJ0ZXhcbiAgICAgIHZlYzQgd29ybGRQb3MgPSBtb2RlbE1hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XG4gICAgICB2V29ybGRQb3MgPSB3b3JsZFBvcy54eTtcblxuICAgICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTtcbiAgICB9XG4gIGAsXG4gIC8vIEZyYWdtZW50IFNoYWRlclxuICAvKmdsc2wqL2BcbiAgICB2YXJ5aW5nIHZlYzIgdlV2O1xuICAgIHZhcnlpbmcgdmVjMiB2V29ybGRQb3M7IC8vIFBpeGVsIHBvc2l0aW9uIGluIHdvcmxkIHNwYWNlXG5cbiAgICB1bmlmb3JtIGZsb2F0IHVfcmFkaXVzQjsgLy8gUmFkaXVzIGZvciB0YXJnZXQgY2lyY2xlcyBCMSwgQjJcbiAgICB1bmlmb3JtIGZsb2F0IHVfcmFkaXVzQTsgLy8gUmFkaXVzIGZvciBkZWZpbmluZyBjaXJjbGVzIEExLCBBMlxuICAgIHVuaWZvcm0gZmxvYXQgdV9ib3hTaXplOyAvLyBSZWNlaXZlIGJveCBzaXplIGZyb20gSlNcbiAgICB1bmlmb3JtIGZsb2F0IHVfc3BhY2luZzsgLy8gR3JpZCBzcGFjaW5nIGJldHdlZW4gY2VudGVyc1xuICAgIHVuaWZvcm0gZmxvYXQgdV9hY3RpdmVDb25uZWN0b3I7IC8vIDAgPSBub25lLCAxID0gcmVkIChBQiksIDIgPSBibHVlIChDRClcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1X2dyaWRTdGF0ZTsgLy8gR3JpZCBzdGF0ZSB0ZXh0dXJlXG5cbiAgICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IGNpcmNsZSBzdGF0ZSBmcm9tIHRoZSBncmlkIHN0YXRlIHRleHR1cmVcbiAgICB2ZWM0IGdldEdyaWRTdGF0ZShpbnQgcm93LCBpbnQgY29sKSB7XG4gICAgICByZXR1cm4gdGV4dHVyZTJEKHVfZ3JpZFN0YXRlLCB2ZWMyKGZsb2F0KGNvbCkgKyAwLjUsIGZsb2F0KHJvdykgKyAwLjUpIC8gMi4wKTtcbiAgICB9XG5cbiAgICAvLyBTREYgZm9yIGEgMkQgY2lyY2xlXG4gICAgZmxvYXQgc2RDaXJjbGUoIHZlYzIgcCwgdmVjMiBjLCBmbG9hdCByICkge1xuICAgICAgICByZXR1cm4gbGVuZ3RoKHAtYykgLSByO1xuICAgIH1cblxuICAgIC8vIFNERiBmb3IgYSAyRCBCb3hcbiAgICAvLyBwOiBwb2ludCwgYzogY2VudGVyLCBiOiBoYWxmLXNpemVcbiAgICBmbG9hdCBzZEJveCggdmVjMiBwLCB2ZWMyIGMsIHZlYzIgYiApIHtcbiAgICAgICAgdmVjMiBxID0gYWJzKHAgLSBjKSAtIGI7XG4gICAgICAgIHJldHVybiBsZW5ndGgobWF4KHEsMC4wKSkgKyBtaW4obWF4KHEueCxxLnkpLDAuMCk7XG4gICAgfVxuXG4gICAgLy8gU21vb3RoIG1pbmltdW0gZnVuY3Rpb24gKHVzZSBsb2cvZXhwLCBiYXNlLWUgaXMgZmluZSlcbiAgICBmbG9hdCBzbWluKCBmbG9hdCBhLCBmbG9hdCBiLCBmbG9hdCBrICkge1xuICAgICAgICBmbG9hdCBoID0gY2xhbXAoIDAuNSArIDAuNSooYi1hKS9rLCAwLjAsIDEuMCApO1xuICAgICAgICByZXR1cm4gbWl4KCBiLCBhLCBoICkgLSBrKmgqKDEuMC1oKTtcbiAgICAgICAgLy8gQWx0ZXJuYXRpdmUgZm9ybXVsYXRpb24gdXNpbmcgZXhwOlxuICAgICAgICAvLyBrID0gbWF4KGssIDAuMDAwMSk7IC8vIEVuc3VyZSBrIGlzIHBvc2l0aXZlXG4gICAgICAgIC8vIHJldHVybiAtbG9nKGV4cCgtayphKSArIGV4cCgtaypiKSkvaztcbiAgICB9XG5cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICAvLyBJZiBubyBjb25uZWN0b3IgaXMgYWN0aXZlLCBkaXNjYXJkIGltbWVkaWF0ZWx5XG4gICAgICBpZiAodV9hY3RpdmVDb25uZWN0b3IgPCAwLjUpIHtcbiAgICAgICAgZGlzY2FyZDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiByZWxldmFudCBjaXJjbGVzIGFyZSBhY3RpdmVcbiAgICAgIHZlYzQgc3RhdGVBID0gZ2V0R3JpZFN0YXRlKDAsIDApOyAvLyBUb3AtbGVmdFxuICAgICAgdmVjNCBzdGF0ZUIgPSBnZXRHcmlkU3RhdGUoMSwgMSk7IC8vIEJvdHRvbS1yaWdodFxuICAgICAgdmVjNCBzdGF0ZUMgPSBnZXRHcmlkU3RhdGUoMSwgMCk7IC8vIEJvdHRvbS1sZWZ0ICBcbiAgICAgIHZlYzQgc3RhdGVEID0gZ2V0R3JpZFN0YXRlKDAsIDEpOyAvLyBUb3AtcmlnaHRcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgaW5uZXIgY2lyY2xlcyBhcmUgYWN0aXZlIChyZWQgY2hhbm5lbCA9IGlubmVyIGNpcmNsZSlcbiAgICAgIGJvb2wgY2lyY2xlQjFBY3RpdmUgPSBzdGF0ZUEuciA+IDAuNTsgLy8gVG9wLWxlZnQgaW5uZXIgY2lyY2xlXG4gICAgICBib29sIGNpcmNsZUIyQWN0aXZlID0gc3RhdGVCLnIgPiAwLjU7IC8vIEJvdHRvbS1yaWdodCBpbm5lciBjaXJjbGVcbiAgICAgIGJvb2wgY2lyY2xlQTFBY3RpdmUgPSBzdGF0ZUMuciA+IDAuNTsgLy8gQm90dG9tLWxlZnQgaW5uZXIgY2lyY2xlXG4gICAgICBib29sIGNpcmNsZUEyQWN0aXZlID0gc3RhdGVELnIgPiAwLjU7IC8vIFRvcC1yaWdodCBpbm5lciBjaXJjbGVcbiAgICAgIFxuICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIGNvbm5lY3RvciB0byBkcmF3IGJhc2VkIG9uIGFjdGl2ZSBjb25uZWN0b3Igc3RhdGVcbiAgICAgIGJvb2wgZHJhd1JlZENvbm5lY3RvciA9IHVfYWN0aXZlQ29ubmVjdG9yID09IDEuMDtcbiAgICAgIGJvb2wgZHJhd0JsdWVDb25uZWN0b3IgPSB1X2FjdGl2ZUNvbm5lY3RvciA9PSAyLjA7XG4gICAgICBcbiAgICAgIC8vIFZlcmlmeSB0aGUgcmVxdWlyZWQgY2lyY2xlcyBhcmUgYWN0aXZlIGZvciB0aGUgc2VsZWN0ZWQgY29ubmVjdG9yXG4gICAgICBpZiAoZHJhd1JlZENvbm5lY3RvciAmJiAoIWNpcmNsZUIxQWN0aXZlIHx8ICFjaXJjbGVCMkFjdGl2ZSkpIHtcbiAgICAgICAgZGlzY2FyZDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoZHJhd0JsdWVDb25uZWN0b3IgJiYgKCFjaXJjbGVBMUFjdGl2ZSB8fCAhY2lyY2xlQTJBY3RpdmUpKSB7XG4gICAgICAgIGRpc2NhcmQ7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICBcbiAgICAgIC8vIENhbGN1bGF0ZSBvZmZzZXQgYmFzZWQgb24gaGFsZiB0aGUgZ3JpZCBzcGFjaW5nXG4gICAgICBmbG9hdCBvZmZzZXQgPSB1X3NwYWNpbmcgKiAwLjU7XG4gICAgICBcbiAgICAgIC8vIERlZmluZSBjaXJjbGUgY2VudGVycyBkeW5hbWljYWxseSBiYXNlZCBvbiBncmlkIHNwYWNpbmdcbiAgICAgIHZlYzIgY2VudGVyQjEgPSB2ZWMyKC1vZmZzZXQsIG9mZnNldCk7ICAgIC8vIFRvcC1sZWZ0XG4gICAgICB2ZWMyIGNlbnRlckIyID0gdmVjMihvZmZzZXQsIC1vZmZzZXQpOyAgICAvLyBCb3R0b20tcmlnaHRcbiAgICAgIHZlYzIgY2VudGVyQTEgPSB2ZWMyKC1vZmZzZXQsIC1vZmZzZXQpOyAgIC8vIEJvdHRvbS1sZWZ0XG4gICAgICB2ZWMyIGNlbnRlckEyID0gdmVjMihvZmZzZXQsIG9mZnNldCk7ICAgICAvLyBUb3AtcmlnaHRcblxuICAgICAgLy8gQ2FsY3VsYXRlIFNERnMgZm9yIGVhY2ggY2lyY2xlIC0gYm90aCBpbm5lciBhbmQgb3V0ZXIgcmFkaWlcbiAgICAgIC8vIElubmVyIGNpcmNsZXMgKEIgcmFkaXVzKVxuICAgICAgZmxvYXQgc2RCMUlubmVyID0gc2RDaXJjbGUodldvcmxkUG9zLCBjZW50ZXJCMSwgdV9yYWRpdXNCKTtcbiAgICAgIGZsb2F0IHNkQjJJbm5lciA9IHNkQ2lyY2xlKHZXb3JsZFBvcywgY2VudGVyQjIsIHVfcmFkaXVzQik7XG4gICAgICBmbG9hdCBzZEExSW5uZXIgPSBzZENpcmNsZSh2V29ybGRQb3MsIGNlbnRlckExLCB1X3JhZGl1c0IpO1xuICAgICAgZmxvYXQgc2RBMklubmVyID0gc2RDaXJjbGUodldvcmxkUG9zLCBjZW50ZXJBMiwgdV9yYWRpdXNCKTtcbiAgICAgIFxuICAgICAgLy8gT3V0ZXIgY2lyY2xlcyAoQSByYWRpdXMpXG4gICAgICBmbG9hdCBzZEIxT3V0ZXIgPSBzZENpcmNsZSh2V29ybGRQb3MsIGNlbnRlckIxLCB1X3JhZGl1c0EpO1xuICAgICAgZmxvYXQgc2RCMk91dGVyID0gc2RDaXJjbGUodldvcmxkUG9zLCBjZW50ZXJCMiwgdV9yYWRpdXNBKTtcbiAgICAgIGZsb2F0IHNkQTFPdXRlciA9IHNkQ2lyY2xlKHZXb3JsZFBvcywgY2VudGVyQTEsIHVfcmFkaXVzQSk7XG4gICAgICBmbG9hdCBzZEEyT3V0ZXIgPSBzZENpcmNsZSh2V29ybGRQb3MsIGNlbnRlckEyLCB1X3JhZGl1c0EpO1xuICAgICAgXG4gICAgICAvLyBDYWxjdWxhdGUgU0RGIGZvciBhIGJvdW5kaW5nIGJveCB1c2luZyB0aGUgdW5pZm9ybSBzaXplXG4gICAgICB2ZWMyIGJveENlbnRlciA9IHZlYzIoMC4wKTtcbiAgICAgIHZlYzIgYm94SGFsZlNpemUgPSB2ZWMyKHVfYm94U2l6ZSk7XG4gICAgICBmbG9hdCBzZGZCb3VuZGluZ0JveCA9IHNkQm94KHZXb3JsZFBvcywgYm94Q2VudGVyLCBib3hIYWxmU2l6ZSk7XG4gICAgICBcbiAgICAgIC8vIENhbGN1bGF0ZSBjb25uZWN0b3Igc2hhcGVzIGJhc2VkIG9uIHRoZSBuZXcgc3BlY2lmaWNhdGlvbnNcbiAgICAgIFxuICAgICAgLy8gUmVkIGNvbm5lY3RvciAoQjEtQjIgZGlhZ29uYWwpOlxuICAgICAgLy8gLSBNdXN0IGJlIG91dHNpZGUgaW5uZXIgQiBjaXJjbGVzIChCMSBhbmQgQjIpXG4gICAgICAvLyAtIE11c3QgYmUgb3V0c2lkZSBvdXRlciBBIGNpcmNsZXMgKEExIGFuZCBBMilcbiAgICAgIGZsb2F0IHNkUmVkQ29ubmVjdG9yID0gMS4wO1xuICAgICAgaWYgKGRyYXdSZWRDb25uZWN0b3IpIHtcbiAgICAgICAgYm9vbCBvdXRzaWRlSW5uZXJCID0gKHNkQjFJbm5lciA+IDAuMCkgJiYgKHNkQjJJbm5lciA+IDAuMCk7XG4gICAgICAgIGJvb2wgb3V0c2lkZU91dGVyQSA9IChzZEExT3V0ZXIgPiAwLjApICYmIChzZEEyT3V0ZXIgPiAwLjApO1xuICAgICAgICBcbiAgICAgICAgaWYgKG91dHNpZGVJbm5lckIgJiYgb3V0c2lkZU91dGVyQSAmJiBzZGZCb3VuZGluZ0JveCA8IDAuMCkge1xuICAgICAgICAgIHNkUmVkQ29ubmVjdG9yID0gLTEuMDsgLy8gSW5zaWRlIHRoZSBjb25uZWN0b3JcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBCbHVlIGNvbm5lY3RvciAoQTEtQTIgZGlhZ29uYWwpOlxuICAgICAgLy8gLSBNdXN0IGJlIG91dHNpZGUgaW5uZXIgQSBjaXJjbGVzIChBMSBhbmQgQTIpXG4gICAgICAvLyAtIE11c3QgYmUgb3V0c2lkZSBvdXRlciBCIGNpcmNsZXMgKEIxIGFuZCBCMilcbiAgICAgIGZsb2F0IHNkQmx1ZUNvbm5lY3RvciA9IDEuMDtcbiAgICAgIGlmIChkcmF3Qmx1ZUNvbm5lY3Rvcikge1xuICAgICAgICBib29sIG91dHNpZGVJbm5lckEgPSAoc2RBMUlubmVyID4gMC4wKSAmJiAoc2RBMklubmVyID4gMC4wKTtcbiAgICAgICAgYm9vbCBvdXRzaWRlT3V0ZXJCID0gKHNkQjFPdXRlciA+IDAuMCkgJiYgKHNkQjJPdXRlciA+IDAuMCk7XG4gICAgICAgIFxuICAgICAgICBpZiAob3V0c2lkZUlubmVyQSAmJiBvdXRzaWRlT3V0ZXJCICYmIHNkZkJvdW5kaW5nQm94IDwgMC4wKSB7XG4gICAgICAgICAgc2RCbHVlQ29ubmVjdG9yID0gLTEuMDsgLy8gSW5zaWRlIHRoZSBjb25uZWN0b3JcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBEZXRlcm1pbmUgaWYgd2UncmUgaW5zaWRlIGVpdGhlciBjb25uZWN0b3JcbiAgICAgIGlmIChzZFJlZENvbm5lY3RvciA8IDAuMCB8fCBzZEJsdWVDb25uZWN0b3IgPCAwLjApIHtcbiAgICAgICAgLy8gQ2hvb3NlIGNvbG9yIGJhc2VkIG9uIHdoaWNoIGNvbm5lY3RvciB3ZSdyZSBpbnNpZGVcbiAgICAgICAgaWYgKHNkUmVkQ29ubmVjdG9yIDwgMC4wKSB7XG4gICAgICAgICAgLy8gUmVkIGNvbm5lY3RvclxuICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMS4wLCAwLjAsIDAuMCwgMS4wKTsgLy8gUmVkXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQmx1ZSBjb25uZWN0b3JcbiAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuMCwgMC41LCAxLjAsIDEuMCk7IC8vIEJsdWVcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGlzY2FyZDsgLy8gT3V0c2lkZSBib3RoIGNvbm5lY3RvcnNcbiAgICAgIH1cbiAgICB9XG4gIGBcbik7XG5cbi8vIEFkZCBhIHVuaXF1ZSBrZXkgZm9yIEhNUiBwdXJwb3NlcyB3aXRoIFIzRlxuU2ltcGxlQ29ubmVjdG9yTWF0ZXJpYWwua2V5ID0gVEhSRUUuTWF0aFV0aWxzLmdlbmVyYXRlVVVJRCgpO1xuXG5leHBvcnQgeyBTaW1wbGVDb25uZWN0b3JNYXRlcmlhbCB9OyAiXSwibmFtZXMiOlsiVEhSRUUiLCJzaGFkZXJNYXRlcmlhbCIsIlNpbXBsZUNvbm5lY3Rvck1hdGVyaWFsIiwidV9yYWRpdXNCIiwidV9yYWRpdXNBIiwidV9ib3hTaXplIiwidV9zcGFjaW5nIiwidV9hY3RpdmVDb25uZWN0b3IiLCJ1X2dyaWRTdGF0ZSIsIkRhdGFUZXh0dXJlIiwiRmxvYXQzMkFycmF5IiwiUkdCQUZvcm1hdCIsIkZsb2F0VHlwZSIsImtleSIsIk1hdGhVdGlscyIsImdlbmVyYXRlVVVJRCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./components/SimpleConnectorMaterial.js\n");

/***/ }),

/***/ "./components/WebGLCanvas.js":
/*!***********************************!*\
  !*** ./components/WebGLCanvas.js ***!
  \***********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ WebGLCanvas)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-three/fiber */ \"@react-three/fiber\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-three/drei */ \"@react-three/drei\");\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_react_three_drei__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var leva__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! leva */ \"leva\");\n/* harmony import */ var leva__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(leva__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _ConnectorMaterial__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ConnectorMaterial */ \"./components/ConnectorMaterial.js\");\n/* harmony import */ var _GridConnectorMaterial__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./GridConnectorMaterial */ \"./components/GridConnectorMaterial.js\");\n/* harmony import */ var _SimpleConnectorMaterial__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./SimpleConnectorMaterial */ \"./components/SimpleConnectorMaterial.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([three__WEBPACK_IMPORTED_MODULE_4__, _ConnectorMaterial__WEBPACK_IMPORTED_MODULE_6__, _GridConnectorMaterial__WEBPACK_IMPORTED_MODULE_7__, _SimpleConnectorMaterial__WEBPACK_IMPORTED_MODULE_8__]);\n([three__WEBPACK_IMPORTED_MODULE_4__, _ConnectorMaterial__WEBPACK_IMPORTED_MODULE_6__, _GridConnectorMaterial__WEBPACK_IMPORTED_MODULE_7__, _SimpleConnectorMaterial__WEBPACK_IMPORTED_MODULE_8__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n\n // Import leva with button instead of monitor\n // We'll create this shader material\n // Import our new connector material\n // Import simple connector for debugging\n// Extend THREE namespace with our custom shader materials\n(0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.extend)({\n    ConnectorMaterial: _ConnectorMaterial__WEBPACK_IMPORTED_MODULE_6__.ConnectorMaterial,\n    GridConnectorMaterial: _GridConnectorMaterial__WEBPACK_IMPORTED_MODULE_7__.GridConnectorMaterial,\n    SimpleConnectorMaterial: _SimpleConnectorMaterial__WEBPACK_IMPORTED_MODULE_8__.SimpleConnectorMaterial\n});\nconst GRID_SIZE = 2;\nconst TOTAL_INSTANCES = GRID_SIZE * GRID_SIZE;\n// Helper to convert grid coords to instance ID\nconst getInstanceId = (row, col)=>row * GRID_SIZE + col;\n// Helper to convert instance ID to grid coords\nconst getGridCoords = (id)=>({\n        row: Math.floor(id / GRID_SIZE),\n        col: id % GRID_SIZE\n    });\n// Create a reusable dummy object for matrix calculation\nconst dummy = new three__WEBPACK_IMPORTED_MODULE_4__.Object3D();\n// Fixed base values\nconst BASE_VALUES = {\n    radiusB: 0.4,\n    radiusA: 0.5,\n    boxSize: 0.5,\n    baseSpacing: 0.89 // Reference spacing for scaling\n};\nfunction Scene() {\n    // Controls for radius, spacing, and debugging\n    const { gridSpacing, zoom, debug, showSimple } = (0,leva__WEBPACK_IMPORTED_MODULE_5__.useControls)({\n        gridSpacing: {\n            value: 0.89,\n            min: 0.5,\n            max: 2.0,\n            step: 0.01,\n            label: \"Grid Spacing\"\n        },\n        zoom: {\n            value: 1.0,\n            min: 0.5,\n            max: 3.0,\n            step: 0.1,\n            label: \"Camera Zoom\"\n        },\n        debug: {\n            value: true,\n            label: \"Debug Mode\"\n        },\n        showSimple: {\n            value: true,\n            label: \"Use Simple Connector\"\n        }\n    });\n    // Calculate scaled values for display\n    const scaleFactor = gridSpacing / BASE_VALUES.baseSpacing;\n    const scaledRadiusB = (BASE_VALUES.radiusB * scaleFactor).toFixed(3);\n    const scaledRadiusA = (BASE_VALUES.radiusA * scaleFactor).toFixed(3);\n    const scaledBoxSize = (BASE_VALUES.boxSize * scaleFactor).toFixed(3);\n    // Display current values in a separate control panel\n    (0,leva__WEBPACK_IMPORTED_MODULE_5__.useControls)(\"Current Values\", {\n        innerRadius: {\n            value: scaledRadiusB,\n            label: \"Inner Radius (B)\",\n            disabled: true\n        },\n        outerRadius: {\n            value: scaledRadiusA,\n            label: \"Outer Radius (A)\",\n            disabled: true\n        },\n        boxSize: {\n            value: scaledBoxSize,\n            label: \"BBox Size\",\n            disabled: true\n        }\n    });\n    // State for the 2x2 grid visibility\n    const [gridState, setGridState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([\n        // Initial state - all circles visible\n        [\n            {\n                showInner: true,\n                showOuter: true\n            },\n            {\n                showInner: true,\n                showOuter: true\n            }\n        ],\n        [\n            {\n                showInner: true,\n                showOuter: true\n            },\n            {\n                showInner: true,\n                showOuter: true\n            }\n        ]\n    ]);\n    // State for active connector - 0: none, 1: red (AB), 2: blue (CD)\n    const [activeConnector, setActiveConnector] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const materialRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    const instancedMeshRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    const gridHelperRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    const cameraRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    // Reference for connector material\n    const gridConnectorMaterialRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    const connectorMeshRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    const debugMeshRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    // Reference for simple connector material (for debugging)\n    const simpleConnectorMaterialRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    const simpleConnectorMeshRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    // Attributes for instance visibility data\n    const instanceShowInner = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>new Float32Array(TOTAL_INSTANCES), []);\n    const instanceShowOuter = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>new Float32Array(TOTAL_INSTANCES), []);\n    // Store positions for click detection\n    const instancePositions = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(Array(TOTAL_INSTANCES).fill().map(()=>new three__WEBPACK_IMPORTED_MODULE_4__.Vector3()));\n    // Access three.js helpers\n    const { camera, raycaster, mouse } = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.useThree)();\n    // Log the grid state for debugging\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        console.log(\"Grid State:\", gridState);\n    }, [\n        gridState\n    ]);\n    // Create a data texture to store grid state for the connector shader\n    const gridStateTexture = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        const data = new Float32Array(4 * 4); // RGBA for each of the 4 cells\n        const texture = new three__WEBPACK_IMPORTED_MODULE_4__.DataTexture(data, 2, 2, three__WEBPACK_IMPORTED_MODULE_4__.RGBAFormat, three__WEBPACK_IMPORTED_MODULE_4__.FloatType);\n        texture.needsUpdate = true;\n        return texture;\n    }, []);\n    // Update the grid state texture and uniforms when controls change\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const data = gridStateTexture.image.data;\n        for(let row = 0; row < GRID_SIZE; row++){\n            for(let col = 0; col < GRID_SIZE; col++){\n                const idx = (row * GRID_SIZE + col) * 4;\n                data[idx] = gridState[row][col].showInner ? 1.0 : 0.0; // R - Inner circle\n                data[idx + 1] = gridState[row][col].showOuter ? 1.0 : 0.0; // G - Outer circle\n                data[idx + 2] = 0.0; // B - unused\n                data[idx + 3] = 1.0; // A - opacity\n            }\n        }\n        gridStateTexture.needsUpdate = true;\n        console.log(\"Updated grid state texture\", data);\n        // Calculate scale factor based on ratio to base grid spacing\n        const scaleFactor = gridSpacing / BASE_VALUES.baseSpacing;\n        // Update connector material uniforms (original grid one)\n        if (gridConnectorMaterialRef.current) {\n            gridConnectorMaterialRef.current.uniforms.u_radiusB.value = BASE_VALUES.radiusB * scaleFactor;\n            gridConnectorMaterialRef.current.uniforms.u_radiusA.value = BASE_VALUES.radiusA * scaleFactor;\n            gridConnectorMaterialRef.current.uniforms.u_spacing.value = gridSpacing;\n            gridConnectorMaterialRef.current.uniforms.u_gridState.value = gridStateTexture;\n            gridConnectorMaterialRef.current.uniforms.u_activeConnector = {\n                value: activeConnector\n            };\n            // Pass the connector thickness to the shader (if it exists - might remove later)\n            if (gridConnectorMaterialRef.current.uniforms.u_thickness) {\n            // gridConnectorMaterialRef.current.uniforms.u_thickness.value = connectorThickness; // Keep commented out for now\n            }\n            // Pass the curvature parameter (if it exists - might remove later)\n            if (gridConnectorMaterialRef.current.uniforms.u_curvature) {\n            // gridConnectorMaterialRef.current.uniforms.u_curvature.value = connectorCurvature; // Keep commented out for now\n            }\n        }\n        // Update simple connector material uniforms\n        if (simpleConnectorMaterialRef.current) {\n            // Scale the radius and box size values proportionally\n            simpleConnectorMaterialRef.current.uniforms.u_radiusB.value = BASE_VALUES.radiusB * scaleFactor;\n            simpleConnectorMaterialRef.current.uniforms.u_radiusA.value = BASE_VALUES.radiusA * scaleFactor;\n            simpleConnectorMaterialRef.current.uniforms.u_boxSize.value = BASE_VALUES.boxSize * scaleFactor;\n            simpleConnectorMaterialRef.current.uniforms.u_spacing.value = gridSpacing;\n            simpleConnectorMaterialRef.current.uniforms.u_gridState.value = gridStateTexture;\n            simpleConnectorMaterialRef.current.uniforms.u_activeConnector = {\n                value: activeConnector\n            };\n        }\n    }, [\n        gridState,\n        gridStateTexture,\n        gridSpacing,\n        debug,\n        showSimple,\n        activeConnector\n    ]);\n    // Update camera zoom based on control\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (camera) {\n            camera.zoom = 100 * (1 / zoom); // Adjust as needed for scale\n            camera.updateProjectionMatrix();\n        }\n    }, [\n        camera,\n        zoom\n    ]);\n    // Update instance matrices and visibility attributes based on state\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!instancedMeshRef.current) return;\n        let instanceId = 0;\n        // Calculate grid starting position\n        const startOffset = (GRID_SIZE - 1) * 0.5 * gridSpacing;\n        for(let row = 0; row < GRID_SIZE; row++){\n            for(let col = 0; col < GRID_SIZE; col++){\n                // Position at grid intersections\n                const x = col * gridSpacing - startOffset;\n                const y = -(row * gridSpacing - startOffset); // Y is inverted for screen coordinates\n                // Update the dummy object's position\n                dummy.position.set(x, y, 0);\n                dummy.updateMatrix();\n                // Set the instance matrix\n                instancedMeshRef.current.setMatrixAt(instanceId, dummy.matrix);\n                // Store position for click detection\n                instancePositions.current[instanceId].set(x, y, 0);\n                // Update visibility attributes\n                instanceShowInner[instanceId] = gridState[row][col].showInner ? 1.0 : 0.0;\n                instanceShowOuter[instanceId] = gridState[row][col].showOuter ? 1.0 : 0.0;\n                instanceId++;\n            }\n        }\n        // Mark attributes and matrix for update\n        instancedMeshRef.current.geometry.attributes.a_instanceShowInner.needsUpdate = true;\n        instancedMeshRef.current.geometry.attributes.a_instanceShowOuter.needsUpdate = true;\n        instancedMeshRef.current.instanceMatrix.needsUpdate = true;\n        // Update global uniforms with the radius values\n        if (materialRef.current) {\n            // Calculate scale factor based on ratio to base grid spacing\n            const scaleFactor = gridSpacing / BASE_VALUES.baseSpacing;\n            materialRef.current.uniforms.u_radiusB.value = BASE_VALUES.radiusB * scaleFactor;\n            materialRef.current.uniforms.u_radiusA.value = BASE_VALUES.radiusA * scaleFactor;\n            materialRef.current.uniforms.u_spacing.value = gridSpacing;\n        }\n        // Update grid helper to match spacing\n        if (gridHelperRef.current) {\n            gridHelperRef.current.scale.set(gridSpacing, gridSpacing, 1);\n        }\n    }, [\n        gridState,\n        gridSpacing,\n        instanceShowInner,\n        instanceShowOuter\n    ]);\n    // Handle click on the canvas\n    const handleClick = (event)=>{\n        if (!instancedMeshRef.current) return;\n        // Calculate scale factor based on ratio to base grid spacing\n        const scaleFactor = gridSpacing / BASE_VALUES.baseSpacing;\n        // Scale the radius values for hit detection\n        const scaledRadiusB = BASE_VALUES.radiusB * scaleFactor;\n        const scaledRadiusA = BASE_VALUES.radiusA * scaleFactor;\n        // Grid positions for detecting connector area\n        const gridOffset = gridSpacing * 0.5;\n        const centerA = new three__WEBPACK_IMPORTED_MODULE_4__.Vector2(-gridOffset, gridOffset); // Top-left (A)\n        const centerB = new three__WEBPACK_IMPORTED_MODULE_4__.Vector2(gridOffset, -gridOffset); // Bottom-right (B)\n        const centerC = new three__WEBPACK_IMPORTED_MODULE_4__.Vector2(-gridOffset, -gridOffset); // Bottom-left (C)\n        const centerD = new three__WEBPACK_IMPORTED_MODULE_4__.Vector2(gridOffset, gridOffset); // Top-right (D)\n        // Create a 2D point from the click event for easier calculations\n        const clickPoint = new three__WEBPACK_IMPORTED_MODULE_4__.Vector2(event.point.x, event.point.y);\n        // Check if we clicked on a connector area\n        const isInABConnectorArea = isPointInConnectorArea(clickPoint, centerA, centerB, scaledRadiusB, scaledRadiusA);\n        const isInCDConnectorArea = isPointInConnectorArea(clickPoint, centerC, centerD, scaledRadiusB, scaledRadiusA);\n        if (isInABConnectorArea || isInCDConnectorArea) {\n            // Clicked in a connector area, cycle the active connector state\n            setActiveConnector((prevState)=>{\n                if (prevState === 0) {\n                    // None -> First connector (Red AB or Blue CD based on which area clicked)\n                    return isInABConnectorArea ? 1 : 2;\n                } else if (prevState === 1 && isInABConnectorArea) {\n                    // Red AB -> Blue CD\n                    return 2;\n                } else if (prevState === 2 && isInCDConnectorArea) {\n                    // Blue CD -> None\n                    return 0;\n                } else {\n                    // Toggle between current connector and None\n                    return prevState === 0 ? isInABConnectorArea ? 1 : 2 : 0;\n                }\n            });\n            return; // Exit after handling connector click\n        }\n        // If no instance was hit, return\n        if (event.instanceId === undefined) return;\n        const instanceId = event.instanceId;\n        const { row, col } = getGridCoords(instanceId);\n        console.log(`Clicked instance: row=${row}, col=${col}`);\n        const currentState = gridState[row][col];\n        // Get instance position from our stored reference\n        const instancePosition = instancePositions.current[instanceId];\n        // Create a copy of the click point\n        const pointCopy = event.point.clone();\n        // Calculate distance from click to instance center\n        const distFromCenter = pointCopy.distanceTo(instancePosition);\n        let newInner = currentState.showInner;\n        let newOuter = currentState.showOuter;\n        if (distFromCenter <= scaledRadiusB) {\n            // Clicked inner circle\n            newInner = !currentState.showInner;\n            console.log(`Toggling inner circle: ${currentState.showInner} -> ${newInner}`);\n            // Check if toggling off an inner circle that was part of an active connector\n            if (!newInner) {\n                // Top-left circle is part of red connector\n                if (row === 0 && col === 0 && activeConnector === 1) {\n                    setActiveConnector(0);\n                } else if (row === 1 && col === 1 && activeConnector === 1) {\n                    setActiveConnector(0);\n                } else if (row === 1 && col === 0 && activeConnector === 2) {\n                    setActiveConnector(0);\n                } else if (row === 0 && col === 1 && activeConnector === 2) {\n                    setActiveConnector(0);\n                }\n            } else if (newInner) {\n                // Only activate connector if no connector is currently active\n                if (activeConnector === 0) {\n                    // Check if this completes a diagonal pair - Red connector (top-left to bottom-right)\n                    if (row === 0 && col === 0 && gridState[1][1].showInner || row === 1 && col === 1 && gridState[0][0].showInner) {\n                        setActiveConnector(1); // Activate red connector\n                    } else if (row === 1 && col === 0 && gridState[0][1].showInner || row === 0 && col === 1 && gridState[1][0].showInner) {\n                        setActiveConnector(2); // Activate blue connector\n                    }\n                }\n            }\n        } else if (distFromCenter <= scaledRadiusA) {\n            // Clicked outer circle\n            newOuter = !currentState.showOuter;\n            console.log(`Toggling outer circle: ${currentState.showOuter} -> ${newOuter}`);\n        }\n        if (newInner !== currentState.showInner || newOuter !== currentState.showOuter) {\n            setGridState((prevState)=>{\n                const newState = JSON.parse(JSON.stringify(prevState)); // Deep copy\n                newState[row][col] = {\n                    showInner: newInner,\n                    showOuter: newOuter\n                };\n                return newState;\n            });\n        }\n    };\n    // Helper function to determine if a point is in the connector area\n    const isPointInConnectorArea = (point, center1, center2, innerRadius, outerRadius)=>{\n        // Check that point is not inside either inner circle\n        const distToCenter1 = point.distanceTo(center1);\n        const distToCenter2 = point.distanceTo(center2);\n        if (distToCenter1 < innerRadius || distToCenter2 < innerRadius) {\n            return false; // Inside an inner circle\n        }\n        // Project point onto the line connecting the centers\n        const direction = new three__WEBPACK_IMPORTED_MODULE_4__.Vector2().subVectors(center2, center1).normalize();\n        const center1ToPoint = new three__WEBPACK_IMPORTED_MODULE_4__.Vector2().subVectors(point, center1);\n        const projectionLength = center1ToPoint.dot(direction);\n        // Check if projection falls between the two centers (with some buffer)\n        const distanceBetweenCenters = center1.distanceTo(center2);\n        if (projectionLength < -outerRadius || projectionLength > distanceBetweenCenters + outerRadius) {\n            return false; // Outside the region between circles\n        }\n        // Calculate perpendicular distance from point to line\n        const projectedPoint = new three__WEBPACK_IMPORTED_MODULE_4__.Vector2().copy(center1).addScaledVector(direction, projectionLength);\n        const perpDistance = point.distanceTo(projectedPoint);\n        // Define a reasonable width for the connector area\n        const connectorWidth = outerRadius * 0.8;\n        return perpDistance < connectorWidth;\n    };\n    // Calculate plane size based on the grid size and spacing\n    const connectorPlaneSize = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>GRID_SIZE * gridSpacing + Math.max(BASE_VALUES.radiusA, BASE_VALUES.radiusB) * 2, [\n        gridSpacing,\n        BASE_VALUES.radiusA,\n        BASE_VALUES.radiusB\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            debug && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"mesh\", {\n                ref: debugMeshRef,\n                position: [\n                    0,\n                    0,\n                    -0.2\n                ],\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"planeGeometry\", {\n                        args: [\n                            connectorPlaneSize,\n                            connectorPlaneSize\n                        ]\n                    }, void 0, false, {\n                        fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                        lineNumber: 386,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"meshBasicMaterial\", {\n                        color: \"blue\",\n                        opacity: 0.1,\n                        transparent: true\n                    }, void 0, false, {\n                        fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                        lineNumber: 387,\n                        columnNumber: 11\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                lineNumber: 385,\n                columnNumber: 9\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"mesh\", {\n                ref: simpleConnectorMeshRef,\n                position: [\n                    0,\n                    0,\n                    0.1\n                ],\n                visible: showSimple,\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"planeGeometry\", {\n                        args: [\n                            connectorPlaneSize,\n                            connectorPlaneSize\n                        ]\n                    }, void 0, false, {\n                        fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                        lineNumber: 393,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"simpleConnectorMaterial\", {\n                        ref: simpleConnectorMaterialRef,\n                        transparent: true,\n                        depthTest: false\n                    }, _SimpleConnectorMaterial__WEBPACK_IMPORTED_MODULE_8__.SimpleConnectorMaterial.key, false, {\n                        fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                        lineNumber: 394,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                lineNumber: 392,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"mesh\", {\n                ref: connectorMeshRef,\n                position: [\n                    0,\n                    0,\n                    -0.1\n                ],\n                visible: !showSimple,\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"planeGeometry\", {\n                        args: [\n                            connectorPlaneSize,\n                            connectorPlaneSize\n                        ]\n                    }, void 0, false, {\n                        fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                        lineNumber: 404,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"gridConnectorMaterial\", {\n                        ref: gridConnectorMaterialRef,\n                        transparent: true,\n                        depthTest: false\n                    }, _GridConnectorMaterial__WEBPACK_IMPORTED_MODULE_7__.GridConnectorMaterial.key, false, {\n                        fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                        lineNumber: 405,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                lineNumber: 403,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"instancedMesh\", {\n                ref: instancedMeshRef,\n                args: [\n                    null,\n                    null,\n                    TOTAL_INSTANCES\n                ],\n                onClick: handleClick,\n                position: [\n                    0,\n                    0,\n                    0\n                ],\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"planeGeometry\", {\n                        args: [\n                            connectorPlaneSize,\n                            connectorPlaneSize\n                        ],\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"instancedBufferAttribute\", {\n                                attach: \"attributes-a_instanceShowInner\",\n                                args: [\n                                    instanceShowInner,\n                                    1\n                                ]\n                            }, void 0, false, {\n                                fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                                lineNumber: 421,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"instancedBufferAttribute\", {\n                                attach: \"attributes-a_instanceShowOuter\",\n                                args: [\n                                    instanceShowOuter,\n                                    1\n                                ]\n                            }, void 0, false, {\n                                fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                                lineNumber: 425,\n                                columnNumber: 11\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                        lineNumber: 420,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"connectorMaterial\", {\n                        ref: materialRef,\n                        transparent: true\n                    }, _ConnectorMaterial__WEBPACK_IMPORTED_MODULE_6__.ConnectorMaterial.key, false, {\n                        fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                        lineNumber: 430,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                lineNumber: 414,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"group\", {\n                ref: gridHelperRef,\n                position: [\n                    0,\n                    0,\n                    -0.2\n                ],\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"gridHelper\", {\n                    args: [\n                        10,\n                        10\n                    ],\n                    rotation: [\n                        Math.PI / 2,\n                        0,\n                        0\n                    ]\n                }, void 0, false, {\n                    fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                    lineNumber: 439,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                lineNumber: 438,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true);\n}\nfunction WebGLCanvas() {\n    return(// Set up the R3F Canvas\n    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.Canvas, {\n        style: {\n            background: \"#f0f0f0\"\n        },\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_react_three_drei__WEBPACK_IMPORTED_MODULE_3__.OrthographicCamera, {\n                makeDefault: true,\n                zoom: 100,\n                position: [\n                    0,\n                    0,\n                    5\n                ],\n                rotation: [\n                    0,\n                    0,\n                    0\n                ]\n            }, void 0, false, {\n                fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                lineNumber: 453,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ambientLight\", {\n                intensity: 0.8\n            }, void 0, false, {\n                fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                lineNumber: 459,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Scene, {}, void 0, false, {\n                fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                lineNumber: 460,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n        lineNumber: 451,\n        columnNumber: 5\n    }, this));\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL1dlYkdMQ2FudmFzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0U7QUFDSTtBQUNqQjtBQUN4QjtBQUNvQixDQUFDLDZDQUE2QztBQUN6QyxDQUFDLG9DQUFvQztBQUM3QixDQUFDLG9DQUFvQztBQUNqQyxDQUFDLHdDQUF3QztBQUU3RywwREFBMEQ7QUFDMURPLDBEQUFNQSxDQUFDO0lBQUVPLGlCQUFpQkEsbUVBQUFBO0lBQUVDLHFCQUFxQkEsMkVBQUFBO0lBQUVDLHVCQUF1QkEsK0VBQUFBO0FBQUM7QUFFM0UsTUFBTUMsWUFBWTtBQUNsQixNQUFNQyxrQkFBa0JELFlBQVlBO0FBRXBDLCtDQUErQztBQUMvQyxNQUFNRSxnQkFBZ0IsQ0FBQ0MsS0FBS0MsTUFBUUQsTUFBTUgsWUFBWUk7QUFDdEQsK0NBQStDO0FBQy9DLE1BQU1DLGdCQUFnQixDQUFDQyxLQUFRO1FBQUVILEtBQUtJLEtBQUtDLEtBQUssQ0FBQ0YsS0FBS047UUFBWUksS0FBS0UsS0FBS047SUFBVTtBQUV0Rix3REFBd0Q7QUFDeEQsTUFBTVMsUUFBUSxJQUFJaEIsMkNBQWM7QUFFaEMsb0JBQW9CO0FBQ3BCLE1BQU1rQixjQUFjO0lBQ2xCQyxTQUFTO0lBQ1RDLFNBQVM7SUFDVEMsU0FBUztJQUNUQyxhQUFhLEtBQUssZ0NBQWdDO0FBQ3BEO0FBRUEsU0FBU0M7SUFDUCw4Q0FBOEM7SUFDOUMsTUFBTSxFQUFFQyxXQUFXLEVBQUVDLElBQUksRUFBRUMsS0FBSyxFQUFFQyxVQUFVLEVBQUUsR0FBRzFCLGlEQUFXQSxDQUFDO1FBQzNEdUIsYUFBYTtZQUFFSSxPQUFPO1lBQU1DLEtBQUs7WUFBS0MsS0FBSztZQUFLQyxNQUFNO1lBQU1DLE9BQU87UUFBZTtRQUNsRlAsTUFBTTtZQUFFRyxPQUFPO1lBQUtDLEtBQUs7WUFBS0MsS0FBSztZQUFLQyxNQUFNO1lBQUtDLE9BQU87UUFBYztRQUN4RU4sT0FBTztZQUFFRSxPQUFPO1lBQU1JLE9BQU87UUFBYTtRQUMxQ0wsWUFBWTtZQUFFQyxPQUFPO1lBQU1JLE9BQU87UUFBdUI7SUFDM0Q7SUFFQSxzQ0FBc0M7SUFDdEMsTUFBTUMsY0FBY1QsY0FBY04sWUFBWUksV0FBVztJQUN6RCxNQUFNWSxnQkFBZ0IsQ0FBQ2hCLFlBQVlDLE9BQU8sR0FBR2MsV0FBVSxFQUFHRSxPQUFPLENBQUM7SUFDbEUsTUFBTUMsZ0JBQWdCLENBQUNsQixZQUFZRSxPQUFPLEdBQUdhLFdBQVUsRUFBR0UsT0FBTyxDQUFDO0lBQ2xFLE1BQU1FLGdCQUFnQixDQUFDbkIsWUFBWUcsT0FBTyxHQUFHWSxXQUFVLEVBQUdFLE9BQU8sQ0FBQztJQUVsRSxxREFBcUQ7SUFDckRsQyxpREFBV0EsQ0FDVCxrQkFDQTtRQUNFcUMsYUFBYTtZQUFFVixPQUFPTTtZQUFlRixPQUFPO1lBQW9CTyxVQUFVO1FBQUs7UUFDL0VDLGFBQWE7WUFBRVosT0FBT1E7WUFBZUosT0FBTztZQUFvQk8sVUFBVTtRQUFLO1FBQy9FbEIsU0FBUztZQUFFTyxPQUFPUztZQUFlTCxPQUFPO1lBQWFPLFVBQVU7UUFBSztJQUN0RTtJQUdGLG9DQUFvQztJQUNwQyxNQUFNLENBQUNFLFdBQVdDLGFBQWEsR0FBR2hELCtDQUFRQSxDQUFDO1FBQ3pDLHNDQUFzQztRQUN0QztZQUFDO2dCQUFFaUQsV0FBVztnQkFBTUMsV0FBVztZQUFLO1lBQUc7Z0JBQUVELFdBQVc7Z0JBQU1DLFdBQVc7WUFBSztTQUFFO1FBQzVFO1lBQUM7Z0JBQUVELFdBQVc7Z0JBQU1DLFdBQVc7WUFBSztZQUFHO2dCQUFFRCxXQUFXO2dCQUFNQyxXQUFXO1lBQUs7U0FBRTtLQUM3RTtJQUVELGtFQUFrRTtJQUNsRSxNQUFNLENBQUNDLGlCQUFpQkMsbUJBQW1CLEdBQUdwRCwrQ0FBUUEsQ0FBQztJQUV2RCxNQUFNcUQsY0FBY3hELDZDQUFNQTtJQUMxQixNQUFNeUQsbUJBQW1CekQsNkNBQU1BO0lBQy9CLE1BQU0wRCxnQkFBZ0IxRCw2Q0FBTUE7SUFDNUIsTUFBTTJELFlBQVkzRCw2Q0FBTUE7SUFFeEIsbUNBQW1DO0lBQ25DLE1BQU00RCwyQkFBMkI1RCw2Q0FBTUE7SUFDdkMsTUFBTTZELG1CQUFtQjdELDZDQUFNQTtJQUMvQixNQUFNOEQsZUFBZTlELDZDQUFNQTtJQUUzQiwwREFBMEQ7SUFDMUQsTUFBTStELDZCQUE2Qi9ELDZDQUFNQTtJQUN6QyxNQUFNZ0UseUJBQXlCaEUsNkNBQU1BO0lBRXJDLDBDQUEwQztJQUMxQyxNQUFNaUUsb0JBQW9CaEUsOENBQU9BLENBQUMsSUFBTSxJQUFJaUUsYUFBYWpELGtCQUFrQixFQUFFO0lBQzdFLE1BQU1rRCxvQkFBb0JsRSw4Q0FBT0EsQ0FBQyxJQUFNLElBQUlpRSxhQUFhakQsa0JBQWtCLEVBQUU7SUFFN0Usc0NBQXNDO0lBQ3RDLE1BQU1tRCxvQkFBb0JwRSw2Q0FBTUEsQ0FBQ3FFLE1BQU1wRCxpQkFBaUJxRCxJQUFJLEdBQUdDLEdBQUcsQ0FBQyxJQUFNLElBQUk5RCwwQ0FBYTtJQUUxRiwwQkFBMEI7SUFDMUIsTUFBTSxFQUFFZ0UsTUFBTSxFQUFFQyxTQUFTLEVBQUVDLEtBQUssRUFBRSxHQUFHcEUsNERBQVFBO0lBRTdDLG1DQUFtQztJQUNuQ0wsZ0RBQVNBLENBQUM7UUFDUjBFLFFBQVFDLEdBQUcsQ0FBQyxlQUFlM0I7SUFDN0IsR0FBRztRQUFDQTtLQUFVO0lBRWQscUVBQXFFO0lBQ3JFLE1BQU00QixtQkFBbUI3RSw4Q0FBT0EsQ0FBQztRQUMvQixNQUFNOEUsT0FBTyxJQUFJYixhQUFhLElBQUksSUFBSSwrQkFBK0I7UUFDckUsTUFBTWMsVUFBVSxJQUFJdkUsOENBQWlCLENBQ25Dc0UsTUFDQSxHQUNBLEdBQ0F0RSw2Q0FBZ0IsRUFDaEJBLDRDQUFlO1FBRWpCdUUsUUFBUUksV0FBVyxHQUFHO1FBQ3RCLE9BQU9KO0lBQ1QsR0FBRyxFQUFFO0lBRUwsa0VBQWtFO0lBQ2xFOUUsZ0RBQVNBLENBQUM7UUFDUixNQUFNNkUsT0FBT0QsaUJBQWlCTyxLQUFLLENBQUNOLElBQUk7UUFFeEMsSUFBSyxJQUFJNUQsTUFBTSxHQUFHQSxNQUFNSCxXQUFXRyxNQUFPO1lBQ3hDLElBQUssSUFBSUMsTUFBTSxHQUFHQSxNQUFNSixXQUFXSSxNQUFPO2dCQUN4QyxNQUFNa0UsTUFBTSxDQUFDbkUsTUFBTUgsWUFBWUksR0FBRSxJQUFLO2dCQUN0QzJELElBQUksQ0FBQ08sSUFBSSxHQUFHcEMsU0FBUyxDQUFDL0IsSUFBSSxDQUFDQyxJQUFJLENBQUNnQyxTQUFTLEdBQUcsTUFBTSxLQUFTLG1CQUFtQjtnQkFDOUUyQixJQUFJLENBQUNPLE1BQU0sRUFBRSxHQUFHcEMsU0FBUyxDQUFDL0IsSUFBSSxDQUFDQyxJQUFJLENBQUNpQyxTQUFTLEdBQUcsTUFBTSxLQUFLLG1CQUFtQjtnQkFDOUUwQixJQUFJLENBQUNPLE1BQU0sRUFBRSxHQUFHLEtBQUssYUFBYTtnQkFDbENQLElBQUksQ0FBQ08sTUFBTSxFQUFFLEdBQUcsS0FBSyxjQUFjO1lBQ3JDO1FBQ0Y7UUFFQVIsaUJBQWlCTSxXQUFXLEdBQUc7UUFDL0JSLFFBQVFDLEdBQUcsQ0FBQyw4QkFBOEJFO1FBRTFDLDZEQUE2RDtRQUM3RCxNQUFNckMsY0FBY1QsY0FBY04sWUFBWUksV0FBVztRQUV6RCx5REFBeUQ7UUFDekQsSUFBSTZCLHlCQUF5QjJCLE9BQU8sRUFBRTtZQUNwQzNCLHlCQUF5QjJCLE9BQU8sQ0FBQ0MsUUFBUSxDQUFDQyxTQUFTLENBQUNwRCxLQUFLLEdBQUdWLFlBQVlDLE9BQU8sR0FBR2M7WUFDbEZrQix5QkFBeUIyQixPQUFPLENBQUNDLFFBQVEsQ0FBQ0UsU0FBUyxDQUFDckQsS0FBSyxHQUFHVixZQUFZRSxPQUFPLEdBQUdhO1lBQ2xGa0IseUJBQXlCMkIsT0FBTyxDQUFDQyxRQUFRLENBQUNHLFNBQVMsQ0FBQ3RELEtBQUssR0FBR0o7WUFDNUQyQix5QkFBeUIyQixPQUFPLENBQUNDLFFBQVEsQ0FBQ0ksV0FBVyxDQUFDdkQsS0FBSyxHQUFHeUM7WUFDOURsQix5QkFBeUIyQixPQUFPLENBQUNDLFFBQVEsQ0FBQ0ssaUJBQWlCLEdBQUc7Z0JBQUV4RCxPQUFPaUI7WUFBZ0I7WUFDdkYsaUZBQWlGO1lBQ2pGLElBQUlNLHlCQUF5QjJCLE9BQU8sQ0FBQ0MsUUFBUSxDQUFDTSxXQUFXLEVBQUU7WUFDekQsa0hBQWtIO1lBQ3BIO1lBQ0EsbUVBQW1FO1lBQ25FLElBQUlsQyx5QkFBeUIyQixPQUFPLENBQUNDLFFBQVEsQ0FBQ08sV0FBVyxFQUFFO1lBQ3pELGtIQUFrSDtZQUNwSDtRQUNGO1FBRUEsNENBQTRDO1FBQzVDLElBQUloQywyQkFBMkJ3QixPQUFPLEVBQUU7WUFDdEMsc0RBQXNEO1lBQ3REeEIsMkJBQTJCd0IsT0FBTyxDQUFDQyxRQUFRLENBQUNDLFNBQVMsQ0FBQ3BELEtBQUssR0FBR1YsWUFBWUMsT0FBTyxHQUFHYztZQUNwRnFCLDJCQUEyQndCLE9BQU8sQ0FBQ0MsUUFBUSxDQUFDRSxTQUFTLENBQUNyRCxLQUFLLEdBQUdWLFlBQVlFLE9BQU8sR0FBR2E7WUFDcEZxQiwyQkFBMkJ3QixPQUFPLENBQUNDLFFBQVEsQ0FBQ1EsU0FBUyxDQUFDM0QsS0FBSyxHQUFHVixZQUFZRyxPQUFPLEdBQUdZO1lBQ3BGcUIsMkJBQTJCd0IsT0FBTyxDQUFDQyxRQUFRLENBQUNHLFNBQVMsQ0FBQ3RELEtBQUssR0FBR0o7WUFDOUQ4QiwyQkFBMkJ3QixPQUFPLENBQUNDLFFBQVEsQ0FBQ0ksV0FBVyxDQUFDdkQsS0FBSyxHQUFHeUM7WUFDaEVmLDJCQUEyQndCLE9BQU8sQ0FBQ0MsUUFBUSxDQUFDSyxpQkFBaUIsR0FBRztnQkFBRXhELE9BQU9pQjtZQUFnQjtRQUMzRjtJQUNGLEdBQUc7UUFBQ0o7UUFBVzRCO1FBQWtCN0M7UUFBYUU7UUFBT0M7UUFBWWtCO0tBQWdCO0lBRWpGLHNDQUFzQztJQUN0Q3BELGdEQUFTQSxDQUFDO1FBQ1IsSUFBSXVFLFFBQVE7WUFDVkEsT0FBT3ZDLElBQUksR0FBRyxNQUFPLEtBQUVBLElBQUcsR0FBSSw2QkFBNkI7WUFDM0R1QyxPQUFPd0Isc0JBQXNCO1FBQy9CO0lBQ0YsR0FBRztRQUFDeEI7UUFBUXZDO0tBQUs7SUFFakIsb0VBQW9FO0lBQ3BFaEMsZ0RBQVNBLENBQUM7UUFDUixJQUFJLENBQUN1RCxpQkFBaUI4QixPQUFPLEVBQUU7UUFFL0IsSUFBSVcsYUFBYTtRQUVqQixtQ0FBbUM7UUFDbkMsTUFBTUMsY0FBYyxDQUFDbkYsWUFBWSxLQUFLLE1BQU1pQjtRQUU1QyxJQUFLLElBQUlkLE1BQU0sR0FBR0EsTUFBTUgsV0FBV0csTUFBTztZQUN4QyxJQUFLLElBQUlDLE1BQU0sR0FBR0EsTUFBTUosV0FBV0ksTUFBTztnQkFDeEMsaUNBQWlDO2dCQUNqQyxNQUFNZ0YsSUFBSWhGLE1BQU1hLGNBQWNrRTtnQkFDOUIsTUFBTUUsSUFBSSxDQUFFbEYsQ0FBQUEsTUFBTWMsY0FBY2tFLFdBQVUsR0FBSSx1Q0FBdUM7Z0JBRXJGLHFDQUFxQztnQkFDckMxRSxNQUFNNkUsUUFBUSxDQUFDQyxHQUFHLENBQUNILEdBQUdDLEdBQUc7Z0JBQ3pCNUUsTUFBTStFLFlBQVk7Z0JBRWxCLDBCQUEwQjtnQkFDMUIvQyxpQkFBaUI4QixPQUFPLENBQUNrQixXQUFXLENBQUNQLFlBQVl6RSxNQUFNaUYsTUFBTTtnQkFFN0QscUNBQXFDO2dCQUNyQ3RDLGtCQUFrQm1CLE9BQU8sQ0FBQ1csV0FBVyxDQUFDSyxHQUFHLENBQUNILEdBQUdDLEdBQUc7Z0JBRWhELCtCQUErQjtnQkFDL0JwQyxpQkFBaUIsQ0FBQ2lDLFdBQVcsR0FBR2hELFNBQVMsQ0FBQy9CLElBQUksQ0FBQ0MsSUFBSSxDQUFDZ0MsU0FBUyxHQUFHLE1BQU07Z0JBQ3RFZSxpQkFBaUIsQ0FBQytCLFdBQVcsR0FBR2hELFNBQVMsQ0FBQy9CLElBQUksQ0FBQ0MsSUFBSSxDQUFDaUMsU0FBUyxHQUFHLE1BQU07Z0JBRXRFNkM7WUFDRjtRQUNGO1FBRUEsd0NBQXdDO1FBQ3hDekMsaUJBQWlCOEIsT0FBTyxDQUFDb0IsUUFBUSxDQUFDQyxVQUFVLENBQUNDLG1CQUFtQixDQUFDekIsV0FBVyxHQUFHO1FBQy9FM0IsaUJBQWlCOEIsT0FBTyxDQUFDb0IsUUFBUSxDQUFDQyxVQUFVLENBQUNFLG1CQUFtQixDQUFDMUIsV0FBVyxHQUFHO1FBQy9FM0IsaUJBQWlCOEIsT0FBTyxDQUFDd0IsY0FBYyxDQUFDM0IsV0FBVyxHQUFHO1FBRXRELGdEQUFnRDtRQUNoRCxJQUFJNUIsWUFBWStCLE9BQU8sRUFBRTtZQUN2Qiw2REFBNkQ7WUFDN0QsTUFBTTdDLGNBQWNULGNBQWNOLFlBQVlJLFdBQVc7WUFFekR5QixZQUFZK0IsT0FBTyxDQUFDQyxRQUFRLENBQUNDLFNBQVMsQ0FBQ3BELEtBQUssR0FBR1YsWUFBWUMsT0FBTyxHQUFHYztZQUNyRWMsWUFBWStCLE9BQU8sQ0FBQ0MsUUFBUSxDQUFDRSxTQUFTLENBQUNyRCxLQUFLLEdBQUdWLFlBQVlFLE9BQU8sR0FBR2E7WUFDckVjLFlBQVkrQixPQUFPLENBQUNDLFFBQVEsQ0FBQ0csU0FBUyxDQUFDdEQsS0FBSyxHQUFHSjtRQUNqRDtRQUVBLHNDQUFzQztRQUN0QyxJQUFJeUIsY0FBYzZCLE9BQU8sRUFBRTtZQUN6QjdCLGNBQWM2QixPQUFPLENBQUN5QixLQUFLLENBQUNULEdBQUcsQ0FBQ3RFLGFBQWFBLGFBQWE7UUFDNUQ7SUFFRixHQUFHO1FBQUNpQjtRQUFXakI7UUFBYWdDO1FBQW1CRTtLQUFrQjtJQUVqRSw2QkFBNkI7SUFDN0IsTUFBTThDLGNBQWMsQ0FBQ0M7UUFDbkIsSUFBSSxDQUFDekQsaUJBQWlCOEIsT0FBTyxFQUFFO1FBRS9CLDZEQUE2RDtRQUM3RCxNQUFNN0MsY0FBY1QsY0FBY04sWUFBWUksV0FBVztRQUV6RCw0Q0FBNEM7UUFDNUMsTUFBTVksZ0JBQWdCaEIsWUFBWUMsT0FBTyxHQUFHYztRQUM1QyxNQUFNRyxnQkFBZ0JsQixZQUFZRSxPQUFPLEdBQUdhO1FBRTVDLDhDQUE4QztRQUM5QyxNQUFNeUUsYUFBYWxGLGNBQWM7UUFDakMsTUFBTW1GLFVBQVUsSUFBSTNHLDBDQUFhLENBQUMsQ0FBQzBHLFlBQVlBLGFBQWUsZUFBZTtRQUM3RSxNQUFNRyxVQUFVLElBQUk3RywwQ0FBYSxDQUFDMEcsWUFBWSxDQUFDQSxhQUFlLG1CQUFtQjtRQUNqRixNQUFNSSxVQUFVLElBQUk5RywwQ0FBYSxDQUFDLENBQUMwRyxZQUFZLENBQUNBLGFBQWMsa0JBQWtCO1FBQ2hGLE1BQU1LLFVBQVUsSUFBSS9HLDBDQUFhLENBQUMwRyxZQUFZQSxhQUFnQixnQkFBZ0I7UUFFOUUsaUVBQWlFO1FBQ2pFLE1BQU1NLGFBQWEsSUFBSWhILDBDQUFhLENBQUN5RyxNQUFNUSxLQUFLLENBQUN0QixDQUFDLEVBQUVjLE1BQU1RLEtBQUssQ0FBQ3JCLENBQUM7UUFFakUsMENBQTBDO1FBQzFDLE1BQU1zQixzQkFBc0JDLHVCQUF1QkgsWUFBWUwsU0FBU0UsU0FBUzNFLGVBQWVFO1FBQ2hHLE1BQU1nRixzQkFBc0JELHVCQUF1QkgsWUFBWUYsU0FBU0MsU0FBUzdFLGVBQWVFO1FBRWhHLElBQUk4RSx1QkFBdUJFLHFCQUFxQjtZQUM5QyxnRUFBZ0U7WUFDaEV0RSxtQkFBbUJ1RSxDQUFBQTtnQkFDakIsSUFBSUEsY0FBYyxHQUFHO29CQUNuQiwwRUFBMEU7b0JBQzFFLE9BQU9ILHNCQUFzQixJQUFJO2dCQUNuQyxPQUFPLElBQUlHLGNBQWMsS0FBS0gscUJBQXFCO29CQUNqRCxvQkFBb0I7b0JBQ3BCLE9BQU87Z0JBQ1QsT0FBTyxJQUFJRyxjQUFjLEtBQUtELHFCQUFxQjtvQkFDakQsa0JBQWtCO29CQUNsQixPQUFPO2dCQUNULE9BQU87b0JBQ0wsNENBQTRDO29CQUM1QyxPQUFPQyxjQUFjLElBQUtILHNCQUFzQixJQUFJLElBQUs7Z0JBQzNEO1lBQ0Y7WUFFQSxRQUFRLHNDQUFzQztRQUNoRDtRQUVBLGlDQUFpQztRQUNqQyxJQUFJVCxNQUFNaEIsVUFBVSxLQUFLNkIsV0FBVztRQUVwQyxNQUFNN0IsYUFBYWdCLE1BQU1oQixVQUFVO1FBQ25DLE1BQU0sRUFBRS9FLEdBQUcsRUFBRUMsR0FBRyxFQUFFLEdBQUdDLGNBQWM2RTtRQUNuQ3RCLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLHNCQUFzQixFQUFFMUQsSUFBSSxNQUFNLEVBQUVDLElBQUksQ0FBQztRQUV0RCxNQUFNNEcsZUFBZTlFLFNBQVMsQ0FBQy9CLElBQUksQ0FBQ0MsSUFBSTtRQUV4QyxrREFBa0Q7UUFDbEQsTUFBTTZHLG1CQUFtQjdELGtCQUFrQm1CLE9BQU8sQ0FBQ1csV0FBVztRQUU5RCxtQ0FBbUM7UUFDbkMsTUFBTWdDLFlBQVloQixNQUFNUSxLQUFLLENBQUNTLEtBQUs7UUFFbkMsbURBQW1EO1FBQ25ELE1BQU1DLGlCQUFpQkYsVUFBVUcsVUFBVSxDQUFDSjtRQUU1QyxJQUFJSyxXQUFXTixhQUFhNUUsU0FBUztRQUNyQyxJQUFJbUYsV0FBV1AsYUFBYTNFLFNBQVM7UUFFckMsSUFBSStFLGtCQUFrQnpGLGVBQWU7WUFDbkMsdUJBQXVCO1lBQ3ZCMkYsV0FBVyxDQUFDTixhQUFhNUUsU0FBUztZQUNsQ3dCLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLHVCQUF1QixFQUFFbUQsYUFBYTVFLFNBQVMsQ0FBQyxJQUFJLEVBQUVrRixTQUFTLENBQUM7WUFFN0UsNkVBQTZFO1lBQzdFLElBQUksQ0FBQ0EsVUFBVTtnQkFDYiwyQ0FBMkM7Z0JBQzNDLElBQUluSCxRQUFRLEtBQUtDLFFBQVEsS0FBS2tDLG9CQUFvQixHQUFHO29CQUNuREMsbUJBQW1CO2dCQUNyQixPQUVLLElBQUlwQyxRQUFRLEtBQUtDLFFBQVEsS0FBS2tDLG9CQUFvQixHQUFHO29CQUN4REMsbUJBQW1CO2dCQUNyQixPQUVLLElBQUlwQyxRQUFRLEtBQUtDLFFBQVEsS0FBS2tDLG9CQUFvQixHQUFHO29CQUN4REMsbUJBQW1CO2dCQUNyQixPQUVLLElBQUlwQyxRQUFRLEtBQUtDLFFBQVEsS0FBS2tDLG9CQUFvQixHQUFHO29CQUN4REMsbUJBQW1CO2dCQUNyQjtZQUNGLE9BRUssSUFBSStFLFVBQVU7Z0JBQ2pCLDhEQUE4RDtnQkFDOUQsSUFBSWhGLG9CQUFvQixHQUFHO29CQUN6QixxRkFBcUY7b0JBQ3JGLElBQUksUUFBUyxLQUFLbEMsUUFBUSxLQUFLOEIsU0FBUyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUNFLFNBQVMsSUFDbkRqQyxRQUFRLEtBQUtDLFFBQVEsS0FBSzhCLFNBQVMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDRSxTQUFTLEVBQUc7d0JBQ3pERyxtQkFBbUIsSUFBSSx5QkFBeUI7b0JBQ2xELE9BRUssSUFBSSxRQUFTLEtBQUtuQyxRQUFRLEtBQUs4QixTQUFTLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQ0UsU0FBUyxJQUNwRGpDLFFBQVEsS0FBS0MsUUFBUSxLQUFLOEIsU0FBUyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUNFLFNBQVMsRUFBRzt3QkFDN0RHLG1CQUFtQixJQUFJLDBCQUEwQjtvQkFDbkQ7Z0JBQ0Y7WUFDRjtRQUNGLE9BQU8sSUFBSTZFLGtCQUFrQnZGLGVBQWU7WUFDMUMsdUJBQXVCO1lBQ3ZCMEYsV0FBVyxDQUFDUCxhQUFhM0UsU0FBUztZQUNsQ3VCLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLHVCQUF1QixFQUFFbUQsYUFBYTNFLFNBQVMsQ0FBQyxJQUFJLEVBQUVrRixTQUFTLENBQUM7UUFDL0U7UUFFQSxJQUFJRCxhQUFhTixhQUFhNUUsU0FBUyxJQUFJbUYsYUFBYVAsYUFBYTNFLFNBQVMsRUFBRTtZQUM5RUYsYUFBYTJFLENBQUFBO2dCQUNYLE1BQU1VLFdBQVdDLEtBQUtDLEtBQUssQ0FBQ0QsS0FBS0UsU0FBUyxDQUFDYixhQUFhLFlBQVk7Z0JBQ3BFVSxRQUFRLENBQUNySCxJQUFJLENBQUNDLElBQUksR0FBRztvQkFBRWdDLFdBQVdrRjtvQkFBVWpGLFdBQVdrRjtnQkFBUztnQkFDaEUsT0FBT0M7WUFDVDtRQUNGO0lBQ0Y7SUFFQSxtRUFBbUU7SUFDbkUsTUFBTVoseUJBQXlCLENBQUNGLE9BQU9rQixTQUFTQyxTQUFTOUYsYUFBYUU7UUFDcEUscURBQXFEO1FBQ3JELE1BQU02RixnQkFBZ0JwQixNQUFNVyxVQUFVLENBQUNPO1FBQ3ZDLE1BQU1HLGdCQUFnQnJCLE1BQU1XLFVBQVUsQ0FBQ1E7UUFFdkMsSUFBSUMsZ0JBQWdCL0YsZUFBZWdHLGdCQUFnQmhHLGFBQWE7WUFDOUQsT0FBTyxPQUFPLHlCQUF5QjtRQUN6QztRQUVBLHFEQUFxRDtRQUNyRCxNQUFNaUcsWUFBWSxJQUFJdkksMENBQWEsR0FBR3dJLFVBQVUsQ0FBQ0osU0FBU0QsU0FBU00sU0FBUztRQUM1RSxNQUFNQyxpQkFBaUIsSUFBSTFJLDBDQUFhLEdBQUd3SSxVQUFVLENBQUN2QixPQUFPa0I7UUFDN0QsTUFBTVEsbUJBQW1CRCxlQUFlRSxHQUFHLENBQUNMO1FBRTVDLHVFQUF1RTtRQUN2RSxNQUFNTSx5QkFBeUJWLFFBQVFQLFVBQVUsQ0FBQ1E7UUFDbEQsSUFBSU8sbUJBQW1CLENBQUNuRyxlQUFlbUcsbUJBQW1CRSx5QkFBeUJyRyxhQUFhO1lBQzlGLE9BQU8sT0FBTyxxQ0FBcUM7UUFDckQ7UUFFQSxzREFBc0Q7UUFDdEQsTUFBTXNHLGlCQUFpQixJQUFJOUksMENBQWEsR0FBRytJLElBQUksQ0FBQ1osU0FBU2EsZUFBZSxDQUFDVCxXQUFXSTtRQUNwRixNQUFNTSxlQUFlaEMsTUFBTVcsVUFBVSxDQUFDa0I7UUFFdEMsbURBQW1EO1FBQ25ELE1BQU1JLGlCQUFpQjFHLGNBQWM7UUFFckMsT0FBT3lHLGVBQWVDO0lBQ3hCO0lBRUEsMERBQTBEO0lBQzFELE1BQU1DLHFCQUFxQjNKLDhDQUFPQSxDQUFDLElBQ2pDZSxZQUFZaUIsY0FBY1YsS0FBS2dCLEdBQUcsQ0FBQ1osWUFBWUUsT0FBTyxFQUFFRixZQUFZQyxPQUFPLElBQUksR0FDL0U7UUFBQ0s7UUFBYU4sWUFBWUUsT0FBTztRQUFFRixZQUFZQyxPQUFPO0tBQUM7SUFHekQscUJBQ0U7O1lBRUdPLHVCQUNDLDhEQUFDMEg7Z0JBQUtDLEtBQUtoRztnQkFBY3dDLFVBQVU7b0JBQUM7b0JBQUc7b0JBQUcsQ0FBQztpQkFBSTs7a0NBQzdDLDhEQUFDeUQ7d0JBQWNDLE1BQU07NEJBQUNKOzRCQUFvQkE7eUJBQW1COzs7Ozs7a0NBQzdELDhEQUFDSzt3QkFBa0JDLE9BQU07d0JBQU9DLFNBQVM7d0JBQUtDLFdBQVc7Ozs7Ozs7Ozs7OzswQkFLN0QsOERBQUNQO2dCQUFLQyxLQUFLOUY7Z0JBQXdCc0MsVUFBVTtvQkFBQztvQkFBRztvQkFBRztpQkFBSTtnQkFBRStELFNBQVNqSTs7a0NBQ2pFLDhEQUFDMkg7d0JBQWNDLE1BQU07NEJBQUNKOzRCQUFvQkE7eUJBQW1COzs7Ozs7a0NBQzdELDhEQUFDVTt3QkFDQ1IsS0FBSy9GO3dCQUVMcUcsYUFBYTt3QkFDYkcsV0FBVzt1QkFGTnhKLDZFQUF1QkEsQ0FBQ3lKLEdBQUc7Ozs7Ozs7Ozs7OzBCQU9wQyw4REFBQ1g7Z0JBQUtDLEtBQUtqRztnQkFBa0J5QyxVQUFVO29CQUFDO29CQUFHO29CQUFHLENBQUM7aUJBQUk7Z0JBQUUrRCxTQUFTLENBQUNqSTs7a0NBQzdELDhEQUFDMkg7d0JBQWNDLE1BQU07NEJBQUNKOzRCQUFvQkE7eUJBQW1COzs7Ozs7a0NBQzdELDhEQUFDYTt3QkFDQ1gsS0FBS2xHO3dCQUVMd0csYUFBYTt3QkFDYkcsV0FBVzt1QkFGTnpKLHlFQUFxQkEsQ0FBQzBKLEdBQUc7Ozs7Ozs7Ozs7OzBCQU9sQyw4REFBQ0U7Z0JBQ0NaLEtBQUtyRztnQkFDTHVHLE1BQU07b0JBQUM7b0JBQU07b0JBQU0vSTtpQkFBZ0I7Z0JBQ25DMEosU0FBUzFEO2dCQUNUWCxVQUFVO29CQUFDO29CQUFHO29CQUFHO2lCQUFFOztrQ0FFbkIsOERBQUN5RDt3QkFBY0MsTUFBTTs0QkFBQ0o7NEJBQW9CQTt5QkFBbUI7OzBDQUMzRCw4REFBQ2dCO2dDQUNDQyxRQUFPO2dDQUNQYixNQUFNO29DQUFDL0Y7b0NBQW1CO2lDQUFFOzs7Ozs7MENBRTlCLDhEQUFDMkc7Z0NBQ0NDLFFBQU87Z0NBQ1BiLE1BQU07b0NBQUM3RjtvQ0FBbUI7aUNBQUU7Ozs7Ozs7Ozs7OztrQ0FHaEMsOERBQUMyRzt3QkFDQ2hCLEtBQUt0Rzt3QkFFTDRHLGFBQWE7dUJBRFJ2SixpRUFBaUJBLENBQUMySixHQUFHOzs7Ozs7Ozs7OzswQkFNOUIsOERBQUNPO2dCQUFNakIsS0FBS3BHO2dCQUFlNEMsVUFBVTtvQkFBQztvQkFBRztvQkFBRyxDQUFDO2lCQUFJOzBCQUMvQyw0RUFBQzBFO29CQUNDaEIsTUFBTTt3QkFBQzt3QkFBSTtxQkFBRztvQkFDZGlCLFVBQVU7d0JBQUMxSixLQUFLMkosRUFBRSxHQUFHO3dCQUFHO3dCQUFHO3FCQUFFOzs7Ozs7Ozs7Ozs7O0FBS3ZDO0FBRWUsU0FBU0M7SUFDdEIsT0FDRSx3QkFBd0I7a0JBQ3hCLDhEQUFDL0ssc0RBQU1BO1FBQUNnTCxPQUFPO1lBQUVDLFlBQVk7UUFBVTs7MEJBRXJDLDhEQUFDN0ssaUVBQWtCQTtnQkFDakI4SyxXQUFXO2dCQUNYcEosTUFBTTtnQkFDTm9FLFVBQVU7b0JBQUM7b0JBQUc7b0JBQUc7aUJBQUU7Z0JBQ25CMkUsVUFBVTtvQkFBQztvQkFBRztvQkFBRztpQkFBRTs7Ozs7OzBCQUVyQiw4REFBQ007Z0JBQWFDLFdBQVc7Ozs7OzswQkFDekIsOERBQUN4Sjs7Ozs7Ozs7Ozs7QUFHUCIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYmdsLWRvdC1ncmlkLW12cC8uL2NvbXBvbmVudHMvV2ViR0xDYW52YXMuanM/MjFlZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlUmVmLCB1c2VNZW1vLCB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgQ2FudmFzLCB1c2VGcmFtZSwgZXh0ZW5kLCB1c2VUaHJlZSB9IGZyb20gJ0ByZWFjdC10aHJlZS9maWJlcic7XG5pbXBvcnQgeyBPcnRob2dyYXBoaWNDYW1lcmEgfSBmcm9tICdAcmVhY3QtdGhyZWUvZHJlaSc7XG5pbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyB1c2VDb250cm9scywgZm9sZGVyLCBidXR0b24gfSBmcm9tICdsZXZhJzsgLy8gSW1wb3J0IGxldmEgd2l0aCBidXR0b24gaW5zdGVhZCBvZiBtb25pdG9yXG5pbXBvcnQgeyBDb25uZWN0b3JNYXRlcmlhbCB9IGZyb20gJy4vQ29ubmVjdG9yTWF0ZXJpYWwnOyAvLyBXZSdsbCBjcmVhdGUgdGhpcyBzaGFkZXIgbWF0ZXJpYWxcbmltcG9ydCB7IEdyaWRDb25uZWN0b3JNYXRlcmlhbCB9IGZyb20gJy4vR3JpZENvbm5lY3Rvck1hdGVyaWFsJzsgLy8gSW1wb3J0IG91ciBuZXcgY29ubmVjdG9yIG1hdGVyaWFsXG5pbXBvcnQgeyBTaW1wbGVDb25uZWN0b3JNYXRlcmlhbCB9IGZyb20gJy4vU2ltcGxlQ29ubmVjdG9yTWF0ZXJpYWwnOyAvLyBJbXBvcnQgc2ltcGxlIGNvbm5lY3RvciBmb3IgZGVidWdnaW5nXG5cbi8vIEV4dGVuZCBUSFJFRSBuYW1lc3BhY2Ugd2l0aCBvdXIgY3VzdG9tIHNoYWRlciBtYXRlcmlhbHNcbmV4dGVuZCh7IENvbm5lY3Rvck1hdGVyaWFsLCBHcmlkQ29ubmVjdG9yTWF0ZXJpYWwsIFNpbXBsZUNvbm5lY3Rvck1hdGVyaWFsIH0pO1xuXG5jb25zdCBHUklEX1NJWkUgPSAyO1xuY29uc3QgVE9UQUxfSU5TVEFOQ0VTID0gR1JJRF9TSVpFICogR1JJRF9TSVpFO1xuXG4vLyBIZWxwZXIgdG8gY29udmVydCBncmlkIGNvb3JkcyB0byBpbnN0YW5jZSBJRFxuY29uc3QgZ2V0SW5zdGFuY2VJZCA9IChyb3csIGNvbCkgPT4gcm93ICogR1JJRF9TSVpFICsgY29sO1xuLy8gSGVscGVyIHRvIGNvbnZlcnQgaW5zdGFuY2UgSUQgdG8gZ3JpZCBjb29yZHNcbmNvbnN0IGdldEdyaWRDb29yZHMgPSAoaWQpID0+ICh7IHJvdzogTWF0aC5mbG9vcihpZCAvIEdSSURfU0laRSksIGNvbDogaWQgJSBHUklEX1NJWkUgfSk7XG5cbi8vIENyZWF0ZSBhIHJldXNhYmxlIGR1bW15IG9iamVjdCBmb3IgbWF0cml4IGNhbGN1bGF0aW9uXG5jb25zdCBkdW1teSA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xuXG4vLyBGaXhlZCBiYXNlIHZhbHVlc1xuY29uc3QgQkFTRV9WQUxVRVMgPSB7XG4gIHJhZGl1c0I6IDAuNCwgIC8vIElubmVyIHJhZGl1c1xuICByYWRpdXNBOiAwLjUsICAvLyBPdXRlciByYWRpdXNcbiAgYm94U2l6ZTogMC41LCAgLy8gQm91bmRpbmcgYm94IHNpemVcbiAgYmFzZVNwYWNpbmc6IDAuODkgLy8gUmVmZXJlbmNlIHNwYWNpbmcgZm9yIHNjYWxpbmdcbn07XG5cbmZ1bmN0aW9uIFNjZW5lKCkge1xuICAvLyBDb250cm9scyBmb3IgcmFkaXVzLCBzcGFjaW5nLCBhbmQgZGVidWdnaW5nXG4gIGNvbnN0IHsgZ3JpZFNwYWNpbmcsIHpvb20sIGRlYnVnLCBzaG93U2ltcGxlIH0gPSB1c2VDb250cm9scyh7XG4gICAgZ3JpZFNwYWNpbmc6IHsgdmFsdWU6IDAuODksIG1pbjogMC41LCBtYXg6IDIuMCwgc3RlcDogMC4wMSwgbGFiZWw6ICdHcmlkIFNwYWNpbmcnIH0sXG4gICAgem9vbTogeyB2YWx1ZTogMS4wLCBtaW46IDAuNSwgbWF4OiAzLjAsIHN0ZXA6IDAuMSwgbGFiZWw6ICdDYW1lcmEgWm9vbScgfSxcbiAgICBkZWJ1ZzogeyB2YWx1ZTogdHJ1ZSwgbGFiZWw6ICdEZWJ1ZyBNb2RlJyB9LFxuICAgIHNob3dTaW1wbGU6IHsgdmFsdWU6IHRydWUsIGxhYmVsOiAnVXNlIFNpbXBsZSBDb25uZWN0b3InIH0sXG4gIH0pO1xuICBcbiAgLy8gQ2FsY3VsYXRlIHNjYWxlZCB2YWx1ZXMgZm9yIGRpc3BsYXlcbiAgY29uc3Qgc2NhbGVGYWN0b3IgPSBncmlkU3BhY2luZyAvIEJBU0VfVkFMVUVTLmJhc2VTcGFjaW5nO1xuICBjb25zdCBzY2FsZWRSYWRpdXNCID0gKEJBU0VfVkFMVUVTLnJhZGl1c0IgKiBzY2FsZUZhY3RvcikudG9GaXhlZCgzKTtcbiAgY29uc3Qgc2NhbGVkUmFkaXVzQSA9IChCQVNFX1ZBTFVFUy5yYWRpdXNBICogc2NhbGVGYWN0b3IpLnRvRml4ZWQoMyk7XG4gIGNvbnN0IHNjYWxlZEJveFNpemUgPSAoQkFTRV9WQUxVRVMuYm94U2l6ZSAqIHNjYWxlRmFjdG9yKS50b0ZpeGVkKDMpO1xuICBcbiAgLy8gRGlzcGxheSBjdXJyZW50IHZhbHVlcyBpbiBhIHNlcGFyYXRlIGNvbnRyb2wgcGFuZWxcbiAgdXNlQ29udHJvbHMoXG4gICAgJ0N1cnJlbnQgVmFsdWVzJyxcbiAgICB7XG4gICAgICBpbm5lclJhZGl1czogeyB2YWx1ZTogc2NhbGVkUmFkaXVzQiwgbGFiZWw6ICdJbm5lciBSYWRpdXMgKEIpJywgZGlzYWJsZWQ6IHRydWUgfSxcbiAgICAgIG91dGVyUmFkaXVzOiB7IHZhbHVlOiBzY2FsZWRSYWRpdXNBLCBsYWJlbDogJ091dGVyIFJhZGl1cyAoQSknLCBkaXNhYmxlZDogdHJ1ZSB9LFxuICAgICAgYm94U2l6ZTogeyB2YWx1ZTogc2NhbGVkQm94U2l6ZSwgbGFiZWw6ICdCQm94IFNpemUnLCBkaXNhYmxlZDogdHJ1ZSB9LFxuICAgIH1cbiAgKTtcblxuICAvLyBTdGF0ZSBmb3IgdGhlIDJ4MiBncmlkIHZpc2liaWxpdHlcbiAgY29uc3QgW2dyaWRTdGF0ZSwgc2V0R3JpZFN0YXRlXSA9IHVzZVN0YXRlKFtcbiAgICAvLyBJbml0aWFsIHN0YXRlIC0gYWxsIGNpcmNsZXMgdmlzaWJsZVxuICAgIFt7IHNob3dJbm5lcjogdHJ1ZSwgc2hvd091dGVyOiB0cnVlIH0sIHsgc2hvd0lubmVyOiB0cnVlLCBzaG93T3V0ZXI6IHRydWUgfV0sXG4gICAgW3sgc2hvd0lubmVyOiB0cnVlLCBzaG93T3V0ZXI6IHRydWUgfSwgeyBzaG93SW5uZXI6IHRydWUsIHNob3dPdXRlcjogdHJ1ZSB9XVxuICBdKTtcblxuICAvLyBTdGF0ZSBmb3IgYWN0aXZlIGNvbm5lY3RvciAtIDA6IG5vbmUsIDE6IHJlZCAoQUIpLCAyOiBibHVlIChDRClcbiAgY29uc3QgW2FjdGl2ZUNvbm5lY3Rvciwgc2V0QWN0aXZlQ29ubmVjdG9yXSA9IHVzZVN0YXRlKDApO1xuXG4gIGNvbnN0IG1hdGVyaWFsUmVmID0gdXNlUmVmKCk7XG4gIGNvbnN0IGluc3RhbmNlZE1lc2hSZWYgPSB1c2VSZWYoKTtcbiAgY29uc3QgZ3JpZEhlbHBlclJlZiA9IHVzZVJlZigpO1xuICBjb25zdCBjYW1lcmFSZWYgPSB1c2VSZWYoKTtcblxuICAvLyBSZWZlcmVuY2UgZm9yIGNvbm5lY3RvciBtYXRlcmlhbFxuICBjb25zdCBncmlkQ29ubmVjdG9yTWF0ZXJpYWxSZWYgPSB1c2VSZWYoKTtcbiAgY29uc3QgY29ubmVjdG9yTWVzaFJlZiA9IHVzZVJlZigpO1xuICBjb25zdCBkZWJ1Z01lc2hSZWYgPSB1c2VSZWYoKTtcblxuICAvLyBSZWZlcmVuY2UgZm9yIHNpbXBsZSBjb25uZWN0b3IgbWF0ZXJpYWwgKGZvciBkZWJ1Z2dpbmcpXG4gIGNvbnN0IHNpbXBsZUNvbm5lY3Rvck1hdGVyaWFsUmVmID0gdXNlUmVmKCk7XG4gIGNvbnN0IHNpbXBsZUNvbm5lY3Rvck1lc2hSZWYgPSB1c2VSZWYoKTtcblxuICAvLyBBdHRyaWJ1dGVzIGZvciBpbnN0YW5jZSB2aXNpYmlsaXR5IGRhdGFcbiAgY29uc3QgaW5zdGFuY2VTaG93SW5uZXIgPSB1c2VNZW1vKCgpID0+IG5ldyBGbG9hdDMyQXJyYXkoVE9UQUxfSU5TVEFOQ0VTKSwgW10pO1xuICBjb25zdCBpbnN0YW5jZVNob3dPdXRlciA9IHVzZU1lbW8oKCkgPT4gbmV3IEZsb2F0MzJBcnJheShUT1RBTF9JTlNUQU5DRVMpLCBbXSk7XG5cbiAgLy8gU3RvcmUgcG9zaXRpb25zIGZvciBjbGljayBkZXRlY3Rpb25cbiAgY29uc3QgaW5zdGFuY2VQb3NpdGlvbnMgPSB1c2VSZWYoQXJyYXkoVE9UQUxfSU5TVEFOQ0VTKS5maWxsKCkubWFwKCgpID0+IG5ldyBUSFJFRS5WZWN0b3IzKCkpKTtcblxuICAvLyBBY2Nlc3MgdGhyZWUuanMgaGVscGVyc1xuICBjb25zdCB7IGNhbWVyYSwgcmF5Y2FzdGVyLCBtb3VzZSB9ID0gdXNlVGhyZWUoKTtcblxuICAvLyBMb2cgdGhlIGdyaWQgc3RhdGUgZm9yIGRlYnVnZ2luZ1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdHcmlkIFN0YXRlOicsIGdyaWRTdGF0ZSk7XG4gIH0sIFtncmlkU3RhdGVdKTtcblxuICAvLyBDcmVhdGUgYSBkYXRhIHRleHR1cmUgdG8gc3RvcmUgZ3JpZCBzdGF0ZSBmb3IgdGhlIGNvbm5lY3RvciBzaGFkZXJcbiAgY29uc3QgZ3JpZFN0YXRlVGV4dHVyZSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IGRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KDQgKiA0KTsgLy8gUkdCQSBmb3IgZWFjaCBvZiB0aGUgNCBjZWxsc1xuICAgIGNvbnN0IHRleHR1cmUgPSBuZXcgVEhSRUUuRGF0YVRleHR1cmUoXG4gICAgICBkYXRhLFxuICAgICAgMiwgLy8gd2lkdGggZm9yIDJ4MiBncmlkXG4gICAgICAyLCAvLyBoZWlnaHRcbiAgICAgIFRIUkVFLlJHQkFGb3JtYXQsXG4gICAgICBUSFJFRS5GbG9hdFR5cGVcbiAgICApO1xuICAgIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIHJldHVybiB0ZXh0dXJlO1xuICB9LCBbXSk7XG5cbiAgLy8gVXBkYXRlIHRoZSBncmlkIHN0YXRlIHRleHR1cmUgYW5kIHVuaWZvcm1zIHdoZW4gY29udHJvbHMgY2hhbmdlXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgZGF0YSA9IGdyaWRTdGF0ZVRleHR1cmUuaW1hZ2UuZGF0YTtcbiAgICBcbiAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCBHUklEX1NJWkU7IHJvdysrKSB7XG4gICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBHUklEX1NJWkU7IGNvbCsrKSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IChyb3cgKiBHUklEX1NJWkUgKyBjb2wpICogNDtcbiAgICAgICAgZGF0YVtpZHhdID0gZ3JpZFN0YXRlW3Jvd11bY29sXS5zaG93SW5uZXIgPyAxLjAgOiAwLjA7ICAgICAvLyBSIC0gSW5uZXIgY2lyY2xlXG4gICAgICAgIGRhdGFbaWR4ICsgMV0gPSBncmlkU3RhdGVbcm93XVtjb2xdLnNob3dPdXRlciA/IDEuMCA6IDAuMDsgLy8gRyAtIE91dGVyIGNpcmNsZVxuICAgICAgICBkYXRhW2lkeCArIDJdID0gMC4wOyAvLyBCIC0gdW51c2VkXG4gICAgICAgIGRhdGFbaWR4ICsgM10gPSAxLjA7IC8vIEEgLSBvcGFjaXR5XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGdyaWRTdGF0ZVRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIGNvbnNvbGUubG9nKCdVcGRhdGVkIGdyaWQgc3RhdGUgdGV4dHVyZScsIGRhdGEpO1xuICAgIFxuICAgIC8vIENhbGN1bGF0ZSBzY2FsZSBmYWN0b3IgYmFzZWQgb24gcmF0aW8gdG8gYmFzZSBncmlkIHNwYWNpbmdcbiAgICBjb25zdCBzY2FsZUZhY3RvciA9IGdyaWRTcGFjaW5nIC8gQkFTRV9WQUxVRVMuYmFzZVNwYWNpbmc7XG4gICAgXG4gICAgLy8gVXBkYXRlIGNvbm5lY3RvciBtYXRlcmlhbCB1bmlmb3JtcyAob3JpZ2luYWwgZ3JpZCBvbmUpXG4gICAgaWYgKGdyaWRDb25uZWN0b3JNYXRlcmlhbFJlZi5jdXJyZW50KSB7XG4gICAgICBncmlkQ29ubmVjdG9yTWF0ZXJpYWxSZWYuY3VycmVudC51bmlmb3Jtcy51X3JhZGl1c0IudmFsdWUgPSBCQVNFX1ZBTFVFUy5yYWRpdXNCICogc2NhbGVGYWN0b3I7XG4gICAgICBncmlkQ29ubmVjdG9yTWF0ZXJpYWxSZWYuY3VycmVudC51bmlmb3Jtcy51X3JhZGl1c0EudmFsdWUgPSBCQVNFX1ZBTFVFUy5yYWRpdXNBICogc2NhbGVGYWN0b3I7XG4gICAgICBncmlkQ29ubmVjdG9yTWF0ZXJpYWxSZWYuY3VycmVudC51bmlmb3Jtcy51X3NwYWNpbmcudmFsdWUgPSBncmlkU3BhY2luZztcbiAgICAgIGdyaWRDb25uZWN0b3JNYXRlcmlhbFJlZi5jdXJyZW50LnVuaWZvcm1zLnVfZ3JpZFN0YXRlLnZhbHVlID0gZ3JpZFN0YXRlVGV4dHVyZTtcbiAgICAgIGdyaWRDb25uZWN0b3JNYXRlcmlhbFJlZi5jdXJyZW50LnVuaWZvcm1zLnVfYWN0aXZlQ29ubmVjdG9yID0geyB2YWx1ZTogYWN0aXZlQ29ubmVjdG9yIH07XG4gICAgICAvLyBQYXNzIHRoZSBjb25uZWN0b3IgdGhpY2tuZXNzIHRvIHRoZSBzaGFkZXIgKGlmIGl0IGV4aXN0cyAtIG1pZ2h0IHJlbW92ZSBsYXRlcilcbiAgICAgIGlmIChncmlkQ29ubmVjdG9yTWF0ZXJpYWxSZWYuY3VycmVudC51bmlmb3Jtcy51X3RoaWNrbmVzcykge1xuICAgICAgICAvLyBncmlkQ29ubmVjdG9yTWF0ZXJpYWxSZWYuY3VycmVudC51bmlmb3Jtcy51X3RoaWNrbmVzcy52YWx1ZSA9IGNvbm5lY3RvclRoaWNrbmVzczsgLy8gS2VlcCBjb21tZW50ZWQgb3V0IGZvciBub3dcbiAgICAgIH1cbiAgICAgIC8vIFBhc3MgdGhlIGN1cnZhdHVyZSBwYXJhbWV0ZXIgKGlmIGl0IGV4aXN0cyAtIG1pZ2h0IHJlbW92ZSBsYXRlcilcbiAgICAgIGlmIChncmlkQ29ubmVjdG9yTWF0ZXJpYWxSZWYuY3VycmVudC51bmlmb3Jtcy51X2N1cnZhdHVyZSkge1xuICAgICAgICAvLyBncmlkQ29ubmVjdG9yTWF0ZXJpYWxSZWYuY3VycmVudC51bmlmb3Jtcy51X2N1cnZhdHVyZS52YWx1ZSA9IGNvbm5lY3RvckN1cnZhdHVyZTsgLy8gS2VlcCBjb21tZW50ZWQgb3V0IGZvciBub3dcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gVXBkYXRlIHNpbXBsZSBjb25uZWN0b3IgbWF0ZXJpYWwgdW5pZm9ybXNcbiAgICBpZiAoc2ltcGxlQ29ubmVjdG9yTWF0ZXJpYWxSZWYuY3VycmVudCkge1xuICAgICAgLy8gU2NhbGUgdGhlIHJhZGl1cyBhbmQgYm94IHNpemUgdmFsdWVzIHByb3BvcnRpb25hbGx5XG4gICAgICBzaW1wbGVDb25uZWN0b3JNYXRlcmlhbFJlZi5jdXJyZW50LnVuaWZvcm1zLnVfcmFkaXVzQi52YWx1ZSA9IEJBU0VfVkFMVUVTLnJhZGl1c0IgKiBzY2FsZUZhY3RvcjtcbiAgICAgIHNpbXBsZUNvbm5lY3Rvck1hdGVyaWFsUmVmLmN1cnJlbnQudW5pZm9ybXMudV9yYWRpdXNBLnZhbHVlID0gQkFTRV9WQUxVRVMucmFkaXVzQSAqIHNjYWxlRmFjdG9yO1xuICAgICAgc2ltcGxlQ29ubmVjdG9yTWF0ZXJpYWxSZWYuY3VycmVudC51bmlmb3Jtcy51X2JveFNpemUudmFsdWUgPSBCQVNFX1ZBTFVFUy5ib3hTaXplICogc2NhbGVGYWN0b3I7XG4gICAgICBzaW1wbGVDb25uZWN0b3JNYXRlcmlhbFJlZi5jdXJyZW50LnVuaWZvcm1zLnVfc3BhY2luZy52YWx1ZSA9IGdyaWRTcGFjaW5nO1xuICAgICAgc2ltcGxlQ29ubmVjdG9yTWF0ZXJpYWxSZWYuY3VycmVudC51bmlmb3Jtcy51X2dyaWRTdGF0ZS52YWx1ZSA9IGdyaWRTdGF0ZVRleHR1cmU7XG4gICAgICBzaW1wbGVDb25uZWN0b3JNYXRlcmlhbFJlZi5jdXJyZW50LnVuaWZvcm1zLnVfYWN0aXZlQ29ubmVjdG9yID0geyB2YWx1ZTogYWN0aXZlQ29ubmVjdG9yIH07XG4gICAgfVxuICB9LCBbZ3JpZFN0YXRlLCBncmlkU3RhdGVUZXh0dXJlLCBncmlkU3BhY2luZywgZGVidWcsIHNob3dTaW1wbGUsIGFjdGl2ZUNvbm5lY3Rvcl0pO1xuXG4gIC8vIFVwZGF0ZSBjYW1lcmEgem9vbSBiYXNlZCBvbiBjb250cm9sXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGNhbWVyYSkge1xuICAgICAgY2FtZXJhLnpvb20gPSAxMDAgKiAoMS96b29tKTsgLy8gQWRqdXN0IGFzIG5lZWRlZCBmb3Igc2NhbGVcbiAgICAgIGNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgfVxuICB9LCBbY2FtZXJhLCB6b29tXSk7XG5cbiAgLy8gVXBkYXRlIGluc3RhbmNlIG1hdHJpY2VzIGFuZCB2aXNpYmlsaXR5IGF0dHJpYnV0ZXMgYmFzZWQgb24gc3RhdGVcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWluc3RhbmNlZE1lc2hSZWYuY3VycmVudCkgcmV0dXJuO1xuXG4gICAgbGV0IGluc3RhbmNlSWQgPSAwO1xuICAgIFxuICAgIC8vIENhbGN1bGF0ZSBncmlkIHN0YXJ0aW5nIHBvc2l0aW9uXG4gICAgY29uc3Qgc3RhcnRPZmZzZXQgPSAoR1JJRF9TSVpFIC0gMSkgKiAwLjUgKiBncmlkU3BhY2luZztcbiAgICBcbiAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCBHUklEX1NJWkU7IHJvdysrKSB7XG4gICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBHUklEX1NJWkU7IGNvbCsrKSB7XG4gICAgICAgIC8vIFBvc2l0aW9uIGF0IGdyaWQgaW50ZXJzZWN0aW9uc1xuICAgICAgICBjb25zdCB4ID0gY29sICogZ3JpZFNwYWNpbmcgLSBzdGFydE9mZnNldDtcbiAgICAgICAgY29uc3QgeSA9IC0ocm93ICogZ3JpZFNwYWNpbmcgLSBzdGFydE9mZnNldCk7IC8vIFkgaXMgaW52ZXJ0ZWQgZm9yIHNjcmVlbiBjb29yZGluYXRlc1xuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBkdW1teSBvYmplY3QncyBwb3NpdGlvblxuICAgICAgICBkdW1teS5wb3NpdGlvbi5zZXQoeCwgeSwgMCk7XG4gICAgICAgIGR1bW15LnVwZGF0ZU1hdHJpeCgpO1xuICAgICAgICBcbiAgICAgICAgLy8gU2V0IHRoZSBpbnN0YW5jZSBtYXRyaXhcbiAgICAgICAgaW5zdGFuY2VkTWVzaFJlZi5jdXJyZW50LnNldE1hdHJpeEF0KGluc3RhbmNlSWQsIGR1bW15Lm1hdHJpeCk7XG4gICAgICAgIFxuICAgICAgICAvLyBTdG9yZSBwb3NpdGlvbiBmb3IgY2xpY2sgZGV0ZWN0aW9uXG4gICAgICAgIGluc3RhbmNlUG9zaXRpb25zLmN1cnJlbnRbaW5zdGFuY2VJZF0uc2V0KHgsIHksIDApO1xuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIHZpc2liaWxpdHkgYXR0cmlidXRlc1xuICAgICAgICBpbnN0YW5jZVNob3dJbm5lcltpbnN0YW5jZUlkXSA9IGdyaWRTdGF0ZVtyb3ddW2NvbF0uc2hvd0lubmVyID8gMS4wIDogMC4wO1xuICAgICAgICBpbnN0YW5jZVNob3dPdXRlcltpbnN0YW5jZUlkXSA9IGdyaWRTdGF0ZVtyb3ddW2NvbF0uc2hvd091dGVyID8gMS4wIDogMC4wO1xuICAgICAgICBcbiAgICAgICAgaW5zdGFuY2VJZCsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1hcmsgYXR0cmlidXRlcyBhbmQgbWF0cml4IGZvciB1cGRhdGVcbiAgICBpbnN0YW5jZWRNZXNoUmVmLmN1cnJlbnQuZ2VvbWV0cnkuYXR0cmlidXRlcy5hX2luc3RhbmNlU2hvd0lubmVyLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICBpbnN0YW5jZWRNZXNoUmVmLmN1cnJlbnQuZ2VvbWV0cnkuYXR0cmlidXRlcy5hX2luc3RhbmNlU2hvd091dGVyLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICBpbnN0YW5jZWRNZXNoUmVmLmN1cnJlbnQuaW5zdGFuY2VNYXRyaXgubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgLy8gVXBkYXRlIGdsb2JhbCB1bmlmb3JtcyB3aXRoIHRoZSByYWRpdXMgdmFsdWVzXG4gICAgaWYgKG1hdGVyaWFsUmVmLmN1cnJlbnQpIHtcbiAgICAgIC8vIENhbGN1bGF0ZSBzY2FsZSBmYWN0b3IgYmFzZWQgb24gcmF0aW8gdG8gYmFzZSBncmlkIHNwYWNpbmdcbiAgICAgIGNvbnN0IHNjYWxlRmFjdG9yID0gZ3JpZFNwYWNpbmcgLyBCQVNFX1ZBTFVFUy5iYXNlU3BhY2luZztcbiAgICAgIFxuICAgICAgbWF0ZXJpYWxSZWYuY3VycmVudC51bmlmb3Jtcy51X3JhZGl1c0IudmFsdWUgPSBCQVNFX1ZBTFVFUy5yYWRpdXNCICogc2NhbGVGYWN0b3I7XG4gICAgICBtYXRlcmlhbFJlZi5jdXJyZW50LnVuaWZvcm1zLnVfcmFkaXVzQS52YWx1ZSA9IEJBU0VfVkFMVUVTLnJhZGl1c0EgKiBzY2FsZUZhY3RvcjtcbiAgICAgIG1hdGVyaWFsUmVmLmN1cnJlbnQudW5pZm9ybXMudV9zcGFjaW5nLnZhbHVlID0gZ3JpZFNwYWNpbmc7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIGdyaWQgaGVscGVyIHRvIG1hdGNoIHNwYWNpbmdcbiAgICBpZiAoZ3JpZEhlbHBlclJlZi5jdXJyZW50KSB7XG4gICAgICBncmlkSGVscGVyUmVmLmN1cnJlbnQuc2NhbGUuc2V0KGdyaWRTcGFjaW5nLCBncmlkU3BhY2luZywgMSk7XG4gICAgfVxuXG4gIH0sIFtncmlkU3RhdGUsIGdyaWRTcGFjaW5nLCBpbnN0YW5jZVNob3dJbm5lciwgaW5zdGFuY2VTaG93T3V0ZXJdKTtcblxuICAvLyBIYW5kbGUgY2xpY2sgb24gdGhlIGNhbnZhc1xuICBjb25zdCBoYW5kbGVDbGljayA9IChldmVudCkgPT4ge1xuICAgIGlmICghaW5zdGFuY2VkTWVzaFJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIHNjYWxlIGZhY3RvciBiYXNlZCBvbiByYXRpbyB0byBiYXNlIGdyaWQgc3BhY2luZ1xuICAgIGNvbnN0IHNjYWxlRmFjdG9yID0gZ3JpZFNwYWNpbmcgLyBCQVNFX1ZBTFVFUy5iYXNlU3BhY2luZztcbiAgICBcbiAgICAvLyBTY2FsZSB0aGUgcmFkaXVzIHZhbHVlcyBmb3IgaGl0IGRldGVjdGlvblxuICAgIGNvbnN0IHNjYWxlZFJhZGl1c0IgPSBCQVNFX1ZBTFVFUy5yYWRpdXNCICogc2NhbGVGYWN0b3I7XG4gICAgY29uc3Qgc2NhbGVkUmFkaXVzQSA9IEJBU0VfVkFMVUVTLnJhZGl1c0EgKiBzY2FsZUZhY3RvcjtcbiAgICBcbiAgICAvLyBHcmlkIHBvc2l0aW9ucyBmb3IgZGV0ZWN0aW5nIGNvbm5lY3RvciBhcmVhXG4gICAgY29uc3QgZ3JpZE9mZnNldCA9IGdyaWRTcGFjaW5nICogMC41O1xuICAgIGNvbnN0IGNlbnRlckEgPSBuZXcgVEhSRUUuVmVjdG9yMigtZ3JpZE9mZnNldCwgZ3JpZE9mZnNldCk7ICAgLy8gVG9wLWxlZnQgKEEpXG4gICAgY29uc3QgY2VudGVyQiA9IG5ldyBUSFJFRS5WZWN0b3IyKGdyaWRPZmZzZXQsIC1ncmlkT2Zmc2V0KTsgICAvLyBCb3R0b20tcmlnaHQgKEIpXG4gICAgY29uc3QgY2VudGVyQyA9IG5ldyBUSFJFRS5WZWN0b3IyKC1ncmlkT2Zmc2V0LCAtZ3JpZE9mZnNldCk7ICAvLyBCb3R0b20tbGVmdCAoQylcbiAgICBjb25zdCBjZW50ZXJEID0gbmV3IFRIUkVFLlZlY3RvcjIoZ3JpZE9mZnNldCwgZ3JpZE9mZnNldCk7ICAgIC8vIFRvcC1yaWdodCAoRClcbiAgICBcbiAgICAvLyBDcmVhdGUgYSAyRCBwb2ludCBmcm9tIHRoZSBjbGljayBldmVudCBmb3IgZWFzaWVyIGNhbGN1bGF0aW9uc1xuICAgIGNvbnN0IGNsaWNrUG9pbnQgPSBuZXcgVEhSRUUuVmVjdG9yMihldmVudC5wb2ludC54LCBldmVudC5wb2ludC55KTtcbiAgICBcbiAgICAvLyBDaGVjayBpZiB3ZSBjbGlja2VkIG9uIGEgY29ubmVjdG9yIGFyZWFcbiAgICBjb25zdCBpc0luQUJDb25uZWN0b3JBcmVhID0gaXNQb2ludEluQ29ubmVjdG9yQXJlYShjbGlja1BvaW50LCBjZW50ZXJBLCBjZW50ZXJCLCBzY2FsZWRSYWRpdXNCLCBzY2FsZWRSYWRpdXNBKTtcbiAgICBjb25zdCBpc0luQ0RDb25uZWN0b3JBcmVhID0gaXNQb2ludEluQ29ubmVjdG9yQXJlYShjbGlja1BvaW50LCBjZW50ZXJDLCBjZW50ZXJELCBzY2FsZWRSYWRpdXNCLCBzY2FsZWRSYWRpdXNBKTtcbiAgICBcbiAgICBpZiAoaXNJbkFCQ29ubmVjdG9yQXJlYSB8fCBpc0luQ0RDb25uZWN0b3JBcmVhKSB7XG4gICAgICAvLyBDbGlja2VkIGluIGEgY29ubmVjdG9yIGFyZWEsIGN5Y2xlIHRoZSBhY3RpdmUgY29ubmVjdG9yIHN0YXRlXG4gICAgICBzZXRBY3RpdmVDb25uZWN0b3IocHJldlN0YXRlID0+IHtcbiAgICAgICAgaWYgKHByZXZTdGF0ZSA9PT0gMCkge1xuICAgICAgICAgIC8vIE5vbmUgLT4gRmlyc3QgY29ubmVjdG9yIChSZWQgQUIgb3IgQmx1ZSBDRCBiYXNlZCBvbiB3aGljaCBhcmVhIGNsaWNrZWQpXG4gICAgICAgICAgcmV0dXJuIGlzSW5BQkNvbm5lY3RvckFyZWEgPyAxIDogMjtcbiAgICAgICAgfSBlbHNlIGlmIChwcmV2U3RhdGUgPT09IDEgJiYgaXNJbkFCQ29ubmVjdG9yQXJlYSkge1xuICAgICAgICAgIC8vIFJlZCBBQiAtPiBCbHVlIENEXG4gICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIH0gZWxzZSBpZiAocHJldlN0YXRlID09PSAyICYmIGlzSW5DRENvbm5lY3RvckFyZWEpIHtcbiAgICAgICAgICAvLyBCbHVlIENEIC0+IE5vbmVcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUb2dnbGUgYmV0d2VlbiBjdXJyZW50IGNvbm5lY3RvciBhbmQgTm9uZVxuICAgICAgICAgIHJldHVybiBwcmV2U3RhdGUgPT09IDAgPyAoaXNJbkFCQ29ubmVjdG9yQXJlYSA/IDEgOiAyKSA6IDA7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICByZXR1cm47IC8vIEV4aXQgYWZ0ZXIgaGFuZGxpbmcgY29ubmVjdG9yIGNsaWNrXG4gICAgfVxuICAgIFxuICAgIC8vIElmIG5vIGluc3RhbmNlIHdhcyBoaXQsIHJldHVyblxuICAgIGlmIChldmVudC5pbnN0YW5jZUlkID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICBcbiAgICBjb25zdCBpbnN0YW5jZUlkID0gZXZlbnQuaW5zdGFuY2VJZDtcbiAgICBjb25zdCB7IHJvdywgY29sIH0gPSBnZXRHcmlkQ29vcmRzKGluc3RhbmNlSWQpO1xuICAgIGNvbnNvbGUubG9nKGBDbGlja2VkIGluc3RhbmNlOiByb3c9JHtyb3d9LCBjb2w9JHtjb2x9YCk7XG4gICAgXG4gICAgY29uc3QgY3VycmVudFN0YXRlID0gZ3JpZFN0YXRlW3Jvd11bY29sXTtcbiAgICBcbiAgICAvLyBHZXQgaW5zdGFuY2UgcG9zaXRpb24gZnJvbSBvdXIgc3RvcmVkIHJlZmVyZW5jZVxuICAgIGNvbnN0IGluc3RhbmNlUG9zaXRpb24gPSBpbnN0YW5jZVBvc2l0aW9ucy5jdXJyZW50W2luc3RhbmNlSWRdO1xuICAgIFxuICAgIC8vIENyZWF0ZSBhIGNvcHkgb2YgdGhlIGNsaWNrIHBvaW50XG4gICAgY29uc3QgcG9pbnRDb3B5ID0gZXZlbnQucG9pbnQuY2xvbmUoKTtcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgZGlzdGFuY2UgZnJvbSBjbGljayB0byBpbnN0YW5jZSBjZW50ZXJcbiAgICBjb25zdCBkaXN0RnJvbUNlbnRlciA9IHBvaW50Q29weS5kaXN0YW5jZVRvKGluc3RhbmNlUG9zaXRpb24pO1xuICAgIFxuICAgIGxldCBuZXdJbm5lciA9IGN1cnJlbnRTdGF0ZS5zaG93SW5uZXI7XG4gICAgbGV0IG5ld091dGVyID0gY3VycmVudFN0YXRlLnNob3dPdXRlcjtcblxuICAgIGlmIChkaXN0RnJvbUNlbnRlciA8PSBzY2FsZWRSYWRpdXNCKSB7XG4gICAgICAvLyBDbGlja2VkIGlubmVyIGNpcmNsZVxuICAgICAgbmV3SW5uZXIgPSAhY3VycmVudFN0YXRlLnNob3dJbm5lcjtcbiAgICAgIGNvbnNvbGUubG9nKGBUb2dnbGluZyBpbm5lciBjaXJjbGU6ICR7Y3VycmVudFN0YXRlLnNob3dJbm5lcn0gLT4gJHtuZXdJbm5lcn1gKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgdG9nZ2xpbmcgb2ZmIGFuIGlubmVyIGNpcmNsZSB0aGF0IHdhcyBwYXJ0IG9mIGFuIGFjdGl2ZSBjb25uZWN0b3JcbiAgICAgIGlmICghbmV3SW5uZXIpIHtcbiAgICAgICAgLy8gVG9wLWxlZnQgY2lyY2xlIGlzIHBhcnQgb2YgcmVkIGNvbm5lY3RvclxuICAgICAgICBpZiAocm93ID09PSAwICYmIGNvbCA9PT0gMCAmJiBhY3RpdmVDb25uZWN0b3IgPT09IDEpIHtcbiAgICAgICAgICBzZXRBY3RpdmVDb25uZWN0b3IoMCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQm90dG9tLXJpZ2h0IGNpcmNsZSBpcyBwYXJ0IG9mIHJlZCBjb25uZWN0b3JcbiAgICAgICAgZWxzZSBpZiAocm93ID09PSAxICYmIGNvbCA9PT0gMSAmJiBhY3RpdmVDb25uZWN0b3IgPT09IDEpIHtcbiAgICAgICAgICBzZXRBY3RpdmVDb25uZWN0b3IoMCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQm90dG9tLWxlZnQgY2lyY2xlIGlzIHBhcnQgb2YgYmx1ZSBjb25uZWN0b3JcbiAgICAgICAgZWxzZSBpZiAocm93ID09PSAxICYmIGNvbCA9PT0gMCAmJiBhY3RpdmVDb25uZWN0b3IgPT09IDIpIHtcbiAgICAgICAgICBzZXRBY3RpdmVDb25uZWN0b3IoMCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVG9wLXJpZ2h0IGNpcmNsZSBpcyBwYXJ0IG9mIGJsdWUgY29ubmVjdG9yXG4gICAgICAgIGVsc2UgaWYgKHJvdyA9PT0gMCAmJiBjb2wgPT09IDEgJiYgYWN0aXZlQ29ubmVjdG9yID09PSAyKSB7XG4gICAgICAgICAgc2V0QWN0aXZlQ29ubmVjdG9yKDApO1xuICAgICAgICB9XG4gICAgICB9IFxuICAgICAgLy8gSWYgdG9nZ2xpbmcgT04gYW4gaW5uZXIgY2lyY2xlLCBjaGVjayBpZiBpdCBjb21wbGV0ZXMgYSBkaWFnb25hbCBwYWlyXG4gICAgICBlbHNlIGlmIChuZXdJbm5lcikge1xuICAgICAgICAvLyBPbmx5IGFjdGl2YXRlIGNvbm5lY3RvciBpZiBubyBjb25uZWN0b3IgaXMgY3VycmVudGx5IGFjdGl2ZVxuICAgICAgICBpZiAoYWN0aXZlQ29ubmVjdG9yID09PSAwKSB7XG4gICAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBjb21wbGV0ZXMgYSBkaWFnb25hbCBwYWlyIC0gUmVkIGNvbm5lY3RvciAodG9wLWxlZnQgdG8gYm90dG9tLXJpZ2h0KVxuICAgICAgICAgIGlmICgocm93ID09PSAwICYmIGNvbCA9PT0gMCAmJiBncmlkU3RhdGVbMV1bMV0uc2hvd0lubmVyKSB8fCBcbiAgICAgICAgICAgICAgKHJvdyA9PT0gMSAmJiBjb2wgPT09IDEgJiYgZ3JpZFN0YXRlWzBdWzBdLnNob3dJbm5lcikpIHtcbiAgICAgICAgICAgIHNldEFjdGl2ZUNvbm5lY3RvcigxKTsgLy8gQWN0aXZhdGUgcmVkIGNvbm5lY3RvclxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGNvbXBsZXRlcyBhIGRpYWdvbmFsIHBhaXIgLSBCbHVlIGNvbm5lY3RvciAoYm90dG9tLWxlZnQgdG8gdG9wLXJpZ2h0KVxuICAgICAgICAgIGVsc2UgaWYgKChyb3cgPT09IDEgJiYgY29sID09PSAwICYmIGdyaWRTdGF0ZVswXVsxXS5zaG93SW5uZXIpIHx8IFxuICAgICAgICAgICAgICAgICAgKHJvdyA9PT0gMCAmJiBjb2wgPT09IDEgJiYgZ3JpZFN0YXRlWzFdWzBdLnNob3dJbm5lcikpIHtcbiAgICAgICAgICAgIHNldEFjdGl2ZUNvbm5lY3RvcigyKTsgLy8gQWN0aXZhdGUgYmx1ZSBjb25uZWN0b3JcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRpc3RGcm9tQ2VudGVyIDw9IHNjYWxlZFJhZGl1c0EpIHtcbiAgICAgIC8vIENsaWNrZWQgb3V0ZXIgY2lyY2xlXG4gICAgICBuZXdPdXRlciA9ICFjdXJyZW50U3RhdGUuc2hvd091dGVyO1xuICAgICAgY29uc29sZS5sb2coYFRvZ2dsaW5nIG91dGVyIGNpcmNsZTogJHtjdXJyZW50U3RhdGUuc2hvd091dGVyfSAtPiAke25ld091dGVyfWApO1xuICAgIH1cbiAgICBcbiAgICBpZiAobmV3SW5uZXIgIT09IGN1cnJlbnRTdGF0ZS5zaG93SW5uZXIgfHwgbmV3T3V0ZXIgIT09IGN1cnJlbnRTdGF0ZS5zaG93T3V0ZXIpIHtcbiAgICAgIHNldEdyaWRTdGF0ZShwcmV2U3RhdGUgPT4ge1xuICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocHJldlN0YXRlKSk7IC8vIERlZXAgY29weVxuICAgICAgICBuZXdTdGF0ZVtyb3ddW2NvbF0gPSB7IHNob3dJbm5lcjogbmV3SW5uZXIsIHNob3dPdXRlcjogbmV3T3V0ZXIgfTtcbiAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBcbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGRldGVybWluZSBpZiBhIHBvaW50IGlzIGluIHRoZSBjb25uZWN0b3IgYXJlYVxuICBjb25zdCBpc1BvaW50SW5Db25uZWN0b3JBcmVhID0gKHBvaW50LCBjZW50ZXIxLCBjZW50ZXIyLCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMpID0+IHtcbiAgICAvLyBDaGVjayB0aGF0IHBvaW50IGlzIG5vdCBpbnNpZGUgZWl0aGVyIGlubmVyIGNpcmNsZVxuICAgIGNvbnN0IGRpc3RUb0NlbnRlcjEgPSBwb2ludC5kaXN0YW5jZVRvKGNlbnRlcjEpO1xuICAgIGNvbnN0IGRpc3RUb0NlbnRlcjIgPSBwb2ludC5kaXN0YW5jZVRvKGNlbnRlcjIpO1xuICAgIFxuICAgIGlmIChkaXN0VG9DZW50ZXIxIDwgaW5uZXJSYWRpdXMgfHwgZGlzdFRvQ2VudGVyMiA8IGlubmVyUmFkaXVzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7IC8vIEluc2lkZSBhbiBpbm5lciBjaXJjbGVcbiAgICB9XG4gICAgXG4gICAgLy8gUHJvamVjdCBwb2ludCBvbnRvIHRoZSBsaW5lIGNvbm5lY3RpbmcgdGhlIGNlbnRlcnNcbiAgICBjb25zdCBkaXJlY3Rpb24gPSBuZXcgVEhSRUUuVmVjdG9yMigpLnN1YlZlY3RvcnMoY2VudGVyMiwgY2VudGVyMSkubm9ybWFsaXplKCk7XG4gICAgY29uc3QgY2VudGVyMVRvUG9pbnQgPSBuZXcgVEhSRUUuVmVjdG9yMigpLnN1YlZlY3RvcnMocG9pbnQsIGNlbnRlcjEpO1xuICAgIGNvbnN0IHByb2plY3Rpb25MZW5ndGggPSBjZW50ZXIxVG9Qb2ludC5kb3QoZGlyZWN0aW9uKTtcbiAgICBcbiAgICAvLyBDaGVjayBpZiBwcm9qZWN0aW9uIGZhbGxzIGJldHdlZW4gdGhlIHR3byBjZW50ZXJzICh3aXRoIHNvbWUgYnVmZmVyKVxuICAgIGNvbnN0IGRpc3RhbmNlQmV0d2VlbkNlbnRlcnMgPSBjZW50ZXIxLmRpc3RhbmNlVG8oY2VudGVyMik7XG4gICAgaWYgKHByb2plY3Rpb25MZW5ndGggPCAtb3V0ZXJSYWRpdXMgfHwgcHJvamVjdGlvbkxlbmd0aCA+IGRpc3RhbmNlQmV0d2VlbkNlbnRlcnMgKyBvdXRlclJhZGl1cykge1xuICAgICAgcmV0dXJuIGZhbHNlOyAvLyBPdXRzaWRlIHRoZSByZWdpb24gYmV0d2VlbiBjaXJjbGVzXG4gICAgfVxuICAgIFxuICAgIC8vIENhbGN1bGF0ZSBwZXJwZW5kaWN1bGFyIGRpc3RhbmNlIGZyb20gcG9pbnQgdG8gbGluZVxuICAgIGNvbnN0IHByb2plY3RlZFBvaW50ID0gbmV3IFRIUkVFLlZlY3RvcjIoKS5jb3B5KGNlbnRlcjEpLmFkZFNjYWxlZFZlY3RvcihkaXJlY3Rpb24sIHByb2plY3Rpb25MZW5ndGgpO1xuICAgIGNvbnN0IHBlcnBEaXN0YW5jZSA9IHBvaW50LmRpc3RhbmNlVG8ocHJvamVjdGVkUG9pbnQpO1xuICAgIFxuICAgIC8vIERlZmluZSBhIHJlYXNvbmFibGUgd2lkdGggZm9yIHRoZSBjb25uZWN0b3IgYXJlYVxuICAgIGNvbnN0IGNvbm5lY3RvcldpZHRoID0gb3V0ZXJSYWRpdXMgKiAwLjg7XG4gICAgXG4gICAgcmV0dXJuIHBlcnBEaXN0YW5jZSA8IGNvbm5lY3RvcldpZHRoO1xuICB9O1xuXG4gIC8vIENhbGN1bGF0ZSBwbGFuZSBzaXplIGJhc2VkIG9uIHRoZSBncmlkIHNpemUgYW5kIHNwYWNpbmdcbiAgY29uc3QgY29ubmVjdG9yUGxhbmVTaXplID0gdXNlTWVtbygoKSA9PiBcbiAgICBHUklEX1NJWkUgKiBncmlkU3BhY2luZyArIE1hdGgubWF4KEJBU0VfVkFMVUVTLnJhZGl1c0EsIEJBU0VfVkFMVUVTLnJhZGl1c0IpICogMixcbiAgICBbZ3JpZFNwYWNpbmcsIEJBU0VfVkFMVUVTLnJhZGl1c0EsIEJBU0VfVkFMVUVTLnJhZGl1c0JdXG4gICk7XG5cbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAgey8qIERlYnVnIGNvbG9yZWQgcGxhbmUgdG8gdmVyaWZ5IHJlbmRlcmluZyAqL31cbiAgICAgIHtkZWJ1ZyAmJiAoXG4gICAgICAgIDxtZXNoIHJlZj17ZGVidWdNZXNoUmVmfSBwb3NpdGlvbj17WzAsIDAsIC0wLjJdfT5cbiAgICAgICAgICA8cGxhbmVHZW9tZXRyeSBhcmdzPXtbY29ubmVjdG9yUGxhbmVTaXplLCBjb25uZWN0b3JQbGFuZVNpemVdfSAvPlxuICAgICAgICAgIDxtZXNoQmFzaWNNYXRlcmlhbCBjb2xvcj1cImJsdWVcIiBvcGFjaXR5PXswLjF9IHRyYW5zcGFyZW50IC8+XG4gICAgICAgIDwvbWVzaD5cbiAgICAgICl9XG5cbiAgICAgIHsvKiBTaW1wbGUgY29ubmVjdG9yIGZvciBkZWJ1Z2dpbmcgKGhpZ2hlciB6LWluZGV4IHNvIGl0J3MgdmlzaWJsZSkgKi99XG4gICAgICA8bWVzaCByZWY9e3NpbXBsZUNvbm5lY3Rvck1lc2hSZWZ9IHBvc2l0aW9uPXtbMCwgMCwgMC4xXX0gdmlzaWJsZT17c2hvd1NpbXBsZX0+XG4gICAgICAgIDxwbGFuZUdlb21ldHJ5IGFyZ3M9e1tjb25uZWN0b3JQbGFuZVNpemUsIGNvbm5lY3RvclBsYW5lU2l6ZV19IC8+XG4gICAgICAgIDxzaW1wbGVDb25uZWN0b3JNYXRlcmlhbFxuICAgICAgICAgIHJlZj17c2ltcGxlQ29ubmVjdG9yTWF0ZXJpYWxSZWZ9XG4gICAgICAgICAga2V5PXtTaW1wbGVDb25uZWN0b3JNYXRlcmlhbC5rZXl9XG4gICAgICAgICAgdHJhbnNwYXJlbnQ9e3RydWV9XG4gICAgICAgICAgZGVwdGhUZXN0PXtmYWxzZX1cbiAgICAgICAgLz5cbiAgICAgIDwvbWVzaD5cblxuICAgICAgey8qIEFkZCBvcmlnaW5hbCBjb25uZWN0b3IgbWVzaCBmb3IgdGhlIHNoYXBlcyBiZXR3ZWVuIGNpcmNsZXMgKi99XG4gICAgICA8bWVzaCByZWY9e2Nvbm5lY3Rvck1lc2hSZWZ9IHBvc2l0aW9uPXtbMCwgMCwgLTAuMV19IHZpc2libGU9eyFzaG93U2ltcGxlfT5cbiAgICAgICAgPHBsYW5lR2VvbWV0cnkgYXJncz17W2Nvbm5lY3RvclBsYW5lU2l6ZSwgY29ubmVjdG9yUGxhbmVTaXplXX0gLz5cbiAgICAgICAgPGdyaWRDb25uZWN0b3JNYXRlcmlhbFxuICAgICAgICAgIHJlZj17Z3JpZENvbm5lY3Rvck1hdGVyaWFsUmVmfVxuICAgICAgICAgIGtleT17R3JpZENvbm5lY3Rvck1hdGVyaWFsLmtleX1cbiAgICAgICAgICB0cmFuc3BhcmVudD17dHJ1ZX1cbiAgICAgICAgICBkZXB0aFRlc3Q9e2ZhbHNlfVxuICAgICAgICAvPlxuICAgICAgPC9tZXNoPlxuXG4gICAgICB7LyogQ2lyY2xlcyAqL31cbiAgICAgIDxpbnN0YW5jZWRNZXNoXG4gICAgICAgIHJlZj17aW5zdGFuY2VkTWVzaFJlZn1cbiAgICAgICAgYXJncz17W251bGwsIG51bGwsIFRPVEFMX0lOU1RBTkNFU119XG4gICAgICAgIG9uQ2xpY2s9e2hhbmRsZUNsaWNrfVxuICAgICAgICBwb3NpdGlvbj17WzAsIDAsIDBdfVxuICAgICAgPlxuICAgICAgICA8cGxhbmVHZW9tZXRyeSBhcmdzPXtbY29ubmVjdG9yUGxhbmVTaXplLCBjb25uZWN0b3JQbGFuZVNpemVdfT5cbiAgICAgICAgICA8aW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlIFxuICAgICAgICAgICAgYXR0YWNoPVwiYXR0cmlidXRlcy1hX2luc3RhbmNlU2hvd0lubmVyXCIgXG4gICAgICAgICAgICBhcmdzPXtbaW5zdGFuY2VTaG93SW5uZXIsIDFdfSBcbiAgICAgICAgICAvPlxuICAgICAgICAgIDxpbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgXG4gICAgICAgICAgICBhdHRhY2g9XCJhdHRyaWJ1dGVzLWFfaW5zdGFuY2VTaG93T3V0ZXJcIiBcbiAgICAgICAgICAgIGFyZ3M9e1tpbnN0YW5jZVNob3dPdXRlciwgMV19IFxuICAgICAgICAgIC8+XG4gICAgICAgIDwvcGxhbmVHZW9tZXRyeT5cbiAgICAgICAgPGNvbm5lY3Rvck1hdGVyaWFsXG4gICAgICAgICAgcmVmPXttYXRlcmlhbFJlZn1cbiAgICAgICAgICBrZXk9e0Nvbm5lY3Rvck1hdGVyaWFsLmtleX1cbiAgICAgICAgICB0cmFuc3BhcmVudD17dHJ1ZX1cbiAgICAgICAgLz5cbiAgICAgIDwvaW5zdGFuY2VkTWVzaD5cblxuICAgICAgey8qIEdyaWQgbGluZXMgdGhhdCBtYXRjaCB0aGUgZ3JpZCBzcGFjaW5nICovfVxuICAgICAgPGdyb3VwIHJlZj17Z3JpZEhlbHBlclJlZn0gcG9zaXRpb249e1swLCAwLCAtMC4yXX0+XG4gICAgICAgIDxncmlkSGVscGVyIFxuICAgICAgICAgIGFyZ3M9e1sxMCwgMTBdfSBcbiAgICAgICAgICByb3RhdGlvbj17W01hdGguUEkgLyAyLCAwLCAwXX1cbiAgICAgICAgLz5cbiAgICAgIDwvZ3JvdXA+XG4gICAgPC8+XG4gICk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFdlYkdMQ2FudmFzKCkge1xuICByZXR1cm4gKFxuICAgIC8vIFNldCB1cCB0aGUgUjNGIENhbnZhc1xuICAgIDxDYW52YXMgc3R5bGU9e3sgYmFja2dyb3VuZDogJyNmMGYwZjAnIH19PlxuICAgICAgey8qIE9ydGhvZ3JhcGhpYyBjYW1lcmEgZm9yIHRydWUgMkQgdmlldyAqL31cbiAgICAgIDxPcnRob2dyYXBoaWNDYW1lcmEgXG4gICAgICAgIG1ha2VEZWZhdWx0IFxuICAgICAgICB6b29tPXsxMDB9IFxuICAgICAgICBwb3NpdGlvbj17WzAsIDAsIDVdfSBcbiAgICAgICAgcm90YXRpb249e1swLCAwLCAwXX1cbiAgICAgIC8+XG4gICAgICA8YW1iaWVudExpZ2h0IGludGVuc2l0eT17MC44fSAvPlxuICAgICAgPFNjZW5lIC8+XG4gICAgPC9DYW52YXM+XG4gICk7XG59ICJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZVJlZiIsInVzZU1lbW8iLCJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsIkNhbnZhcyIsInVzZUZyYW1lIiwiZXh0ZW5kIiwidXNlVGhyZWUiLCJPcnRob2dyYXBoaWNDYW1lcmEiLCJUSFJFRSIsInVzZUNvbnRyb2xzIiwiZm9sZGVyIiwiYnV0dG9uIiwiQ29ubmVjdG9yTWF0ZXJpYWwiLCJHcmlkQ29ubmVjdG9yTWF0ZXJpYWwiLCJTaW1wbGVDb25uZWN0b3JNYXRlcmlhbCIsIkdSSURfU0laRSIsIlRPVEFMX0lOU1RBTkNFUyIsImdldEluc3RhbmNlSWQiLCJyb3ciLCJjb2wiLCJnZXRHcmlkQ29vcmRzIiwiaWQiLCJNYXRoIiwiZmxvb3IiLCJkdW1teSIsIk9iamVjdDNEIiwiQkFTRV9WQUxVRVMiLCJyYWRpdXNCIiwicmFkaXVzQSIsImJveFNpemUiLCJiYXNlU3BhY2luZyIsIlNjZW5lIiwiZ3JpZFNwYWNpbmciLCJ6b29tIiwiZGVidWciLCJzaG93U2ltcGxlIiwidmFsdWUiLCJtaW4iLCJtYXgiLCJzdGVwIiwibGFiZWwiLCJzY2FsZUZhY3RvciIsInNjYWxlZFJhZGl1c0IiLCJ0b0ZpeGVkIiwic2NhbGVkUmFkaXVzQSIsInNjYWxlZEJveFNpemUiLCJpbm5lclJhZGl1cyIsImRpc2FibGVkIiwib3V0ZXJSYWRpdXMiLCJncmlkU3RhdGUiLCJzZXRHcmlkU3RhdGUiLCJzaG93SW5uZXIiLCJzaG93T3V0ZXIiLCJhY3RpdmVDb25uZWN0b3IiLCJzZXRBY3RpdmVDb25uZWN0b3IiLCJtYXRlcmlhbFJlZiIsImluc3RhbmNlZE1lc2hSZWYiLCJncmlkSGVscGVyUmVmIiwiY2FtZXJhUmVmIiwiZ3JpZENvbm5lY3Rvck1hdGVyaWFsUmVmIiwiY29ubmVjdG9yTWVzaFJlZiIsImRlYnVnTWVzaFJlZiIsInNpbXBsZUNvbm5lY3Rvck1hdGVyaWFsUmVmIiwic2ltcGxlQ29ubmVjdG9yTWVzaFJlZiIsImluc3RhbmNlU2hvd0lubmVyIiwiRmxvYXQzMkFycmF5IiwiaW5zdGFuY2VTaG93T3V0ZXIiLCJpbnN0YW5jZVBvc2l0aW9ucyIsIkFycmF5IiwiZmlsbCIsIm1hcCIsIlZlY3RvcjMiLCJjYW1lcmEiLCJyYXljYXN0ZXIiLCJtb3VzZSIsImNvbnNvbGUiLCJsb2ciLCJncmlkU3RhdGVUZXh0dXJlIiwiZGF0YSIsInRleHR1cmUiLCJEYXRhVGV4dHVyZSIsIlJHQkFGb3JtYXQiLCJGbG9hdFR5cGUiLCJuZWVkc1VwZGF0ZSIsImltYWdlIiwiaWR4IiwiY3VycmVudCIsInVuaWZvcm1zIiwidV9yYWRpdXNCIiwidV9yYWRpdXNBIiwidV9zcGFjaW5nIiwidV9ncmlkU3RhdGUiLCJ1X2FjdGl2ZUNvbm5lY3RvciIsInVfdGhpY2tuZXNzIiwidV9jdXJ2YXR1cmUiLCJ1X2JveFNpemUiLCJ1cGRhdGVQcm9qZWN0aW9uTWF0cml4IiwiaW5zdGFuY2VJZCIsInN0YXJ0T2Zmc2V0IiwieCIsInkiLCJwb3NpdGlvbiIsInNldCIsInVwZGF0ZU1hdHJpeCIsInNldE1hdHJpeEF0IiwibWF0cml4IiwiZ2VvbWV0cnkiLCJhdHRyaWJ1dGVzIiwiYV9pbnN0YW5jZVNob3dJbm5lciIsImFfaW5zdGFuY2VTaG93T3V0ZXIiLCJpbnN0YW5jZU1hdHJpeCIsInNjYWxlIiwiaGFuZGxlQ2xpY2siLCJldmVudCIsImdyaWRPZmZzZXQiLCJjZW50ZXJBIiwiVmVjdG9yMiIsImNlbnRlckIiLCJjZW50ZXJDIiwiY2VudGVyRCIsImNsaWNrUG9pbnQiLCJwb2ludCIsImlzSW5BQkNvbm5lY3RvckFyZWEiLCJpc1BvaW50SW5Db25uZWN0b3JBcmVhIiwiaXNJbkNEQ29ubmVjdG9yQXJlYSIsInByZXZTdGF0ZSIsInVuZGVmaW5lZCIsImN1cnJlbnRTdGF0ZSIsImluc3RhbmNlUG9zaXRpb24iLCJwb2ludENvcHkiLCJjbG9uZSIsImRpc3RGcm9tQ2VudGVyIiwiZGlzdGFuY2VUbyIsIm5ld0lubmVyIiwibmV3T3V0ZXIiLCJuZXdTdGF0ZSIsIkpTT04iLCJwYXJzZSIsInN0cmluZ2lmeSIsImNlbnRlcjEiLCJjZW50ZXIyIiwiZGlzdFRvQ2VudGVyMSIsImRpc3RUb0NlbnRlcjIiLCJkaXJlY3Rpb24iLCJzdWJWZWN0b3JzIiwibm9ybWFsaXplIiwiY2VudGVyMVRvUG9pbnQiLCJwcm9qZWN0aW9uTGVuZ3RoIiwiZG90IiwiZGlzdGFuY2VCZXR3ZWVuQ2VudGVycyIsInByb2plY3RlZFBvaW50IiwiY29weSIsImFkZFNjYWxlZFZlY3RvciIsInBlcnBEaXN0YW5jZSIsImNvbm5lY3RvcldpZHRoIiwiY29ubmVjdG9yUGxhbmVTaXplIiwibWVzaCIsInJlZiIsInBsYW5lR2VvbWV0cnkiLCJhcmdzIiwibWVzaEJhc2ljTWF0ZXJpYWwiLCJjb2xvciIsIm9wYWNpdHkiLCJ0cmFuc3BhcmVudCIsInZpc2libGUiLCJzaW1wbGVDb25uZWN0b3JNYXRlcmlhbCIsImRlcHRoVGVzdCIsImtleSIsImdyaWRDb25uZWN0b3JNYXRlcmlhbCIsImluc3RhbmNlZE1lc2giLCJvbkNsaWNrIiwiaW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlIiwiYXR0YWNoIiwiY29ubmVjdG9yTWF0ZXJpYWwiLCJncm91cCIsImdyaWRIZWxwZXIiLCJyb3RhdGlvbiIsIlBJIiwiV2ViR0xDYW52YXMiLCJzdHlsZSIsImJhY2tncm91bmQiLCJtYWtlRGVmYXVsdCIsImFtYmllbnRMaWdodCIsImludGVuc2l0eSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./components/WebGLCanvas.js\n");

/***/ })

};
;