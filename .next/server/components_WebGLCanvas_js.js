"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "components_WebGLCanvas_js";
exports.ids = ["components_WebGLCanvas_js"];
exports.modules = {

/***/ "./components/ConnectorMaterial.js":
/*!*****************************************!*\
  !*** ./components/ConnectorMaterial.js ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConnectorMaterial: () => (/* binding */ ConnectorMaterial)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-three/drei */ \"@react-three/drei\");\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_react_three_drei__WEBPACK_IMPORTED_MODULE_1__);\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([three__WEBPACK_IMPORTED_MODULE_0__]);\nthree__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n// Define uniforms and shader code\n// Adapted for InstancedMesh with matrix-based positioning\nconst ConnectorMaterial = (0,_react_three_drei__WEBPACK_IMPORTED_MODULE_1__.shaderMaterial)(// Uniforms (global settings)\n{\n    u_radiusB: 0.4,\n    u_radiusA: 0.5,\n    u_spacing: 1.5,\n    u_resolution: new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(1, 1)\n}, // Vertex Shader - Pass instance visibility and world center\n/*glsl*/ `\n    // Instance attributes\n    attribute float a_instanceShowInner;\n    attribute float a_instanceShowOuter;\n\n    // Varyings to pass data to fragment shader\n    varying vec2 vUv;\n    varying vec2 vWorldPos;\n    varying vec2 vInstanceCenterWorld; // Pass instance center in world space\n    varying float v_showInner;\n    varying float v_showOuter;\n\n    void main() {\n      vUv = uv;\n      v_showInner = a_instanceShowInner;\n      v_showOuter = a_instanceShowOuter;\n\n      // World position of the vertex\n      vec4 worldPos = instanceMatrix * vec4(position, 1.0);\n      vWorldPos = worldPos.xy;\n      \n      // World position of the instance center (origin of the instance's local space)\n      vec4 instanceCenterWorld = instanceMatrix * vec4(0.0, 0.0, 0.0, 1.0);\n      vInstanceCenterWorld = instanceCenterWorld.xy;\n      \n      gl_Position = projectionMatrix * modelViewMatrix * worldPos;\n    }\n  `, // Fragment Shader - Use instance visibility and world center\n/*glsl*/ `\n    varying vec2 vUv;\n    varying vec2 vWorldPos;\n    varying vec2 vInstanceCenterWorld;\n    varying float v_showInner;\n    varying float v_showOuter;\n\n    uniform float u_radiusB; // Inner circle radius\n    uniform float u_radiusA; // Outer circle radius\n    uniform float u_spacing;\n    uniform vec2 u_resolution;\n\n    void main() {\n      // Calculate distance from pixel's world position to the instance's world center\n      float dist = length(vWorldPos - vInstanceCenterWorld);\n      \n      // Signed distance field for inner circle (radiusB)\n      float innerCircleSDF = dist - u_radiusB;\n      \n      // Signed distance field for outer circle (radiusA)\n      float outerCircleSDF = dist - u_radiusA;\n      \n      // Edge width for anti-aliasing\n      float edgeWidth = 0.01;\n      \n      // Line width for outlines\n      float lineWidth = 0.01;\n      \n      // Inner circle - use v_showInner (attribute)\n      float innerAlpha = 0.0;\n      bool isInnerVisible = v_showInner > 0.5;\n      if (isInnerVisible) {\n        // Full circle\n        innerAlpha = 1.0 - smoothstep(-edgeWidth, edgeWidth, innerCircleSDF);\n      } else {\n        // Just an outline\n        innerAlpha = (1.0 - smoothstep(-lineWidth/2.0, lineWidth/2.0, abs(innerCircleSDF) - lineWidth/2.0)) * 0.8;\n      }\n      \n      // Outer circle - use v_showOuter (attribute)\n      float ringAlpha = 0.0;\n      bool isOuterVisible = v_showOuter > 0.5;\n      if (isOuterVisible) {\n        // Full outer ring\n        float insideOuter = 1.0 - smoothstep(-edgeWidth, edgeWidth, outerCircleSDF);\n        // Subtract inner part IF BOTH inner and outer are visible\n        float innerMask = (isInnerVisible && isOuterVisible) ? (1.0 - smoothstep(-edgeWidth, edgeWidth, innerCircleSDF)) : 0.0;\n        ringAlpha = max(0.0, insideOuter - innerMask);\n      } else {\n        // Just an outline for the outer circle\n        ringAlpha = (1.0 - smoothstep(-lineWidth/2.0, lineWidth/2.0, abs(outerCircleSDF) - lineWidth/2.0)) * 0.8;\n      }\n      \n      // Combine both shapes\n      float finalAlpha = max(innerAlpha, ringAlpha * 0.7);\n      \n      // If nearly transparent, discard the pixel\n      if (finalAlpha < 0.01) discard;\n      \n      // Create different colors based on instance visibility\n      vec3 innerColor = isInnerVisible ? vec3(0.0) : vec3(0.3); // Black when on, gray when outline\n      vec3 ringColor = isOuterVisible ? vec3(0.3) : vec3(0.5);  // Dark gray when on, lighter gray when outline\n      \n      // Determine final color\n      vec3 color = vec3(1.0); // Default white (shouldn't be visible)\n      if(abs(innerCircleSDF) < lineWidth / 2.0 + edgeWidth && !isInnerVisible) {\n        color = innerColor; // Inner outline\n      } else if (abs(outerCircleSDF) < lineWidth / 2.0 + edgeWidth && !isOuterVisible) {\n         color = ringColor; // Outer outline\n      } else if (innerCircleSDF < 0.0 && isInnerVisible) {\n        color = innerColor; // Inner fill\n      } else if (outerCircleSDF < 0.0 && isOuterVisible) {\n        color = ringColor; // Outer ring fill\n      }\n\n      // Output with calculated alpha\n      gl_FragColor = vec4(color, finalAlpha);\n    }\n  `);\n// Add a unique key for HMR purposes with R3F\nConnectorMaterial.key = three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.generateUUID();\n\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL0Nvbm5lY3Rvck1hdGVyaWFsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBK0I7QUFDb0I7QUFFbkQsa0NBQWtDO0FBQ2xDLDBEQUEwRDtBQUUxRCxNQUFNRSxvQkFBb0JELGlFQUFjQSxDQUN0Qyw2QkFBNkI7QUFDN0I7SUFDRUUsV0FBVztJQUNYQyxXQUFXO0lBQ1hDLFdBQVc7SUFDWEMsY0FBYyxJQUFJTiwwQ0FBYSxDQUFDLEdBQUc7QUFDckMsR0FDQSw0REFBNEQ7QUFDNUQsTUFBTSxHQUFFLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQTJCVCxDQUFDLEVBQ0QsNkRBQTZEO0FBQzdELE1BQU0sR0FBRSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUE4RVQsQ0FBQztBQUdILDZDQUE2QztBQUM3Q0Usa0JBQWtCTSxHQUFHLEdBQUdSLDRDQUFlLENBQUNVLFlBQVk7QUFFdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWJnbC1kb3QtZ3JpZC1tdnAvLi9jb21wb25lbnRzL0Nvbm5lY3Rvck1hdGVyaWFsLmpzPzQxNDIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgc2hhZGVyTWF0ZXJpYWwgfSBmcm9tICdAcmVhY3QtdGhyZWUvZHJlaSc7XG5cbi8vIERlZmluZSB1bmlmb3JtcyBhbmQgc2hhZGVyIGNvZGVcbi8vIEFkYXB0ZWQgZm9yIEluc3RhbmNlZE1lc2ggd2l0aCBtYXRyaXgtYmFzZWQgcG9zaXRpb25pbmdcblxuY29uc3QgQ29ubmVjdG9yTWF0ZXJpYWwgPSBzaGFkZXJNYXRlcmlhbChcbiAgLy8gVW5pZm9ybXMgKGdsb2JhbCBzZXR0aW5ncylcbiAge1xuICAgIHVfcmFkaXVzQjogMC40LCAvLyBJbm5lciBjaXJjbGUgcmFkaXVzXG4gICAgdV9yYWRpdXNBOiAwLjUsIC8vIE91dGVyIGNpcmNsZSByYWRpdXNcbiAgICB1X3NwYWNpbmc6IDEuNSxcbiAgICB1X3Jlc29sdXRpb246IG5ldyBUSFJFRS5WZWN0b3IyKDEsIDEpLFxuICB9LFxuICAvLyBWZXJ0ZXggU2hhZGVyIC0gUGFzcyBpbnN0YW5jZSB2aXNpYmlsaXR5IGFuZCB3b3JsZCBjZW50ZXJcbiAgLypnbHNsKi9gXG4gICAgLy8gSW5zdGFuY2UgYXR0cmlidXRlc1xuICAgIGF0dHJpYnV0ZSBmbG9hdCBhX2luc3RhbmNlU2hvd0lubmVyO1xuICAgIGF0dHJpYnV0ZSBmbG9hdCBhX2luc3RhbmNlU2hvd091dGVyO1xuXG4gICAgLy8gVmFyeWluZ3MgdG8gcGFzcyBkYXRhIHRvIGZyYWdtZW50IHNoYWRlclxuICAgIHZhcnlpbmcgdmVjMiB2VXY7XG4gICAgdmFyeWluZyB2ZWMyIHZXb3JsZFBvcztcbiAgICB2YXJ5aW5nIHZlYzIgdkluc3RhbmNlQ2VudGVyV29ybGQ7IC8vIFBhc3MgaW5zdGFuY2UgY2VudGVyIGluIHdvcmxkIHNwYWNlXG4gICAgdmFyeWluZyBmbG9hdCB2X3Nob3dJbm5lcjtcbiAgICB2YXJ5aW5nIGZsb2F0IHZfc2hvd091dGVyO1xuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgdlV2ID0gdXY7XG4gICAgICB2X3Nob3dJbm5lciA9IGFfaW5zdGFuY2VTaG93SW5uZXI7XG4gICAgICB2X3Nob3dPdXRlciA9IGFfaW5zdGFuY2VTaG93T3V0ZXI7XG5cbiAgICAgIC8vIFdvcmxkIHBvc2l0aW9uIG9mIHRoZSB2ZXJ0ZXhcbiAgICAgIHZlYzQgd29ybGRQb3MgPSBpbnN0YW5jZU1hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XG4gICAgICB2V29ybGRQb3MgPSB3b3JsZFBvcy54eTtcbiAgICAgIFxuICAgICAgLy8gV29ybGQgcG9zaXRpb24gb2YgdGhlIGluc3RhbmNlIGNlbnRlciAob3JpZ2luIG9mIHRoZSBpbnN0YW5jZSdzIGxvY2FsIHNwYWNlKVxuICAgICAgdmVjNCBpbnN0YW5jZUNlbnRlcldvcmxkID0gaW5zdGFuY2VNYXRyaXggKiB2ZWM0KDAuMCwgMC4wLCAwLjAsIDEuMCk7XG4gICAgICB2SW5zdGFuY2VDZW50ZXJXb3JsZCA9IGluc3RhbmNlQ2VudGVyV29ybGQueHk7XG4gICAgICBcbiAgICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHdvcmxkUG9zO1xuICAgIH1cbiAgYCxcbiAgLy8gRnJhZ21lbnQgU2hhZGVyIC0gVXNlIGluc3RhbmNlIHZpc2liaWxpdHkgYW5kIHdvcmxkIGNlbnRlclxuICAvKmdsc2wqL2BcbiAgICB2YXJ5aW5nIHZlYzIgdlV2O1xuICAgIHZhcnlpbmcgdmVjMiB2V29ybGRQb3M7XG4gICAgdmFyeWluZyB2ZWMyIHZJbnN0YW5jZUNlbnRlcldvcmxkO1xuICAgIHZhcnlpbmcgZmxvYXQgdl9zaG93SW5uZXI7XG4gICAgdmFyeWluZyBmbG9hdCB2X3Nob3dPdXRlcjtcblxuICAgIHVuaWZvcm0gZmxvYXQgdV9yYWRpdXNCOyAvLyBJbm5lciBjaXJjbGUgcmFkaXVzXG4gICAgdW5pZm9ybSBmbG9hdCB1X3JhZGl1c0E7IC8vIE91dGVyIGNpcmNsZSByYWRpdXNcbiAgICB1bmlmb3JtIGZsb2F0IHVfc3BhY2luZztcbiAgICB1bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uO1xuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgLy8gQ2FsY3VsYXRlIGRpc3RhbmNlIGZyb20gcGl4ZWwncyB3b3JsZCBwb3NpdGlvbiB0byB0aGUgaW5zdGFuY2UncyB3b3JsZCBjZW50ZXJcbiAgICAgIGZsb2F0IGRpc3QgPSBsZW5ndGgodldvcmxkUG9zIC0gdkluc3RhbmNlQ2VudGVyV29ybGQpO1xuICAgICAgXG4gICAgICAvLyBTaWduZWQgZGlzdGFuY2UgZmllbGQgZm9yIGlubmVyIGNpcmNsZSAocmFkaXVzQilcbiAgICAgIGZsb2F0IGlubmVyQ2lyY2xlU0RGID0gZGlzdCAtIHVfcmFkaXVzQjtcbiAgICAgIFxuICAgICAgLy8gU2lnbmVkIGRpc3RhbmNlIGZpZWxkIGZvciBvdXRlciBjaXJjbGUgKHJhZGl1c0EpXG4gICAgICBmbG9hdCBvdXRlckNpcmNsZVNERiA9IGRpc3QgLSB1X3JhZGl1c0E7XG4gICAgICBcbiAgICAgIC8vIEVkZ2Ugd2lkdGggZm9yIGFudGktYWxpYXNpbmdcbiAgICAgIGZsb2F0IGVkZ2VXaWR0aCA9IDAuMDE7XG4gICAgICBcbiAgICAgIC8vIExpbmUgd2lkdGggZm9yIG91dGxpbmVzXG4gICAgICBmbG9hdCBsaW5lV2lkdGggPSAwLjAxO1xuICAgICAgXG4gICAgICAvLyBJbm5lciBjaXJjbGUgLSB1c2Ugdl9zaG93SW5uZXIgKGF0dHJpYnV0ZSlcbiAgICAgIGZsb2F0IGlubmVyQWxwaGEgPSAwLjA7XG4gICAgICBib29sIGlzSW5uZXJWaXNpYmxlID0gdl9zaG93SW5uZXIgPiAwLjU7XG4gICAgICBpZiAoaXNJbm5lclZpc2libGUpIHtcbiAgICAgICAgLy8gRnVsbCBjaXJjbGVcbiAgICAgICAgaW5uZXJBbHBoYSA9IDEuMCAtIHNtb290aHN0ZXAoLWVkZ2VXaWR0aCwgZWRnZVdpZHRoLCBpbm5lckNpcmNsZVNERik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBKdXN0IGFuIG91dGxpbmVcbiAgICAgICAgaW5uZXJBbHBoYSA9ICgxLjAgLSBzbW9vdGhzdGVwKC1saW5lV2lkdGgvMi4wLCBsaW5lV2lkdGgvMi4wLCBhYnMoaW5uZXJDaXJjbGVTREYpIC0gbGluZVdpZHRoLzIuMCkpICogMC44O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBPdXRlciBjaXJjbGUgLSB1c2Ugdl9zaG93T3V0ZXIgKGF0dHJpYnV0ZSlcbiAgICAgIGZsb2F0IHJpbmdBbHBoYSA9IDAuMDtcbiAgICAgIGJvb2wgaXNPdXRlclZpc2libGUgPSB2X3Nob3dPdXRlciA+IDAuNTtcbiAgICAgIGlmIChpc091dGVyVmlzaWJsZSkge1xuICAgICAgICAvLyBGdWxsIG91dGVyIHJpbmdcbiAgICAgICAgZmxvYXQgaW5zaWRlT3V0ZXIgPSAxLjAgLSBzbW9vdGhzdGVwKC1lZGdlV2lkdGgsIGVkZ2VXaWR0aCwgb3V0ZXJDaXJjbGVTREYpO1xuICAgICAgICAvLyBTdWJ0cmFjdCBpbm5lciBwYXJ0IElGIEJPVEggaW5uZXIgYW5kIG91dGVyIGFyZSB2aXNpYmxlXG4gICAgICAgIGZsb2F0IGlubmVyTWFzayA9IChpc0lubmVyVmlzaWJsZSAmJiBpc091dGVyVmlzaWJsZSkgPyAoMS4wIC0gc21vb3Roc3RlcCgtZWRnZVdpZHRoLCBlZGdlV2lkdGgsIGlubmVyQ2lyY2xlU0RGKSkgOiAwLjA7XG4gICAgICAgIHJpbmdBbHBoYSA9IG1heCgwLjAsIGluc2lkZU91dGVyIC0gaW5uZXJNYXNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEp1c3QgYW4gb3V0bGluZSBmb3IgdGhlIG91dGVyIGNpcmNsZVxuICAgICAgICByaW5nQWxwaGEgPSAoMS4wIC0gc21vb3Roc3RlcCgtbGluZVdpZHRoLzIuMCwgbGluZVdpZHRoLzIuMCwgYWJzKG91dGVyQ2lyY2xlU0RGKSAtIGxpbmVXaWR0aC8yLjApKSAqIDAuODtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ29tYmluZSBib3RoIHNoYXBlc1xuICAgICAgZmxvYXQgZmluYWxBbHBoYSA9IG1heChpbm5lckFscGhhLCByaW5nQWxwaGEgKiAwLjcpO1xuICAgICAgXG4gICAgICAvLyBJZiBuZWFybHkgdHJhbnNwYXJlbnQsIGRpc2NhcmQgdGhlIHBpeGVsXG4gICAgICBpZiAoZmluYWxBbHBoYSA8IDAuMDEpIGRpc2NhcmQ7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBkaWZmZXJlbnQgY29sb3JzIGJhc2VkIG9uIGluc3RhbmNlIHZpc2liaWxpdHlcbiAgICAgIHZlYzMgaW5uZXJDb2xvciA9IGlzSW5uZXJWaXNpYmxlID8gdmVjMygwLjApIDogdmVjMygwLjMpOyAvLyBCbGFjayB3aGVuIG9uLCBncmF5IHdoZW4gb3V0bGluZVxuICAgICAgdmVjMyByaW5nQ29sb3IgPSBpc091dGVyVmlzaWJsZSA/IHZlYzMoMC4zKSA6IHZlYzMoMC41KTsgIC8vIERhcmsgZ3JheSB3aGVuIG9uLCBsaWdodGVyIGdyYXkgd2hlbiBvdXRsaW5lXG4gICAgICBcbiAgICAgIC8vIERldGVybWluZSBmaW5hbCBjb2xvclxuICAgICAgdmVjMyBjb2xvciA9IHZlYzMoMS4wKTsgLy8gRGVmYXVsdCB3aGl0ZSAoc2hvdWxkbid0IGJlIHZpc2libGUpXG4gICAgICBpZihhYnMoaW5uZXJDaXJjbGVTREYpIDwgbGluZVdpZHRoIC8gMi4wICsgZWRnZVdpZHRoICYmICFpc0lubmVyVmlzaWJsZSkge1xuICAgICAgICBjb2xvciA9IGlubmVyQ29sb3I7IC8vIElubmVyIG91dGxpbmVcbiAgICAgIH0gZWxzZSBpZiAoYWJzKG91dGVyQ2lyY2xlU0RGKSA8IGxpbmVXaWR0aCAvIDIuMCArIGVkZ2VXaWR0aCAmJiAhaXNPdXRlclZpc2libGUpIHtcbiAgICAgICAgIGNvbG9yID0gcmluZ0NvbG9yOyAvLyBPdXRlciBvdXRsaW5lXG4gICAgICB9IGVsc2UgaWYgKGlubmVyQ2lyY2xlU0RGIDwgMC4wICYmIGlzSW5uZXJWaXNpYmxlKSB7XG4gICAgICAgIGNvbG9yID0gaW5uZXJDb2xvcjsgLy8gSW5uZXIgZmlsbFxuICAgICAgfSBlbHNlIGlmIChvdXRlckNpcmNsZVNERiA8IDAuMCAmJiBpc091dGVyVmlzaWJsZSkge1xuICAgICAgICBjb2xvciA9IHJpbmdDb2xvcjsgLy8gT3V0ZXIgcmluZyBmaWxsXG4gICAgICB9XG5cbiAgICAgIC8vIE91dHB1dCB3aXRoIGNhbGN1bGF0ZWQgYWxwaGFcbiAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IsIGZpbmFsQWxwaGEpO1xuICAgIH1cbiAgYFxuKTtcblxuLy8gQWRkIGEgdW5pcXVlIGtleSBmb3IgSE1SIHB1cnBvc2VzIHdpdGggUjNGXG5Db25uZWN0b3JNYXRlcmlhbC5rZXkgPSBUSFJFRS5NYXRoVXRpbHMuZ2VuZXJhdGVVVUlEKCk7XG5cbmV4cG9ydCB7IENvbm5lY3Rvck1hdGVyaWFsIH07ICJdLCJuYW1lcyI6WyJUSFJFRSIsInNoYWRlck1hdGVyaWFsIiwiQ29ubmVjdG9yTWF0ZXJpYWwiLCJ1X3JhZGl1c0IiLCJ1X3JhZGl1c0EiLCJ1X3NwYWNpbmciLCJ1X3Jlc29sdXRpb24iLCJWZWN0b3IyIiwia2V5IiwiTWF0aFV0aWxzIiwiZ2VuZXJhdGVVVUlEIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./components/ConnectorMaterial.js\n");

/***/ }),

/***/ "./components/GridConnectorMaterial.js":
/*!*********************************************!*\
  !*** ./components/GridConnectorMaterial.js ***!
  \*********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GridConnectorMaterial: () => (/* binding */ GridConnectorMaterial)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-three/drei */ \"@react-three/drei\");\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_react_three_drei__WEBPACK_IMPORTED_MODULE_1__);\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([three__WEBPACK_IMPORTED_MODULE_0__]);\nthree__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n// This material handles the connector shapes between active points on the grid\nconst GridConnectorMaterial = (0,_react_three_drei__WEBPACK_IMPORTED_MODULE_1__.shaderMaterial)(// Uniforms\n{\n    u_radiusB: 0.4,\n    u_radiusA: 0.5,\n    u_spacing: 1.0,\n    u_thickness: 0.2,\n    u_curvature: 0.5,\n    u_resolution: new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(1, 1),\n    u_gridState: new three__WEBPACK_IMPORTED_MODULE_0__.DataTexture(new Float32Array(4), 2, 2, three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat, three__WEBPACK_IMPORTED_MODULE_0__.FloatType)\n}, // Vertex Shader\n/*glsl*/ `\n    varying vec2 vUv;\n    varying vec2 vWorldPos;\n\n    void main() {\n      vUv = uv;\n      \n      // World position of the vertex\n      vec4 worldPos = modelMatrix * vec4(position, 1.0);\n      vWorldPos = worldPos.xy;\n      \n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n  `, // Fragment Shader\n/*glsl*/ `\n    varying vec2 vUv;\n    varying vec2 vWorldPos;\n\n    uniform float u_radiusB; // Inner circle radius (black circle)\n    uniform float u_radiusA; // Outer circle radius (for connector shape)\n    uniform float u_spacing;\n    uniform float u_thickness; // Controls connector thickness\n    uniform float u_curvature; // Controls the curve shape\n    uniform vec2 u_resolution;\n    uniform sampler2D u_gridState;\n\n    // Helper function to get circle state from the grid state texture\n    vec4 getGridState(int row, int col) {\n      return texture2D(u_gridState, vec2(float(col) + 0.5, float(row) + 0.5) / 2.0);\n    }\n\n    // Helper function to calculate distance to a circle\n    float distToCircle(vec2 point, vec2 center) {\n      return length(point - center);\n    }\n\n    // Create a smooth minimum function to blend the connector\n    float smin(float a, float b, float k) {\n      float h = max(k - abs(a - b), 0.0) / k;\n      return min(a, b) - h * h * k * 0.25;\n    }\n\n    void main() {\n      // Calculate grid positions (2x2 grid)\n      float gridOffset = u_spacing * 0.5;\n      vec2 center_A = vec2(-gridOffset, gridOffset);   // Top-left (A)\n      vec2 center_B = vec2(gridOffset, -gridOffset);   // Bottom-right (B)\n      vec2 center_C = vec2(-gridOffset, -gridOffset);  // Bottom-left (C)\n      vec2 center_D = vec2(gridOffset, gridOffset);    // Top-right (D)\n\n      // Calculate distances from current pixel to each circle center\n      float dist_A = distToCircle(vWorldPos, center_A);\n      float dist_B = distToCircle(vWorldPos, center_B);\n      float dist_C = distToCircle(vWorldPos, center_C);\n      float dist_D = distToCircle(vWorldPos, center_D);\n\n      // Get circle states\n      vec4 stateA = getGridState(0, 0); // Top-left\n      vec4 stateB = getGridState(1, 1); // Bottom-right\n      vec4 stateC = getGridState(1, 0); // Bottom-left\n      vec4 stateD = getGridState(0, 1); // Top-right\n\n      // Check if relevant circles are active \n      bool circleAInnerActive = stateA.r > 0.5; // Top-left inner circle\n      bool circleBInnerActive = stateB.r > 0.5; // Bottom-right inner circle\n      // Add checks for the other diagonal\n      bool circleCInnerActive = stateC.r > 0.5; // Bottom-left inner circle\n      bool circleDInnerActive = stateD.r > 0.5; // Top-right inner circle\n      \n      // Check if either diagonal pair of inner circles is active\n      bool diagonalABActive = circleAInnerActive && circleBInnerActive;\n      bool diagonalCDActive = circleCInnerActive && circleDInnerActive;\n      \n      // If neither diagonal is active, discard\n      if (!diagonalABActive && !diagonalCDActive) {\n        discard;\n        return;\n      }\n      \n      // Determine which connector to draw\n      bool drawABConnector = diagonalABActive;\n      bool drawCDConnector = diagonalCDActive;\n      \n      // Distance fields for the inner black circles\n      float sdfA = dist_A - u_radiusB;\n      float sdfB = dist_B - u_radiusB;\n      float sdfC = dist_C - u_radiusB;\n      float sdfD = dist_D - u_radiusB;\n      \n      // We only continue if we're outside the relevant black circles\n      bool outsideRelevantCircles = true;\n      \n      if (drawABConnector) {\n        outsideRelevantCircles = (sdfA > 0.0) && (sdfB > 0.0);\n      }\n      \n      if (drawCDConnector) {\n        outsideRelevantCircles = (sdfC > 0.0) && (sdfD > 0.0);\n      }\n      \n      if (!outsideRelevantCircles) {\n        discard;\n        return;\n      }\n      \n      // Check if inside influence areas\n      bool insideInfluenceArea = false;\n      \n      if (drawABConnector) {\n        // For Red AB connector:\n        // Must be outside inner B circles (we already checked this with outsideRelevantCircles)\n        // Must be outside outer A circles (represented by the gray circles)\n        // Notice how we're checking if we're outside both outer A circles (C and D)\n        insideInfluenceArea = (dist_C > u_radiusA) && (dist_D > u_radiusA);\n      }\n      \n      if (drawCDConnector) {\n        // For Blue CD connector:\n        // Must be outside inner A circles (we already checked this with outsideRelevantCircles)\n        // Must be outside outer B circles (represented by the gray circles)\n        // Notice how we're checking if we're outside both outer B circles (A and B)\n        insideInfluenceArea = (dist_A > u_radiusA) && (dist_B > u_radiusA);\n      }\n      \n      if (!insideInfluenceArea) {\n        discard;\n        return;\n      }\n      \n      // Calculate vector between the active circles\n      vec2 activeDirection;\n      vec2 startCenter;\n      vec2 endCenter;\n      float distStart;\n      float distEnd;\n      \n      if (drawABConnector) {\n        activeDirection = center_B - center_A;\n        startCenter = center_A;\n        endCenter = center_B;\n        distStart = dist_A;\n        distEnd = dist_B;\n      }\n      \n      if (drawCDConnector) {\n        activeDirection = center_D - center_C;\n        startCenter = center_C;\n        endCenter = center_D;\n        distStart = dist_C;\n        distEnd = dist_D;\n      }\n      \n      // Continue with existing connector logic, but use the active centers\n      float lengthAB = length(activeDirection);\n      vec2 AB_normalized = activeDirection / lengthAB;\n      \n      // Project current point onto line\n      vec2 AP = vWorldPos - startCenter;\n      float projection = dot(AP, AB_normalized);\n      \n      // Create a field that represents the \"pathway\" between the two circles\n      // This creates a curved shape that narrows in the middle\n      float pathwayField;\n      \n      // For the first part of the curvature range, use distance-based shape\n      if (u_curvature < 0.5) {\n        // Method 1: Path with varying width based on projection along AB\n        \n        // Only proceed if the pixel is reasonably near the AB line\n        if (projection >= -u_radiusA && projection <= lengthAB + u_radiusA) {\n          // Calculate perpendicular distance from point to AB line\n          vec2 perpendicular = AP - projection * AB_normalized;\n          float perpDistance = length(perpendicular);\n          \n          // Base width based on thickness\n          float baseWidth = u_thickness * u_radiusA;\n          float midPoint = lengthAB * 0.5;\n          float distFromMid = abs(projection - midPoint);\n          \n          // Make narrower in middle based on curvature\n          float t = distFromMid / midPoint; // 0 at center, 1 at endpoints\n          float narrowingFactor = mix(0.5, 0.9, u_curvature * 2.0); // More narrow at higher curvature\n          float widthCurve = 1.0 - pow(t, 1.5) * narrowingFactor;\n          \n          // Calculate the adjusted width based on position\n          float adjustedWidth;\n          \n          if (projection < 0.0) {\n            // Near endpoint A - blend with circle\n            adjustedWidth = mix(u_radiusA * 0.8, baseWidth, 1.0 + projection / u_radiusA);\n          } else if (projection > lengthAB) {\n            // Near endpoint B - blend with circle\n            adjustedWidth = mix(u_radiusA * 0.8, baseWidth, 1.0 - (projection - lengthAB) / u_radiusA);\n          } else {\n            // Between endpoints - use curved width\n            adjustedWidth = baseWidth * widthCurve;\n          }\n          \n          // If within the adjusted width, we're in the connector\n          if (perpDistance < adjustedWidth) {\n            // Set color based on which connector is being drawn\n            if (drawABConnector) {\n              gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); // Red for AB connector\n            } else {\n              gl_FragColor = vec4(0.0, 0.5, 1.0, 1.0); // Blue for CD connector\n            }\n            return;\n          }\n        }\n      }\n      else {\n        // Method 2: Use hyperbolic distance field for higher curvature\n        // Normalize distances for better control\n        float d1 = max(0.0, distStart - u_radiusB) / u_radiusA; \n        float d2 = max(0.0, distEnd - u_radiusB) / u_radiusA;\n        \n        // Create hyperbolic field (product of distances)\n        pathwayField = d1 * d2;\n        \n        // Adjust field strength based on distance to make shape more compact\n        float distanceScale = 3.0 / lengthAB;\n        pathwayField *= distanceScale;\n        \n        // Thickness controls the threshold\n        float threshold = u_thickness * 0.2 * mix(1.0, 2.0, u_curvature - 0.5);\n        \n        // Check if within the field threshold\n        if (pathwayField < threshold) {\n          // Only show connector between the circles (not extending out the other sides)\n          float dotProductA = dot(AP, AB_normalized);\n          float dotProductB = dot(vWorldPos - endCenter, -AB_normalized);\n          \n          if (dotProductA >= -u_radiusB * 0.5 && dotProductB >= -u_radiusB * 0.5) {\n            // Set color based on which connector is being drawn\n            if (drawABConnector) {\n              gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); // Red for AB connector\n            } else {\n              gl_FragColor = vec4(0.0, 0.5, 1.0, 1.0); // Blue for CD connector\n            }\n            return;\n          }\n        }\n      }\n      \n      // If we got here, the pixel is outside the connector shape\n      discard;\n    }\n  `);\n// Add a unique key for HMR purposes with R3F\nGridConnectorMaterial.key = three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.generateUUID();\n\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL0dyaWRDb25uZWN0b3JNYXRlcmlhbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQStCO0FBQ29CO0FBRW5ELCtFQUErRTtBQUMvRSxNQUFNRSx3QkFBd0JELGlFQUFjQSxDQUMxQyxXQUFXO0FBQ1g7SUFDRUUsV0FBVztJQUNYQyxXQUFXO0lBQ1hDLFdBQVc7SUFDWEMsYUFBYTtJQUNiQyxhQUFhO0lBQ2JDLGNBQWMsSUFBSVIsMENBQWEsQ0FBQyxHQUFHO0lBQ25DVSxhQUFhLElBQUlWLDhDQUFpQixDQUNoQyxJQUFJWSxhQUFhLElBQ2pCLEdBQ0EsR0FDQVosNkNBQWdCLEVBQ2hCQSw0Q0FBZTtBQUVuQixHQUNBLGdCQUFnQjtBQUNoQixNQUFNLEdBQUUsQ0FBQzs7Ozs7Ozs7Ozs7OztFQWFULENBQUMsRUFDRCxrQkFBa0I7QUFDbEIsTUFBTSxHQUFFLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBeU9ULENBQUM7QUFHSCw2Q0FBNkM7QUFDN0NFLHNCQUFzQmEsR0FBRyxHQUFHZiw0Q0FBZSxDQUFDaUIsWUFBWTtBQUV2QiIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYmdsLWRvdC1ncmlkLW12cC8uL2NvbXBvbmVudHMvR3JpZENvbm5lY3Rvck1hdGVyaWFsLmpzP2IyMWQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgc2hhZGVyTWF0ZXJpYWwgfSBmcm9tICdAcmVhY3QtdGhyZWUvZHJlaSc7XG5cbi8vIFRoaXMgbWF0ZXJpYWwgaGFuZGxlcyB0aGUgY29ubmVjdG9yIHNoYXBlcyBiZXR3ZWVuIGFjdGl2ZSBwb2ludHMgb24gdGhlIGdyaWRcbmNvbnN0IEdyaWRDb25uZWN0b3JNYXRlcmlhbCA9IHNoYWRlck1hdGVyaWFsKFxuICAvLyBVbmlmb3Jtc1xuICB7XG4gICAgdV9yYWRpdXNCOiAwLjQsIC8vIElubmVyIGNpcmNsZSByYWRpdXMgKGJsYWNrIGNpcmNsZSlcbiAgICB1X3JhZGl1c0E6IDAuNSwgLy8gT3V0ZXIgY2lyY2xlIHJhZGl1cyAoZm9yIGNvbm5lY3RvciBzaGFwZSBjYWxjdWxhdGlvbilcbiAgICB1X3NwYWNpbmc6IDEuMCwgLy8gR3JpZCBzcGFjaW5nXG4gICAgdV90aGlja25lc3M6IDAuMiwgLy8gQ29ubmVjdG9yIHRoaWNrbmVzcyBjb250cm9sXG4gICAgdV9jdXJ2YXR1cmU6IDAuNSwgLy8gQ29udHJvbHMgdGhlIGN1cnZhdHVyZSBvZiB0aGUgY29ubmVjdG9yXG4gICAgdV9yZXNvbHV0aW9uOiBuZXcgVEhSRUUuVmVjdG9yMigxLCAxKSxcbiAgICB1X2dyaWRTdGF0ZTogbmV3IFRIUkVFLkRhdGFUZXh0dXJlKCAvLyBXaWxsIHN0b3JlIGdyaWQgc3RhdGUgaW4gYSB0ZXh0dXJlXG4gICAgICBuZXcgRmxvYXQzMkFycmF5KDQpLCAvLyBSR0JBIHZhbHVlcyBwZXIgY2VsbFxuICAgICAgMiwgLy8gd2lkdGggKGZvciAyeDIgZ3JpZClcbiAgICAgIDIsIC8vIGhlaWdodCAoZm9yIDJ4MiBncmlkKVxuICAgICAgVEhSRUUuUkdCQUZvcm1hdCxcbiAgICAgIFRIUkVFLkZsb2F0VHlwZVxuICAgICksXG4gIH0sXG4gIC8vIFZlcnRleCBTaGFkZXJcbiAgLypnbHNsKi9gXG4gICAgdmFyeWluZyB2ZWMyIHZVdjtcbiAgICB2YXJ5aW5nIHZlYzIgdldvcmxkUG9zO1xuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgdlV2ID0gdXY7XG4gICAgICBcbiAgICAgIC8vIFdvcmxkIHBvc2l0aW9uIG9mIHRoZSB2ZXJ0ZXhcbiAgICAgIHZlYzQgd29ybGRQb3MgPSBtb2RlbE1hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XG4gICAgICB2V29ybGRQb3MgPSB3b3JsZFBvcy54eTtcbiAgICAgIFxuICAgICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTtcbiAgICB9XG4gIGAsXG4gIC8vIEZyYWdtZW50IFNoYWRlclxuICAvKmdsc2wqL2BcbiAgICB2YXJ5aW5nIHZlYzIgdlV2O1xuICAgIHZhcnlpbmcgdmVjMiB2V29ybGRQb3M7XG5cbiAgICB1bmlmb3JtIGZsb2F0IHVfcmFkaXVzQjsgLy8gSW5uZXIgY2lyY2xlIHJhZGl1cyAoYmxhY2sgY2lyY2xlKVxuICAgIHVuaWZvcm0gZmxvYXQgdV9yYWRpdXNBOyAvLyBPdXRlciBjaXJjbGUgcmFkaXVzIChmb3IgY29ubmVjdG9yIHNoYXBlKVxuICAgIHVuaWZvcm0gZmxvYXQgdV9zcGFjaW5nO1xuICAgIHVuaWZvcm0gZmxvYXQgdV90aGlja25lc3M7IC8vIENvbnRyb2xzIGNvbm5lY3RvciB0aGlja25lc3NcbiAgICB1bmlmb3JtIGZsb2F0IHVfY3VydmF0dXJlOyAvLyBDb250cm9scyB0aGUgY3VydmUgc2hhcGVcbiAgICB1bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uO1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVfZ3JpZFN0YXRlO1xuXG4gICAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGdldCBjaXJjbGUgc3RhdGUgZnJvbSB0aGUgZ3JpZCBzdGF0ZSB0ZXh0dXJlXG4gICAgdmVjNCBnZXRHcmlkU3RhdGUoaW50IHJvdywgaW50IGNvbCkge1xuICAgICAgcmV0dXJuIHRleHR1cmUyRCh1X2dyaWRTdGF0ZSwgdmVjMihmbG9hdChjb2wpICsgMC41LCBmbG9hdChyb3cpICsgMC41KSAvIDIuMCk7XG4gICAgfVxuXG4gICAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNhbGN1bGF0ZSBkaXN0YW5jZSB0byBhIGNpcmNsZVxuICAgIGZsb2F0IGRpc3RUb0NpcmNsZSh2ZWMyIHBvaW50LCB2ZWMyIGNlbnRlcikge1xuICAgICAgcmV0dXJuIGxlbmd0aChwb2ludCAtIGNlbnRlcik7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGEgc21vb3RoIG1pbmltdW0gZnVuY3Rpb24gdG8gYmxlbmQgdGhlIGNvbm5lY3RvclxuICAgIGZsb2F0IHNtaW4oZmxvYXQgYSwgZmxvYXQgYiwgZmxvYXQgaykge1xuICAgICAgZmxvYXQgaCA9IG1heChrIC0gYWJzKGEgLSBiKSwgMC4wKSAvIGs7XG4gICAgICByZXR1cm4gbWluKGEsIGIpIC0gaCAqIGggKiBrICogMC4yNTtcbiAgICB9XG5cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICAvLyBDYWxjdWxhdGUgZ3JpZCBwb3NpdGlvbnMgKDJ4MiBncmlkKVxuICAgICAgZmxvYXQgZ3JpZE9mZnNldCA9IHVfc3BhY2luZyAqIDAuNTtcbiAgICAgIHZlYzIgY2VudGVyX0EgPSB2ZWMyKC1ncmlkT2Zmc2V0LCBncmlkT2Zmc2V0KTsgICAvLyBUb3AtbGVmdCAoQSlcbiAgICAgIHZlYzIgY2VudGVyX0IgPSB2ZWMyKGdyaWRPZmZzZXQsIC1ncmlkT2Zmc2V0KTsgICAvLyBCb3R0b20tcmlnaHQgKEIpXG4gICAgICB2ZWMyIGNlbnRlcl9DID0gdmVjMigtZ3JpZE9mZnNldCwgLWdyaWRPZmZzZXQpOyAgLy8gQm90dG9tLWxlZnQgKEMpXG4gICAgICB2ZWMyIGNlbnRlcl9EID0gdmVjMihncmlkT2Zmc2V0LCBncmlkT2Zmc2V0KTsgICAgLy8gVG9wLXJpZ2h0IChEKVxuXG4gICAgICAvLyBDYWxjdWxhdGUgZGlzdGFuY2VzIGZyb20gY3VycmVudCBwaXhlbCB0byBlYWNoIGNpcmNsZSBjZW50ZXJcbiAgICAgIGZsb2F0IGRpc3RfQSA9IGRpc3RUb0NpcmNsZSh2V29ybGRQb3MsIGNlbnRlcl9BKTtcbiAgICAgIGZsb2F0IGRpc3RfQiA9IGRpc3RUb0NpcmNsZSh2V29ybGRQb3MsIGNlbnRlcl9CKTtcbiAgICAgIGZsb2F0IGRpc3RfQyA9IGRpc3RUb0NpcmNsZSh2V29ybGRQb3MsIGNlbnRlcl9DKTtcbiAgICAgIGZsb2F0IGRpc3RfRCA9IGRpc3RUb0NpcmNsZSh2V29ybGRQb3MsIGNlbnRlcl9EKTtcblxuICAgICAgLy8gR2V0IGNpcmNsZSBzdGF0ZXNcbiAgICAgIHZlYzQgc3RhdGVBID0gZ2V0R3JpZFN0YXRlKDAsIDApOyAvLyBUb3AtbGVmdFxuICAgICAgdmVjNCBzdGF0ZUIgPSBnZXRHcmlkU3RhdGUoMSwgMSk7IC8vIEJvdHRvbS1yaWdodFxuICAgICAgdmVjNCBzdGF0ZUMgPSBnZXRHcmlkU3RhdGUoMSwgMCk7IC8vIEJvdHRvbS1sZWZ0XG4gICAgICB2ZWM0IHN0YXRlRCA9IGdldEdyaWRTdGF0ZSgwLCAxKTsgLy8gVG9wLXJpZ2h0XG5cbiAgICAgIC8vIENoZWNrIGlmIHJlbGV2YW50IGNpcmNsZXMgYXJlIGFjdGl2ZSBcbiAgICAgIGJvb2wgY2lyY2xlQUlubmVyQWN0aXZlID0gc3RhdGVBLnIgPiAwLjU7IC8vIFRvcC1sZWZ0IGlubmVyIGNpcmNsZVxuICAgICAgYm9vbCBjaXJjbGVCSW5uZXJBY3RpdmUgPSBzdGF0ZUIuciA+IDAuNTsgLy8gQm90dG9tLXJpZ2h0IGlubmVyIGNpcmNsZVxuICAgICAgLy8gQWRkIGNoZWNrcyBmb3IgdGhlIG90aGVyIGRpYWdvbmFsXG4gICAgICBib29sIGNpcmNsZUNJbm5lckFjdGl2ZSA9IHN0YXRlQy5yID4gMC41OyAvLyBCb3R0b20tbGVmdCBpbm5lciBjaXJjbGVcbiAgICAgIGJvb2wgY2lyY2xlRElubmVyQWN0aXZlID0gc3RhdGVELnIgPiAwLjU7IC8vIFRvcC1yaWdodCBpbm5lciBjaXJjbGVcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgZWl0aGVyIGRpYWdvbmFsIHBhaXIgb2YgaW5uZXIgY2lyY2xlcyBpcyBhY3RpdmVcbiAgICAgIGJvb2wgZGlhZ29uYWxBQkFjdGl2ZSA9IGNpcmNsZUFJbm5lckFjdGl2ZSAmJiBjaXJjbGVCSW5uZXJBY3RpdmU7XG4gICAgICBib29sIGRpYWdvbmFsQ0RBY3RpdmUgPSBjaXJjbGVDSW5uZXJBY3RpdmUgJiYgY2lyY2xlRElubmVyQWN0aXZlO1xuICAgICAgXG4gICAgICAvLyBJZiBuZWl0aGVyIGRpYWdvbmFsIGlzIGFjdGl2ZSwgZGlzY2FyZFxuICAgICAgaWYgKCFkaWFnb25hbEFCQWN0aXZlICYmICFkaWFnb25hbENEQWN0aXZlKSB7XG4gICAgICAgIGRpc2NhcmQ7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIGNvbm5lY3RvciB0byBkcmF3XG4gICAgICBib29sIGRyYXdBQkNvbm5lY3RvciA9IGRpYWdvbmFsQUJBY3RpdmU7XG4gICAgICBib29sIGRyYXdDRENvbm5lY3RvciA9IGRpYWdvbmFsQ0RBY3RpdmU7XG4gICAgICBcbiAgICAgIC8vIERpc3RhbmNlIGZpZWxkcyBmb3IgdGhlIGlubmVyIGJsYWNrIGNpcmNsZXNcbiAgICAgIGZsb2F0IHNkZkEgPSBkaXN0X0EgLSB1X3JhZGl1c0I7XG4gICAgICBmbG9hdCBzZGZCID0gZGlzdF9CIC0gdV9yYWRpdXNCO1xuICAgICAgZmxvYXQgc2RmQyA9IGRpc3RfQyAtIHVfcmFkaXVzQjtcbiAgICAgIGZsb2F0IHNkZkQgPSBkaXN0X0QgLSB1X3JhZGl1c0I7XG4gICAgICBcbiAgICAgIC8vIFdlIG9ubHkgY29udGludWUgaWYgd2UncmUgb3V0c2lkZSB0aGUgcmVsZXZhbnQgYmxhY2sgY2lyY2xlc1xuICAgICAgYm9vbCBvdXRzaWRlUmVsZXZhbnRDaXJjbGVzID0gdHJ1ZTtcbiAgICAgIFxuICAgICAgaWYgKGRyYXdBQkNvbm5lY3Rvcikge1xuICAgICAgICBvdXRzaWRlUmVsZXZhbnRDaXJjbGVzID0gKHNkZkEgPiAwLjApICYmIChzZGZCID4gMC4wKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKGRyYXdDRENvbm5lY3Rvcikge1xuICAgICAgICBvdXRzaWRlUmVsZXZhbnRDaXJjbGVzID0gKHNkZkMgPiAwLjApICYmIChzZGZEID4gMC4wKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKCFvdXRzaWRlUmVsZXZhbnRDaXJjbGVzKSB7XG4gICAgICAgIGRpc2NhcmQ7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgaW5zaWRlIGluZmx1ZW5jZSBhcmVhc1xuICAgICAgYm9vbCBpbnNpZGVJbmZsdWVuY2VBcmVhID0gZmFsc2U7XG4gICAgICBcbiAgICAgIGlmIChkcmF3QUJDb25uZWN0b3IpIHtcbiAgICAgICAgLy8gRm9yIFJlZCBBQiBjb25uZWN0b3I6XG4gICAgICAgIC8vIE11c3QgYmUgb3V0c2lkZSBpbm5lciBCIGNpcmNsZXMgKHdlIGFscmVhZHkgY2hlY2tlZCB0aGlzIHdpdGggb3V0c2lkZVJlbGV2YW50Q2lyY2xlcylcbiAgICAgICAgLy8gTXVzdCBiZSBvdXRzaWRlIG91dGVyIEEgY2lyY2xlcyAocmVwcmVzZW50ZWQgYnkgdGhlIGdyYXkgY2lyY2xlcylcbiAgICAgICAgLy8gTm90aWNlIGhvdyB3ZSdyZSBjaGVja2luZyBpZiB3ZSdyZSBvdXRzaWRlIGJvdGggb3V0ZXIgQSBjaXJjbGVzIChDIGFuZCBEKVxuICAgICAgICBpbnNpZGVJbmZsdWVuY2VBcmVhID0gKGRpc3RfQyA+IHVfcmFkaXVzQSkgJiYgKGRpc3RfRCA+IHVfcmFkaXVzQSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChkcmF3Q0RDb25uZWN0b3IpIHtcbiAgICAgICAgLy8gRm9yIEJsdWUgQ0QgY29ubmVjdG9yOlxuICAgICAgICAvLyBNdXN0IGJlIG91dHNpZGUgaW5uZXIgQSBjaXJjbGVzICh3ZSBhbHJlYWR5IGNoZWNrZWQgdGhpcyB3aXRoIG91dHNpZGVSZWxldmFudENpcmNsZXMpXG4gICAgICAgIC8vIE11c3QgYmUgb3V0c2lkZSBvdXRlciBCIGNpcmNsZXMgKHJlcHJlc2VudGVkIGJ5IHRoZSBncmF5IGNpcmNsZXMpXG4gICAgICAgIC8vIE5vdGljZSBob3cgd2UncmUgY2hlY2tpbmcgaWYgd2UncmUgb3V0c2lkZSBib3RoIG91dGVyIEIgY2lyY2xlcyAoQSBhbmQgQilcbiAgICAgICAgaW5zaWRlSW5mbHVlbmNlQXJlYSA9IChkaXN0X0EgPiB1X3JhZGl1c0EpICYmIChkaXN0X0IgPiB1X3JhZGl1c0EpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoIWluc2lkZUluZmx1ZW5jZUFyZWEpIHtcbiAgICAgICAgZGlzY2FyZDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDYWxjdWxhdGUgdmVjdG9yIGJldHdlZW4gdGhlIGFjdGl2ZSBjaXJjbGVzXG4gICAgICB2ZWMyIGFjdGl2ZURpcmVjdGlvbjtcbiAgICAgIHZlYzIgc3RhcnRDZW50ZXI7XG4gICAgICB2ZWMyIGVuZENlbnRlcjtcbiAgICAgIGZsb2F0IGRpc3RTdGFydDtcbiAgICAgIGZsb2F0IGRpc3RFbmQ7XG4gICAgICBcbiAgICAgIGlmIChkcmF3QUJDb25uZWN0b3IpIHtcbiAgICAgICAgYWN0aXZlRGlyZWN0aW9uID0gY2VudGVyX0IgLSBjZW50ZXJfQTtcbiAgICAgICAgc3RhcnRDZW50ZXIgPSBjZW50ZXJfQTtcbiAgICAgICAgZW5kQ2VudGVyID0gY2VudGVyX0I7XG4gICAgICAgIGRpc3RTdGFydCA9IGRpc3RfQTtcbiAgICAgICAgZGlzdEVuZCA9IGRpc3RfQjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKGRyYXdDRENvbm5lY3Rvcikge1xuICAgICAgICBhY3RpdmVEaXJlY3Rpb24gPSBjZW50ZXJfRCAtIGNlbnRlcl9DO1xuICAgICAgICBzdGFydENlbnRlciA9IGNlbnRlcl9DO1xuICAgICAgICBlbmRDZW50ZXIgPSBjZW50ZXJfRDtcbiAgICAgICAgZGlzdFN0YXJ0ID0gZGlzdF9DO1xuICAgICAgICBkaXN0RW5kID0gZGlzdF9EO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDb250aW51ZSB3aXRoIGV4aXN0aW5nIGNvbm5lY3RvciBsb2dpYywgYnV0IHVzZSB0aGUgYWN0aXZlIGNlbnRlcnNcbiAgICAgIGZsb2F0IGxlbmd0aEFCID0gbGVuZ3RoKGFjdGl2ZURpcmVjdGlvbik7XG4gICAgICB2ZWMyIEFCX25vcm1hbGl6ZWQgPSBhY3RpdmVEaXJlY3Rpb24gLyBsZW5ndGhBQjtcbiAgICAgIFxuICAgICAgLy8gUHJvamVjdCBjdXJyZW50IHBvaW50IG9udG8gbGluZVxuICAgICAgdmVjMiBBUCA9IHZXb3JsZFBvcyAtIHN0YXJ0Q2VudGVyO1xuICAgICAgZmxvYXQgcHJvamVjdGlvbiA9IGRvdChBUCwgQUJfbm9ybWFsaXplZCk7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBhIGZpZWxkIHRoYXQgcmVwcmVzZW50cyB0aGUgXCJwYXRod2F5XCIgYmV0d2VlbiB0aGUgdHdvIGNpcmNsZXNcbiAgICAgIC8vIFRoaXMgY3JlYXRlcyBhIGN1cnZlZCBzaGFwZSB0aGF0IG5hcnJvd3MgaW4gdGhlIG1pZGRsZVxuICAgICAgZmxvYXQgcGF0aHdheUZpZWxkO1xuICAgICAgXG4gICAgICAvLyBGb3IgdGhlIGZpcnN0IHBhcnQgb2YgdGhlIGN1cnZhdHVyZSByYW5nZSwgdXNlIGRpc3RhbmNlLWJhc2VkIHNoYXBlXG4gICAgICBpZiAodV9jdXJ2YXR1cmUgPCAwLjUpIHtcbiAgICAgICAgLy8gTWV0aG9kIDE6IFBhdGggd2l0aCB2YXJ5aW5nIHdpZHRoIGJhc2VkIG9uIHByb2plY3Rpb24gYWxvbmcgQUJcbiAgICAgICAgXG4gICAgICAgIC8vIE9ubHkgcHJvY2VlZCBpZiB0aGUgcGl4ZWwgaXMgcmVhc29uYWJseSBuZWFyIHRoZSBBQiBsaW5lXG4gICAgICAgIGlmIChwcm9qZWN0aW9uID49IC11X3JhZGl1c0EgJiYgcHJvamVjdGlvbiA8PSBsZW5ndGhBQiArIHVfcmFkaXVzQSkge1xuICAgICAgICAgIC8vIENhbGN1bGF0ZSBwZXJwZW5kaWN1bGFyIGRpc3RhbmNlIGZyb20gcG9pbnQgdG8gQUIgbGluZVxuICAgICAgICAgIHZlYzIgcGVycGVuZGljdWxhciA9IEFQIC0gcHJvamVjdGlvbiAqIEFCX25vcm1hbGl6ZWQ7XG4gICAgICAgICAgZmxvYXQgcGVycERpc3RhbmNlID0gbGVuZ3RoKHBlcnBlbmRpY3VsYXIpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEJhc2Ugd2lkdGggYmFzZWQgb24gdGhpY2tuZXNzXG4gICAgICAgICAgZmxvYXQgYmFzZVdpZHRoID0gdV90aGlja25lc3MgKiB1X3JhZGl1c0E7XG4gICAgICAgICAgZmxvYXQgbWlkUG9pbnQgPSBsZW5ndGhBQiAqIDAuNTtcbiAgICAgICAgICBmbG9hdCBkaXN0RnJvbU1pZCA9IGFicyhwcm9qZWN0aW9uIC0gbWlkUG9pbnQpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIE1ha2UgbmFycm93ZXIgaW4gbWlkZGxlIGJhc2VkIG9uIGN1cnZhdHVyZVxuICAgICAgICAgIGZsb2F0IHQgPSBkaXN0RnJvbU1pZCAvIG1pZFBvaW50OyAvLyAwIGF0IGNlbnRlciwgMSBhdCBlbmRwb2ludHNcbiAgICAgICAgICBmbG9hdCBuYXJyb3dpbmdGYWN0b3IgPSBtaXgoMC41LCAwLjksIHVfY3VydmF0dXJlICogMi4wKTsgLy8gTW9yZSBuYXJyb3cgYXQgaGlnaGVyIGN1cnZhdHVyZVxuICAgICAgICAgIGZsb2F0IHdpZHRoQ3VydmUgPSAxLjAgLSBwb3codCwgMS41KSAqIG5hcnJvd2luZ0ZhY3RvcjtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGFkanVzdGVkIHdpZHRoIGJhc2VkIG9uIHBvc2l0aW9uXG4gICAgICAgICAgZmxvYXQgYWRqdXN0ZWRXaWR0aDtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAocHJvamVjdGlvbiA8IDAuMCkge1xuICAgICAgICAgICAgLy8gTmVhciBlbmRwb2ludCBBIC0gYmxlbmQgd2l0aCBjaXJjbGVcbiAgICAgICAgICAgIGFkanVzdGVkV2lkdGggPSBtaXgodV9yYWRpdXNBICogMC44LCBiYXNlV2lkdGgsIDEuMCArIHByb2plY3Rpb24gLyB1X3JhZGl1c0EpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocHJvamVjdGlvbiA+IGxlbmd0aEFCKSB7XG4gICAgICAgICAgICAvLyBOZWFyIGVuZHBvaW50IEIgLSBibGVuZCB3aXRoIGNpcmNsZVxuICAgICAgICAgICAgYWRqdXN0ZWRXaWR0aCA9IG1peCh1X3JhZGl1c0EgKiAwLjgsIGJhc2VXaWR0aCwgMS4wIC0gKHByb2plY3Rpb24gLSBsZW5ndGhBQikgLyB1X3JhZGl1c0EpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBCZXR3ZWVuIGVuZHBvaW50cyAtIHVzZSBjdXJ2ZWQgd2lkdGhcbiAgICAgICAgICAgIGFkanVzdGVkV2lkdGggPSBiYXNlV2lkdGggKiB3aWR0aEN1cnZlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBJZiB3aXRoaW4gdGhlIGFkanVzdGVkIHdpZHRoLCB3ZSdyZSBpbiB0aGUgY29ubmVjdG9yXG4gICAgICAgICAgaWYgKHBlcnBEaXN0YW5jZSA8IGFkanVzdGVkV2lkdGgpIHtcbiAgICAgICAgICAgIC8vIFNldCBjb2xvciBiYXNlZCBvbiB3aGljaCBjb25uZWN0b3IgaXMgYmVpbmcgZHJhd25cbiAgICAgICAgICAgIGlmIChkcmF3QUJDb25uZWN0b3IpIHtcbiAgICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgxLjAsIDAuMCwgMC4wLCAxLjApOyAvLyBSZWQgZm9yIEFCIGNvbm5lY3RvclxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjAsIDAuNSwgMS4wLCAxLjApOyAvLyBCbHVlIGZvciBDRCBjb25uZWN0b3JcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBNZXRob2QgMjogVXNlIGh5cGVyYm9saWMgZGlzdGFuY2UgZmllbGQgZm9yIGhpZ2hlciBjdXJ2YXR1cmVcbiAgICAgICAgLy8gTm9ybWFsaXplIGRpc3RhbmNlcyBmb3IgYmV0dGVyIGNvbnRyb2xcbiAgICAgICAgZmxvYXQgZDEgPSBtYXgoMC4wLCBkaXN0U3RhcnQgLSB1X3JhZGl1c0IpIC8gdV9yYWRpdXNBOyBcbiAgICAgICAgZmxvYXQgZDIgPSBtYXgoMC4wLCBkaXN0RW5kIC0gdV9yYWRpdXNCKSAvIHVfcmFkaXVzQTtcbiAgICAgICAgXG4gICAgICAgIC8vIENyZWF0ZSBoeXBlcmJvbGljIGZpZWxkIChwcm9kdWN0IG9mIGRpc3RhbmNlcylcbiAgICAgICAgcGF0aHdheUZpZWxkID0gZDEgKiBkMjtcbiAgICAgICAgXG4gICAgICAgIC8vIEFkanVzdCBmaWVsZCBzdHJlbmd0aCBiYXNlZCBvbiBkaXN0YW5jZSB0byBtYWtlIHNoYXBlIG1vcmUgY29tcGFjdFxuICAgICAgICBmbG9hdCBkaXN0YW5jZVNjYWxlID0gMy4wIC8gbGVuZ3RoQUI7XG4gICAgICAgIHBhdGh3YXlGaWVsZCAqPSBkaXN0YW5jZVNjYWxlO1xuICAgICAgICBcbiAgICAgICAgLy8gVGhpY2tuZXNzIGNvbnRyb2xzIHRoZSB0aHJlc2hvbGRcbiAgICAgICAgZmxvYXQgdGhyZXNob2xkID0gdV90aGlja25lc3MgKiAwLjIgKiBtaXgoMS4wLCAyLjAsIHVfY3VydmF0dXJlIC0gMC41KTtcbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGlmIHdpdGhpbiB0aGUgZmllbGQgdGhyZXNob2xkXG4gICAgICAgIGlmIChwYXRod2F5RmllbGQgPCB0aHJlc2hvbGQpIHtcbiAgICAgICAgICAvLyBPbmx5IHNob3cgY29ubmVjdG9yIGJldHdlZW4gdGhlIGNpcmNsZXMgKG5vdCBleHRlbmRpbmcgb3V0IHRoZSBvdGhlciBzaWRlcylcbiAgICAgICAgICBmbG9hdCBkb3RQcm9kdWN0QSA9IGRvdChBUCwgQUJfbm9ybWFsaXplZCk7XG4gICAgICAgICAgZmxvYXQgZG90UHJvZHVjdEIgPSBkb3QodldvcmxkUG9zIC0gZW5kQ2VudGVyLCAtQUJfbm9ybWFsaXplZCk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGRvdFByb2R1Y3RBID49IC11X3JhZGl1c0IgKiAwLjUgJiYgZG90UHJvZHVjdEIgPj0gLXVfcmFkaXVzQiAqIDAuNSkge1xuICAgICAgICAgICAgLy8gU2V0IGNvbG9yIGJhc2VkIG9uIHdoaWNoIGNvbm5lY3RvciBpcyBiZWluZyBkcmF3blxuICAgICAgICAgICAgaWYgKGRyYXdBQkNvbm5lY3Rvcikge1xuICAgICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDEuMCwgMC4wLCAwLjAsIDEuMCk7IC8vIFJlZCBmb3IgQUIgY29ubmVjdG9yXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuMCwgMC41LCAxLjAsIDEuMCk7IC8vIEJsdWUgZm9yIENEIGNvbm5lY3RvclxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBJZiB3ZSBnb3QgaGVyZSwgdGhlIHBpeGVsIGlzIG91dHNpZGUgdGhlIGNvbm5lY3RvciBzaGFwZVxuICAgICAgZGlzY2FyZDtcbiAgICB9XG4gIGBcbik7XG5cbi8vIEFkZCBhIHVuaXF1ZSBrZXkgZm9yIEhNUiBwdXJwb3NlcyB3aXRoIFIzRlxuR3JpZENvbm5lY3Rvck1hdGVyaWFsLmtleSA9IFRIUkVFLk1hdGhVdGlscy5nZW5lcmF0ZVVVSUQoKTtcblxuZXhwb3J0IHsgR3JpZENvbm5lY3Rvck1hdGVyaWFsIH07ICJdLCJuYW1lcyI6WyJUSFJFRSIsInNoYWRlck1hdGVyaWFsIiwiR3JpZENvbm5lY3Rvck1hdGVyaWFsIiwidV9yYWRpdXNCIiwidV9yYWRpdXNBIiwidV9zcGFjaW5nIiwidV90aGlja25lc3MiLCJ1X2N1cnZhdHVyZSIsInVfcmVzb2x1dGlvbiIsIlZlY3RvcjIiLCJ1X2dyaWRTdGF0ZSIsIkRhdGFUZXh0dXJlIiwiRmxvYXQzMkFycmF5IiwiUkdCQUZvcm1hdCIsIkZsb2F0VHlwZSIsImtleSIsIk1hdGhVdGlscyIsImdlbmVyYXRlVVVJRCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./components/GridConnectorMaterial.js\n");

/***/ }),

/***/ "./components/SimpleConnectorMaterial.js":
/*!***********************************************!*\
  !*** ./components/SimpleConnectorMaterial.js ***!
  \***********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SimpleConnectorMaterial: () => (/* binding */ SimpleConnectorMaterial)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-three/drei */ \"@react-three/drei\");\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_react_three_drei__WEBPACK_IMPORTED_MODULE_1__);\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([three__WEBPACK_IMPORTED_MODULE_0__]);\nthree__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n// A very simple connector material for debugging\nconst SimpleConnectorMaterial = (0,_react_three_drei__WEBPACK_IMPORTED_MODULE_1__.shaderMaterial)(// Uniforms\n{\n    u_radiusB: 0.4,\n    u_radiusA: 0.5,\n    u_boxSize: 0.5,\n    u_spacing: 0.89,\n    u_gridState: new three__WEBPACK_IMPORTED_MODULE_0__.DataTexture(new Float32Array(4), 2, 2, three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat, three__WEBPACK_IMPORTED_MODULE_0__.FloatType)\n}, // Vertex Shader\n/*glsl*/ `\n    varying vec2 vUv;\n    varying vec2 vWorldPos;\n\n    void main() {\n      vUv = uv;\n\n      // World position of the vertex\n      vec4 worldPos = modelMatrix * vec4(position, 1.0);\n      vWorldPos = worldPos.xy;\n\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n  `, // Fragment Shader\n/*glsl*/ `\n    varying vec2 vUv;\n    varying vec2 vWorldPos; // Pixel position in world space\n\n    uniform float u_radiusB; // Radius for target circles B1, B2\n    uniform float u_radiusA; // Radius for defining circles A1, A2\n    uniform float u_boxSize; // Receive box size from JS\n    uniform float u_spacing; // Grid spacing between centers\n    uniform sampler2D u_gridState; // Grid state texture\n\n    // Helper function to get circle state from the grid state texture\n    vec4 getGridState(int row, int col) {\n      return texture2D(u_gridState, vec2(float(col) + 0.5, float(row) + 0.5) / 2.0);\n    }\n\n    // SDF for a 2D circle\n    float sdCircle( vec2 p, vec2 c, float r ) {\n        return length(p-c) - r;\n    }\n\n    // SDF for a 2D Box\n    // p: point, c: center, b: half-size\n    float sdBox( vec2 p, vec2 c, vec2 b ) {\n        vec2 q = abs(p - c) - b;\n        return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n    }\n\n    // Smooth minimum function (use log/exp, base-e is fine)\n    float smin( float a, float b, float k ) {\n        float h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n        return mix( b, a, h ) - k*h*(1.0-h);\n        // Alternative formulation using exp:\n        // k = max(k, 0.0001); // Ensure k is positive\n        // return -log(exp(-k*a) + exp(-k*b))/k;\n    }\n\n    void main() {\n      // Check if both B circles are active before drawing connector\n      vec4 stateA = getGridState(0, 0); // Top-left\n      vec4 stateB = getGridState(1, 1); // Bottom-right\n      vec4 stateC = getGridState(1, 0); // Bottom-left  \n      vec4 stateD = getGridState(0, 1); // Top-right\n      \n      // Check if inner circles are active (red channel = inner circle)\n      bool circleB1Active = stateA.r > 0.5; // Top-left inner circle\n      bool circleB2Active = stateB.r > 0.5; // Bottom-right inner circle\n      bool circleA1Active = stateC.r > 0.5; // Bottom-left inner circle\n      bool circleA2Active = stateD.r > 0.5; // Top-right inner circle\n      \n      // Check which diagonal is active\n      bool diagonalB1B2Active = circleB1Active && circleB2Active;\n      bool diagonalA1A2Active = circleA1Active && circleA2Active;\n      \n      // Only draw connector if at least one diagonal has both inner circles active\n      if (!diagonalB1B2Active && !diagonalA1A2Active) {\n        discard;\n        return;\n      }\n    \n      // Calculate offset based on half the grid spacing\n      float offset = u_spacing * 0.5;\n      \n      // Define circle centers dynamically based on grid spacing\n      vec2 centerB1 = vec2(-offset, offset);    // Top-left\n      vec2 centerB2 = vec2(offset, -offset);    // Bottom-right\n      vec2 centerA1 = vec2(-offset, -offset);   // Bottom-left\n      vec2 centerA2 = vec2(offset, offset);     // Top-right\n\n      // Calculate SDFs for each circle - both inner and outer radii\n      // Inner circles (B radius)\n      float sdB1Inner = sdCircle(vWorldPos, centerB1, u_radiusB);\n      float sdB2Inner = sdCircle(vWorldPos, centerB2, u_radiusB);\n      float sdA1Inner = sdCircle(vWorldPos, centerA1, u_radiusB);\n      float sdA2Inner = sdCircle(vWorldPos, centerA2, u_radiusB);\n      \n      // Outer circles (A radius)\n      float sdB1Outer = sdCircle(vWorldPos, centerB1, u_radiusA);\n      float sdB2Outer = sdCircle(vWorldPos, centerB2, u_radiusA);\n      float sdA1Outer = sdCircle(vWorldPos, centerA1, u_radiusA);\n      float sdA2Outer = sdCircle(vWorldPos, centerA2, u_radiusA);\n      \n      // Calculate SDF for a bounding box using the uniform size\n      vec2 boxCenter = vec2(0.0);\n      vec2 boxHalfSize = vec2(u_boxSize);\n      float sdfBoundingBox = sdBox(vWorldPos, boxCenter, boxHalfSize);\n      \n      // Calculate connector shapes based on the new specifications\n      \n      // Red connector (B1-B2 diagonal):\n      // - Must be outside inner B circles (B1 and B2)\n      // - Must be outside outer A circles (A1 and A2)\n      float sdRedConnector = 1.0;\n      if (diagonalB1B2Active) {\n        bool outsideInnerB = (sdB1Inner > 0.0) && (sdB2Inner > 0.0);\n        bool outsideOuterA = (sdA1Outer > 0.0) && (sdA2Outer > 0.0);\n        \n        if (outsideInnerB && outsideOuterA && sdfBoundingBox < 0.0) {\n          sdRedConnector = -1.0; // Inside the connector\n        }\n      }\n      \n      // Blue connector (A1-A2 diagonal):\n      // - Must be outside inner A circles (A1 and A2)\n      // - Must be outside outer B circles (B1 and B2)\n      float sdBlueConnector = 1.0;\n      if (diagonalA1A2Active) {\n        bool outsideInnerA = (sdA1Inner > 0.0) && (sdA2Inner > 0.0);\n        bool outsideOuterB = (sdB1Outer > 0.0) && (sdB2Outer > 0.0);\n        \n        if (outsideInnerA && outsideOuterB && sdfBoundingBox < 0.0) {\n          sdBlueConnector = -1.0; // Inside the connector\n        }\n      }\n      \n      // Determine if we're inside either connector\n      if (sdRedConnector < 0.0 || sdBlueConnector < 0.0) {\n        // Choose color based on which connector we're inside\n        if (sdRedConnector < 0.0 && sdBlueConnector < 0.0) {\n          // Inside both connectors - use purple\n          gl_FragColor = vec4(0.5, 0.25, 0.5, 1.0); // Purple\n        } else if (sdRedConnector < 0.0) {\n          // Inside red connector only\n          gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); // Red\n        } else {\n          // Inside blue connector only\n          gl_FragColor = vec4(0.0, 0.5, 1.0, 1.0); // Blue\n        }\n      } else {\n        discard; // Outside both connectors\n      }\n    }\n  `);\n// Add a unique key for HMR purposes with R3F\nSimpleConnectorMaterial.key = three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.generateUUID();\n\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL1NpbXBsZUNvbm5lY3Rvck1hdGVyaWFsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBK0I7QUFDb0I7QUFFbkQsaURBQWlEO0FBQ2pELE1BQU1FLDBCQUEwQkQsaUVBQWNBLENBQzVDLFdBQVc7QUFDWDtJQUNFRSxXQUFXO0lBQ1hDLFdBQVc7SUFDWEMsV0FBVztJQUNYQyxXQUFXO0lBQ1hDLGFBQWEsSUFBSVAsOENBQWlCLENBQ2hDLElBQUlTLGFBQWEsSUFDakIsR0FDQSxHQUNBVCw2Q0FBZ0IsRUFDaEJBLDRDQUFlO0FBR25CLEdBQ0EsZ0JBQWdCO0FBQ2hCLE1BQU0sR0FBRSxDQUFDOzs7Ozs7Ozs7Ozs7O0VBYVQsQ0FBQyxFQUNELGtCQUFrQjtBQUNsQixNQUFNLEdBQUUsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFtSVQsQ0FBQztBQUdILDZDQUE2QztBQUM3Q0Usd0JBQXdCVSxHQUFHLEdBQUdaLDRDQUFlLENBQUNjLFlBQVk7QUFFdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWJnbC1kb3QtZ3JpZC1tdnAvLi9jb21wb25lbnRzL1NpbXBsZUNvbm5lY3Rvck1hdGVyaWFsLmpzPzNmOGIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgc2hhZGVyTWF0ZXJpYWwgfSBmcm9tICdAcmVhY3QtdGhyZWUvZHJlaSc7XG5cbi8vIEEgdmVyeSBzaW1wbGUgY29ubmVjdG9yIG1hdGVyaWFsIGZvciBkZWJ1Z2dpbmdcbmNvbnN0IFNpbXBsZUNvbm5lY3Rvck1hdGVyaWFsID0gc2hhZGVyTWF0ZXJpYWwoXG4gIC8vIFVuaWZvcm1zXG4gIHtcbiAgICB1X3JhZGl1c0I6IDAuNCwgLy8gUmFkaXVzIGZvciB0YXJnZXQgY2lyY2xlcyBCMSwgQjIgKGlubmVyKVxuICAgIHVfcmFkaXVzQTogMC41LCAvLyBSYWRpdXMgZm9yIGRlZmluaW5nIGNpcmNsZXMgQTEsIEEyIChvdXRlcilcbiAgICB1X2JveFNpemU6IDAuNSwgLy8gRGVmYXVsdCBoYWxmLXNpemUgZm9yIHRoZSBib3VuZGluZyBib3ggXG4gICAgdV9zcGFjaW5nOiAwLjg5LCAvLyBHcmlkIHNwYWNpbmcgYmV0d2VlbiBjZW50ZXJzXG4gICAgdV9ncmlkU3RhdGU6IG5ldyBUSFJFRS5EYXRhVGV4dHVyZSggLy8gQWRkIGdyaWQgc3RhdGUgdGV4dHVyZVxuICAgICAgbmV3IEZsb2F0MzJBcnJheSg0KSwgLy8gUkdCQSB2YWx1ZXMgcGVyIGNlbGxcbiAgICAgIDIsIC8vIHdpZHRoIChmb3IgMngyIGdyaWQpXG4gICAgICAyLCAvLyBoZWlnaHQgKGZvciAyeDIgZ3JpZClcbiAgICAgIFRIUkVFLlJHQkFGb3JtYXQsXG4gICAgICBUSFJFRS5GbG9hdFR5cGVcbiAgICApXG4gICAgLy8gdV90aGlja25lc3MsIHVfY3VydmF0dXJlLCB1X3Jlc29sdXRpb24gYXJlIHJlbW92ZWQgYXMgdGhleSBhcmUgbm90IG5lZWRlZCBmb3IgdGhpcyBTREYgbG9naWNcbiAgfSxcbiAgLy8gVmVydGV4IFNoYWRlclxuICAvKmdsc2wqL2BcbiAgICB2YXJ5aW5nIHZlYzIgdlV2O1xuICAgIHZhcnlpbmcgdmVjMiB2V29ybGRQb3M7XG5cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICB2VXYgPSB1djtcblxuICAgICAgLy8gV29ybGQgcG9zaXRpb24gb2YgdGhlIHZlcnRleFxuICAgICAgdmVjNCB3b3JsZFBvcyA9IG1vZGVsTWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTtcbiAgICAgIHZXb3JsZFBvcyA9IHdvcmxkUG9zLnh5O1xuXG4gICAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjApO1xuICAgIH1cbiAgYCxcbiAgLy8gRnJhZ21lbnQgU2hhZGVyXG4gIC8qZ2xzbCovYFxuICAgIHZhcnlpbmcgdmVjMiB2VXY7XG4gICAgdmFyeWluZyB2ZWMyIHZXb3JsZFBvczsgLy8gUGl4ZWwgcG9zaXRpb24gaW4gd29ybGQgc3BhY2VcblxuICAgIHVuaWZvcm0gZmxvYXQgdV9yYWRpdXNCOyAvLyBSYWRpdXMgZm9yIHRhcmdldCBjaXJjbGVzIEIxLCBCMlxuICAgIHVuaWZvcm0gZmxvYXQgdV9yYWRpdXNBOyAvLyBSYWRpdXMgZm9yIGRlZmluaW5nIGNpcmNsZXMgQTEsIEEyXG4gICAgdW5pZm9ybSBmbG9hdCB1X2JveFNpemU7IC8vIFJlY2VpdmUgYm94IHNpemUgZnJvbSBKU1xuICAgIHVuaWZvcm0gZmxvYXQgdV9zcGFjaW5nOyAvLyBHcmlkIHNwYWNpbmcgYmV0d2VlbiBjZW50ZXJzXG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdV9ncmlkU3RhdGU7IC8vIEdyaWQgc3RhdGUgdGV4dHVyZVxuXG4gICAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGdldCBjaXJjbGUgc3RhdGUgZnJvbSB0aGUgZ3JpZCBzdGF0ZSB0ZXh0dXJlXG4gICAgdmVjNCBnZXRHcmlkU3RhdGUoaW50IHJvdywgaW50IGNvbCkge1xuICAgICAgcmV0dXJuIHRleHR1cmUyRCh1X2dyaWRTdGF0ZSwgdmVjMihmbG9hdChjb2wpICsgMC41LCBmbG9hdChyb3cpICsgMC41KSAvIDIuMCk7XG4gICAgfVxuXG4gICAgLy8gU0RGIGZvciBhIDJEIGNpcmNsZVxuICAgIGZsb2F0IHNkQ2lyY2xlKCB2ZWMyIHAsIHZlYzIgYywgZmxvYXQgciApIHtcbiAgICAgICAgcmV0dXJuIGxlbmd0aChwLWMpIC0gcjtcbiAgICB9XG5cbiAgICAvLyBTREYgZm9yIGEgMkQgQm94XG4gICAgLy8gcDogcG9pbnQsIGM6IGNlbnRlciwgYjogaGFsZi1zaXplXG4gICAgZmxvYXQgc2RCb3goIHZlYzIgcCwgdmVjMiBjLCB2ZWMyIGIgKSB7XG4gICAgICAgIHZlYzIgcSA9IGFicyhwIC0gYykgLSBiO1xuICAgICAgICByZXR1cm4gbGVuZ3RoKG1heChxLDAuMCkpICsgbWluKG1heChxLngscS55KSwwLjApO1xuICAgIH1cblxuICAgIC8vIFNtb290aCBtaW5pbXVtIGZ1bmN0aW9uICh1c2UgbG9nL2V4cCwgYmFzZS1lIGlzIGZpbmUpXG4gICAgZmxvYXQgc21pbiggZmxvYXQgYSwgZmxvYXQgYiwgZmxvYXQgayApIHtcbiAgICAgICAgZmxvYXQgaCA9IGNsYW1wKCAwLjUgKyAwLjUqKGItYSkvaywgMC4wLCAxLjAgKTtcbiAgICAgICAgcmV0dXJuIG1peCggYiwgYSwgaCApIC0gaypoKigxLjAtaCk7XG4gICAgICAgIC8vIEFsdGVybmF0aXZlIGZvcm11bGF0aW9uIHVzaW5nIGV4cDpcbiAgICAgICAgLy8gayA9IG1heChrLCAwLjAwMDEpOyAvLyBFbnN1cmUgayBpcyBwb3NpdGl2ZVxuICAgICAgICAvLyByZXR1cm4gLWxvZyhleHAoLWsqYSkgKyBleHAoLWsqYikpL2s7XG4gICAgfVxuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgLy8gQ2hlY2sgaWYgYm90aCBCIGNpcmNsZXMgYXJlIGFjdGl2ZSBiZWZvcmUgZHJhd2luZyBjb25uZWN0b3JcbiAgICAgIHZlYzQgc3RhdGVBID0gZ2V0R3JpZFN0YXRlKDAsIDApOyAvLyBUb3AtbGVmdFxuICAgICAgdmVjNCBzdGF0ZUIgPSBnZXRHcmlkU3RhdGUoMSwgMSk7IC8vIEJvdHRvbS1yaWdodFxuICAgICAgdmVjNCBzdGF0ZUMgPSBnZXRHcmlkU3RhdGUoMSwgMCk7IC8vIEJvdHRvbS1sZWZ0ICBcbiAgICAgIHZlYzQgc3RhdGVEID0gZ2V0R3JpZFN0YXRlKDAsIDEpOyAvLyBUb3AtcmlnaHRcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgaW5uZXIgY2lyY2xlcyBhcmUgYWN0aXZlIChyZWQgY2hhbm5lbCA9IGlubmVyIGNpcmNsZSlcbiAgICAgIGJvb2wgY2lyY2xlQjFBY3RpdmUgPSBzdGF0ZUEuciA+IDAuNTsgLy8gVG9wLWxlZnQgaW5uZXIgY2lyY2xlXG4gICAgICBib29sIGNpcmNsZUIyQWN0aXZlID0gc3RhdGVCLnIgPiAwLjU7IC8vIEJvdHRvbS1yaWdodCBpbm5lciBjaXJjbGVcbiAgICAgIGJvb2wgY2lyY2xlQTFBY3RpdmUgPSBzdGF0ZUMuciA+IDAuNTsgLy8gQm90dG9tLWxlZnQgaW5uZXIgY2lyY2xlXG4gICAgICBib29sIGNpcmNsZUEyQWN0aXZlID0gc3RhdGVELnIgPiAwLjU7IC8vIFRvcC1yaWdodCBpbm5lciBjaXJjbGVcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgd2hpY2ggZGlhZ29uYWwgaXMgYWN0aXZlXG4gICAgICBib29sIGRpYWdvbmFsQjFCMkFjdGl2ZSA9IGNpcmNsZUIxQWN0aXZlICYmIGNpcmNsZUIyQWN0aXZlO1xuICAgICAgYm9vbCBkaWFnb25hbEExQTJBY3RpdmUgPSBjaXJjbGVBMUFjdGl2ZSAmJiBjaXJjbGVBMkFjdGl2ZTtcbiAgICAgIFxuICAgICAgLy8gT25seSBkcmF3IGNvbm5lY3RvciBpZiBhdCBsZWFzdCBvbmUgZGlhZ29uYWwgaGFzIGJvdGggaW5uZXIgY2lyY2xlcyBhY3RpdmVcbiAgICAgIGlmICghZGlhZ29uYWxCMUIyQWN0aXZlICYmICFkaWFnb25hbEExQTJBY3RpdmUpIHtcbiAgICAgICAgZGlzY2FyZDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIFxuICAgICAgLy8gQ2FsY3VsYXRlIG9mZnNldCBiYXNlZCBvbiBoYWxmIHRoZSBncmlkIHNwYWNpbmdcbiAgICAgIGZsb2F0IG9mZnNldCA9IHVfc3BhY2luZyAqIDAuNTtcbiAgICAgIFxuICAgICAgLy8gRGVmaW5lIGNpcmNsZSBjZW50ZXJzIGR5bmFtaWNhbGx5IGJhc2VkIG9uIGdyaWQgc3BhY2luZ1xuICAgICAgdmVjMiBjZW50ZXJCMSA9IHZlYzIoLW9mZnNldCwgb2Zmc2V0KTsgICAgLy8gVG9wLWxlZnRcbiAgICAgIHZlYzIgY2VudGVyQjIgPSB2ZWMyKG9mZnNldCwgLW9mZnNldCk7ICAgIC8vIEJvdHRvbS1yaWdodFxuICAgICAgdmVjMiBjZW50ZXJBMSA9IHZlYzIoLW9mZnNldCwgLW9mZnNldCk7ICAgLy8gQm90dG9tLWxlZnRcbiAgICAgIHZlYzIgY2VudGVyQTIgPSB2ZWMyKG9mZnNldCwgb2Zmc2V0KTsgICAgIC8vIFRvcC1yaWdodFxuXG4gICAgICAvLyBDYWxjdWxhdGUgU0RGcyBmb3IgZWFjaCBjaXJjbGUgLSBib3RoIGlubmVyIGFuZCBvdXRlciByYWRpaVxuICAgICAgLy8gSW5uZXIgY2lyY2xlcyAoQiByYWRpdXMpXG4gICAgICBmbG9hdCBzZEIxSW5uZXIgPSBzZENpcmNsZSh2V29ybGRQb3MsIGNlbnRlckIxLCB1X3JhZGl1c0IpO1xuICAgICAgZmxvYXQgc2RCMklubmVyID0gc2RDaXJjbGUodldvcmxkUG9zLCBjZW50ZXJCMiwgdV9yYWRpdXNCKTtcbiAgICAgIGZsb2F0IHNkQTFJbm5lciA9IHNkQ2lyY2xlKHZXb3JsZFBvcywgY2VudGVyQTEsIHVfcmFkaXVzQik7XG4gICAgICBmbG9hdCBzZEEySW5uZXIgPSBzZENpcmNsZSh2V29ybGRQb3MsIGNlbnRlckEyLCB1X3JhZGl1c0IpO1xuICAgICAgXG4gICAgICAvLyBPdXRlciBjaXJjbGVzIChBIHJhZGl1cylcbiAgICAgIGZsb2F0IHNkQjFPdXRlciA9IHNkQ2lyY2xlKHZXb3JsZFBvcywgY2VudGVyQjEsIHVfcmFkaXVzQSk7XG4gICAgICBmbG9hdCBzZEIyT3V0ZXIgPSBzZENpcmNsZSh2V29ybGRQb3MsIGNlbnRlckIyLCB1X3JhZGl1c0EpO1xuICAgICAgZmxvYXQgc2RBMU91dGVyID0gc2RDaXJjbGUodldvcmxkUG9zLCBjZW50ZXJBMSwgdV9yYWRpdXNBKTtcbiAgICAgIGZsb2F0IHNkQTJPdXRlciA9IHNkQ2lyY2xlKHZXb3JsZFBvcywgY2VudGVyQTIsIHVfcmFkaXVzQSk7XG4gICAgICBcbiAgICAgIC8vIENhbGN1bGF0ZSBTREYgZm9yIGEgYm91bmRpbmcgYm94IHVzaW5nIHRoZSB1bmlmb3JtIHNpemVcbiAgICAgIHZlYzIgYm94Q2VudGVyID0gdmVjMigwLjApO1xuICAgICAgdmVjMiBib3hIYWxmU2l6ZSA9IHZlYzIodV9ib3hTaXplKTtcbiAgICAgIGZsb2F0IHNkZkJvdW5kaW5nQm94ID0gc2RCb3godldvcmxkUG9zLCBib3hDZW50ZXIsIGJveEhhbGZTaXplKTtcbiAgICAgIFxuICAgICAgLy8gQ2FsY3VsYXRlIGNvbm5lY3RvciBzaGFwZXMgYmFzZWQgb24gdGhlIG5ldyBzcGVjaWZpY2F0aW9uc1xuICAgICAgXG4gICAgICAvLyBSZWQgY29ubmVjdG9yIChCMS1CMiBkaWFnb25hbCk6XG4gICAgICAvLyAtIE11c3QgYmUgb3V0c2lkZSBpbm5lciBCIGNpcmNsZXMgKEIxIGFuZCBCMilcbiAgICAgIC8vIC0gTXVzdCBiZSBvdXRzaWRlIG91dGVyIEEgY2lyY2xlcyAoQTEgYW5kIEEyKVxuICAgICAgZmxvYXQgc2RSZWRDb25uZWN0b3IgPSAxLjA7XG4gICAgICBpZiAoZGlhZ29uYWxCMUIyQWN0aXZlKSB7XG4gICAgICAgIGJvb2wgb3V0c2lkZUlubmVyQiA9IChzZEIxSW5uZXIgPiAwLjApICYmIChzZEIySW5uZXIgPiAwLjApO1xuICAgICAgICBib29sIG91dHNpZGVPdXRlckEgPSAoc2RBMU91dGVyID4gMC4wKSAmJiAoc2RBMk91dGVyID4gMC4wKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChvdXRzaWRlSW5uZXJCICYmIG91dHNpZGVPdXRlckEgJiYgc2RmQm91bmRpbmdCb3ggPCAwLjApIHtcbiAgICAgICAgICBzZFJlZENvbm5lY3RvciA9IC0xLjA7IC8vIEluc2lkZSB0aGUgY29ubmVjdG9yXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQmx1ZSBjb25uZWN0b3IgKEExLUEyIGRpYWdvbmFsKTpcbiAgICAgIC8vIC0gTXVzdCBiZSBvdXRzaWRlIGlubmVyIEEgY2lyY2xlcyAoQTEgYW5kIEEyKVxuICAgICAgLy8gLSBNdXN0IGJlIG91dHNpZGUgb3V0ZXIgQiBjaXJjbGVzIChCMSBhbmQgQjIpXG4gICAgICBmbG9hdCBzZEJsdWVDb25uZWN0b3IgPSAxLjA7XG4gICAgICBpZiAoZGlhZ29uYWxBMUEyQWN0aXZlKSB7XG4gICAgICAgIGJvb2wgb3V0c2lkZUlubmVyQSA9IChzZEExSW5uZXIgPiAwLjApICYmIChzZEEySW5uZXIgPiAwLjApO1xuICAgICAgICBib29sIG91dHNpZGVPdXRlckIgPSAoc2RCMU91dGVyID4gMC4wKSAmJiAoc2RCMk91dGVyID4gMC4wKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChvdXRzaWRlSW5uZXJBICYmIG91dHNpZGVPdXRlckIgJiYgc2RmQm91bmRpbmdCb3ggPCAwLjApIHtcbiAgICAgICAgICBzZEJsdWVDb25uZWN0b3IgPSAtMS4wOyAvLyBJbnNpZGUgdGhlIGNvbm5lY3RvclxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIERldGVybWluZSBpZiB3ZSdyZSBpbnNpZGUgZWl0aGVyIGNvbm5lY3RvclxuICAgICAgaWYgKHNkUmVkQ29ubmVjdG9yIDwgMC4wIHx8IHNkQmx1ZUNvbm5lY3RvciA8IDAuMCkge1xuICAgICAgICAvLyBDaG9vc2UgY29sb3IgYmFzZWQgb24gd2hpY2ggY29ubmVjdG9yIHdlJ3JlIGluc2lkZVxuICAgICAgICBpZiAoc2RSZWRDb25uZWN0b3IgPCAwLjAgJiYgc2RCbHVlQ29ubmVjdG9yIDwgMC4wKSB7XG4gICAgICAgICAgLy8gSW5zaWRlIGJvdGggY29ubmVjdG9ycyAtIHVzZSBwdXJwbGVcbiAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuNSwgMC4yNSwgMC41LCAxLjApOyAvLyBQdXJwbGVcbiAgICAgICAgfSBlbHNlIGlmIChzZFJlZENvbm5lY3RvciA8IDAuMCkge1xuICAgICAgICAgIC8vIEluc2lkZSByZWQgY29ubmVjdG9yIG9ubHlcbiAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDEuMCwgMC4wLCAwLjAsIDEuMCk7IC8vIFJlZFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEluc2lkZSBibHVlIGNvbm5lY3RvciBvbmx5XG4gICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjAsIDAuNSwgMS4wLCAxLjApOyAvLyBCbHVlXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpc2NhcmQ7IC8vIE91dHNpZGUgYm90aCBjb25uZWN0b3JzXG4gICAgICB9XG4gICAgfVxuICBgXG4pO1xuXG4vLyBBZGQgYSB1bmlxdWUga2V5IGZvciBITVIgcHVycG9zZXMgd2l0aCBSM0ZcblNpbXBsZUNvbm5lY3Rvck1hdGVyaWFsLmtleSA9IFRIUkVFLk1hdGhVdGlscy5nZW5lcmF0ZVVVSUQoKTtcblxuZXhwb3J0IHsgU2ltcGxlQ29ubmVjdG9yTWF0ZXJpYWwgfTsgIl0sIm5hbWVzIjpbIlRIUkVFIiwic2hhZGVyTWF0ZXJpYWwiLCJTaW1wbGVDb25uZWN0b3JNYXRlcmlhbCIsInVfcmFkaXVzQiIsInVfcmFkaXVzQSIsInVfYm94U2l6ZSIsInVfc3BhY2luZyIsInVfZ3JpZFN0YXRlIiwiRGF0YVRleHR1cmUiLCJGbG9hdDMyQXJyYXkiLCJSR0JBRm9ybWF0IiwiRmxvYXRUeXBlIiwia2V5IiwiTWF0aFV0aWxzIiwiZ2VuZXJhdGVVVUlEIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./components/SimpleConnectorMaterial.js\n");

/***/ }),

/***/ "./components/WebGLCanvas.js":
/*!***********************************!*\
  !*** ./components/WebGLCanvas.js ***!
  \***********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ WebGLCanvas)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-three/fiber */ \"@react-three/fiber\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-three/drei */ \"@react-three/drei\");\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_react_three_drei__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var leva__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! leva */ \"leva\");\n/* harmony import */ var leva__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(leva__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _ConnectorMaterial__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ConnectorMaterial */ \"./components/ConnectorMaterial.js\");\n/* harmony import */ var _GridConnectorMaterial__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./GridConnectorMaterial */ \"./components/GridConnectorMaterial.js\");\n/* harmony import */ var _SimpleConnectorMaterial__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./SimpleConnectorMaterial */ \"./components/SimpleConnectorMaterial.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([three__WEBPACK_IMPORTED_MODULE_4__, _ConnectorMaterial__WEBPACK_IMPORTED_MODULE_6__, _GridConnectorMaterial__WEBPACK_IMPORTED_MODULE_7__, _SimpleConnectorMaterial__WEBPACK_IMPORTED_MODULE_8__]);\n([three__WEBPACK_IMPORTED_MODULE_4__, _ConnectorMaterial__WEBPACK_IMPORTED_MODULE_6__, _GridConnectorMaterial__WEBPACK_IMPORTED_MODULE_7__, _SimpleConnectorMaterial__WEBPACK_IMPORTED_MODULE_8__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n\n // Import leva with button instead of monitor\n // We'll create this shader material\n // Import our new connector material\n // Import simple connector for debugging\n// Extend THREE namespace with our custom shader materials\n(0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.extend)({\n    ConnectorMaterial: _ConnectorMaterial__WEBPACK_IMPORTED_MODULE_6__.ConnectorMaterial,\n    GridConnectorMaterial: _GridConnectorMaterial__WEBPACK_IMPORTED_MODULE_7__.GridConnectorMaterial,\n    SimpleConnectorMaterial: _SimpleConnectorMaterial__WEBPACK_IMPORTED_MODULE_8__.SimpleConnectorMaterial\n});\nconst GRID_SIZE = 2;\nconst TOTAL_INSTANCES = GRID_SIZE * GRID_SIZE;\n// Helper to convert grid coords to instance ID\nconst getInstanceId = (row, col)=>row * GRID_SIZE + col;\n// Helper to convert instance ID to grid coords\nconst getGridCoords = (id)=>({\n        row: Math.floor(id / GRID_SIZE),\n        col: id % GRID_SIZE\n    });\n// Create a reusable dummy object for matrix calculation\nconst dummy = new three__WEBPACK_IMPORTED_MODULE_4__.Object3D();\n// Fixed base values\nconst BASE_VALUES = {\n    radiusB: 0.4,\n    radiusA: 0.5,\n    boxSize: 0.5,\n    baseSpacing: 0.89 // Reference spacing for scaling\n};\nfunction Scene() {\n    // Controls for radius, spacing, and debugging\n    const { gridSpacing, zoom, debug, showSimple } = (0,leva__WEBPACK_IMPORTED_MODULE_5__.useControls)({\n        gridSpacing: {\n            value: 0.89,\n            min: 0.5,\n            max: 2.0,\n            step: 0.01,\n            label: \"Grid Spacing\"\n        },\n        zoom: {\n            value: 1.0,\n            min: 0.5,\n            max: 3.0,\n            step: 0.1,\n            label: \"Camera Zoom\"\n        },\n        debug: {\n            value: true,\n            label: \"Debug Mode\"\n        },\n        showSimple: {\n            value: true,\n            label: \"Use Simple Connector\"\n        }\n    });\n    // Calculate scaled values for display\n    const scaleFactor = gridSpacing / BASE_VALUES.baseSpacing;\n    const scaledRadiusB = (BASE_VALUES.radiusB * scaleFactor).toFixed(3);\n    const scaledRadiusA = (BASE_VALUES.radiusA * scaleFactor).toFixed(3);\n    const scaledBoxSize = (BASE_VALUES.boxSize * scaleFactor).toFixed(3);\n    // Display current values in a separate control panel\n    (0,leva__WEBPACK_IMPORTED_MODULE_5__.useControls)(\"Current Values\", {\n        innerRadius: {\n            value: scaledRadiusB,\n            label: \"Inner Radius (B)\",\n            disabled: true\n        },\n        outerRadius: {\n            value: scaledRadiusA,\n            label: \"Outer Radius (A)\",\n            disabled: true\n        },\n        boxSize: {\n            value: scaledBoxSize,\n            label: \"BBox Size\",\n            disabled: true\n        }\n    });\n    // State for the 2x2 grid visibility\n    const [gridState, setGridState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([\n        // Initial state - all circles visible\n        [\n            {\n                showInner: true,\n                showOuter: true\n            },\n            {\n                showInner: true,\n                showOuter: true\n            }\n        ],\n        [\n            {\n                showInner: true,\n                showOuter: true\n            },\n            {\n                showInner: true,\n                showOuter: true\n            }\n        ]\n    ]);\n    const materialRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    const instancedMeshRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    const gridHelperRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    const cameraRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    // Reference for connector material\n    const gridConnectorMaterialRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    const connectorMeshRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    const debugMeshRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    // Reference for simple connector material (for debugging)\n    const simpleConnectorMaterialRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    const simpleConnectorMeshRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    // Attributes for instance visibility data\n    const instanceShowInner = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>new Float32Array(TOTAL_INSTANCES), []);\n    const instanceShowOuter = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>new Float32Array(TOTAL_INSTANCES), []);\n    // Store positions for click detection\n    const instancePositions = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(Array(TOTAL_INSTANCES).fill().map(()=>new three__WEBPACK_IMPORTED_MODULE_4__.Vector3()));\n    // Access three.js helpers\n    const { camera, raycaster, mouse } = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.useThree)();\n    // Log the grid state for debugging\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        console.log(\"Grid State:\", gridState);\n    }, [\n        gridState\n    ]);\n    // Create a data texture to store grid state for the connector shader\n    const gridStateTexture = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        const data = new Float32Array(4 * 4); // RGBA for each of the 4 cells\n        const texture = new three__WEBPACK_IMPORTED_MODULE_4__.DataTexture(data, 2, 2, three__WEBPACK_IMPORTED_MODULE_4__.RGBAFormat, three__WEBPACK_IMPORTED_MODULE_4__.FloatType);\n        texture.needsUpdate = true;\n        return texture;\n    }, []);\n    // Update the grid state texture and uniforms when controls change\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const data = gridStateTexture.image.data;\n        for(let row = 0; row < GRID_SIZE; row++){\n            for(let col = 0; col < GRID_SIZE; col++){\n                const idx = (row * GRID_SIZE + col) * 4;\n                data[idx] = gridState[row][col].showInner ? 1.0 : 0.0; // R - Inner circle\n                data[idx + 1] = gridState[row][col].showOuter ? 1.0 : 0.0; // G - Outer circle\n                data[idx + 2] = 0.0; // B - unused\n                data[idx + 3] = 1.0; // A - opacity\n            }\n        }\n        gridStateTexture.needsUpdate = true;\n        console.log(\"Updated grid state texture\", data);\n        // Calculate scale factor based on ratio to base grid spacing\n        const scaleFactor = gridSpacing / BASE_VALUES.baseSpacing;\n        // Update connector material uniforms (original grid one)\n        if (gridConnectorMaterialRef.current) {\n            gridConnectorMaterialRef.current.uniforms.u_radiusB.value = BASE_VALUES.radiusB * scaleFactor;\n            gridConnectorMaterialRef.current.uniforms.u_radiusA.value = BASE_VALUES.radiusA * scaleFactor;\n            gridConnectorMaterialRef.current.uniforms.u_spacing.value = gridSpacing;\n            gridConnectorMaterialRef.current.uniforms.u_gridState.value = gridStateTexture;\n            // Pass the connector thickness to the shader (if it exists - might remove later)\n            if (gridConnectorMaterialRef.current.uniforms.u_thickness) {\n            // gridConnectorMaterialRef.current.uniforms.u_thickness.value = connectorThickness; // Keep commented out for now\n            }\n            // Pass the curvature parameter (if it exists - might remove later)\n            if (gridConnectorMaterialRef.current.uniforms.u_curvature) {\n            // gridConnectorMaterialRef.current.uniforms.u_curvature.value = connectorCurvature; // Keep commented out for now\n            }\n        }\n        // Update simple connector material uniforms\n        if (simpleConnectorMaterialRef.current) {\n            // Scale the radius and box size values proportionally\n            simpleConnectorMaterialRef.current.uniforms.u_radiusB.value = BASE_VALUES.radiusB * scaleFactor;\n            simpleConnectorMaterialRef.current.uniforms.u_radiusA.value = BASE_VALUES.radiusA * scaleFactor;\n            simpleConnectorMaterialRef.current.uniforms.u_boxSize.value = BASE_VALUES.boxSize * scaleFactor;\n            simpleConnectorMaterialRef.current.uniforms.u_spacing.value = gridSpacing;\n            simpleConnectorMaterialRef.current.uniforms.u_gridState.value = gridStateTexture;\n        }\n    }, [\n        gridState,\n        gridStateTexture,\n        gridSpacing,\n        debug,\n        showSimple\n    ]);\n    // Update camera zoom based on control\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (camera) {\n            camera.zoom = 100 * (1 / zoom); // Adjust as needed for scale\n            camera.updateProjectionMatrix();\n        }\n    }, [\n        camera,\n        zoom\n    ]);\n    // Update instance matrices and visibility attributes based on state\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!instancedMeshRef.current) return;\n        let instanceId = 0;\n        // Calculate grid starting position\n        const startOffset = (GRID_SIZE - 1) * 0.5 * gridSpacing;\n        for(let row = 0; row < GRID_SIZE; row++){\n            for(let col = 0; col < GRID_SIZE; col++){\n                // Position at grid intersections\n                const x = col * gridSpacing - startOffset;\n                const y = -(row * gridSpacing - startOffset); // Y is inverted for screen coordinates\n                // Update the dummy object's position\n                dummy.position.set(x, y, 0);\n                dummy.updateMatrix();\n                // Set the instance matrix\n                instancedMeshRef.current.setMatrixAt(instanceId, dummy.matrix);\n                // Store position for click detection\n                instancePositions.current[instanceId].set(x, y, 0);\n                // Update visibility attributes\n                instanceShowInner[instanceId] = gridState[row][col].showInner ? 1.0 : 0.0;\n                instanceShowOuter[instanceId] = gridState[row][col].showOuter ? 1.0 : 0.0;\n                instanceId++;\n            }\n        }\n        // Mark attributes and matrix for update\n        instancedMeshRef.current.geometry.attributes.a_instanceShowInner.needsUpdate = true;\n        instancedMeshRef.current.geometry.attributes.a_instanceShowOuter.needsUpdate = true;\n        instancedMeshRef.current.instanceMatrix.needsUpdate = true;\n        // Update global uniforms with the radius values\n        if (materialRef.current) {\n            // Calculate scale factor based on ratio to base grid spacing\n            const scaleFactor = gridSpacing / BASE_VALUES.baseSpacing;\n            materialRef.current.uniforms.u_radiusB.value = BASE_VALUES.radiusB * scaleFactor;\n            materialRef.current.uniforms.u_radiusA.value = BASE_VALUES.radiusA * scaleFactor;\n            materialRef.current.uniforms.u_spacing.value = gridSpacing;\n        }\n        // Update grid helper to match spacing\n        if (gridHelperRef.current) {\n            gridHelperRef.current.scale.set(gridSpacing, gridSpacing, 1);\n        }\n    }, [\n        gridState,\n        gridSpacing,\n        instanceShowInner,\n        instanceShowOuter\n    ]);\n    // Handle click on the canvas\n    const handleClick = (event)=>{\n        if (!instancedMeshRef.current) return;\n        // If no instance was hit, return\n        if (event.instanceId === undefined) return;\n        const instanceId = event.instanceId;\n        const { row, col } = getGridCoords(instanceId);\n        console.log(`Clicked instance: row=${row}, col=${col}`);\n        const currentState = gridState[row][col];\n        // Get instance position from our stored reference\n        const instancePosition = instancePositions.current[instanceId];\n        // Create a copy of the click point\n        const pointCopy = event.point.clone();\n        // Calculate distance from click to instance center\n        const distFromCenter = pointCopy.distanceTo(instancePosition);\n        // Calculate scale factor based on ratio to base grid spacing\n        const scaleFactor = gridSpacing / BASE_VALUES.baseSpacing;\n        // Scale the radius values for hit detection\n        const scaledRadiusB = BASE_VALUES.radiusB * scaleFactor;\n        const scaledRadiusA = BASE_VALUES.radiusA * scaleFactor;\n        let newInner = currentState.showInner;\n        let newOuter = currentState.showOuter;\n        if (distFromCenter <= scaledRadiusB) {\n            // Clicked inner circle\n            newInner = !currentState.showInner;\n            console.log(`Toggling inner circle: ${currentState.showInner} -> ${newInner}`);\n        } else if (distFromCenter <= scaledRadiusA) {\n            // Clicked outer circle\n            newOuter = !currentState.showOuter;\n            console.log(`Toggling outer circle: ${currentState.showOuter} -> ${newOuter}`);\n        }\n        if (newInner !== currentState.showInner || newOuter !== currentState.showOuter) {\n            setGridState((prevState)=>{\n                const newState = JSON.parse(JSON.stringify(prevState)); // Deep copy\n                newState[row][col] = {\n                    showInner: newInner,\n                    showOuter: newOuter\n                };\n                return newState;\n            });\n        }\n    };\n    // Calculate plane size based on the grid size and spacing\n    const connectorPlaneSize = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>GRID_SIZE * gridSpacing + Math.max(BASE_VALUES.radiusA, BASE_VALUES.radiusB) * 2, [\n        gridSpacing,\n        BASE_VALUES.radiusA,\n        BASE_VALUES.radiusB\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            debug && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"mesh\", {\n                ref: debugMeshRef,\n                position: [\n                    0,\n                    0,\n                    -0.2\n                ],\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"planeGeometry\", {\n                        args: [\n                            connectorPlaneSize,\n                            connectorPlaneSize\n                        ]\n                    }, void 0, false, {\n                        fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                        lineNumber: 279,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"meshBasicMaterial\", {\n                        color: \"blue\",\n                        opacity: 0.1,\n                        transparent: true\n                    }, void 0, false, {\n                        fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                        lineNumber: 280,\n                        columnNumber: 11\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                lineNumber: 278,\n                columnNumber: 9\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"mesh\", {\n                ref: simpleConnectorMeshRef,\n                position: [\n                    0,\n                    0,\n                    0.1\n                ],\n                visible: showSimple,\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"planeGeometry\", {\n                        args: [\n                            connectorPlaneSize,\n                            connectorPlaneSize\n                        ]\n                    }, void 0, false, {\n                        fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                        lineNumber: 286,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"simpleConnectorMaterial\", {\n                        ref: simpleConnectorMaterialRef,\n                        transparent: true,\n                        depthTest: false\n                    }, _SimpleConnectorMaterial__WEBPACK_IMPORTED_MODULE_8__.SimpleConnectorMaterial.key, false, {\n                        fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                        lineNumber: 287,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                lineNumber: 285,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"mesh\", {\n                ref: connectorMeshRef,\n                position: [\n                    0,\n                    0,\n                    -0.1\n                ],\n                visible: !showSimple,\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"planeGeometry\", {\n                        args: [\n                            connectorPlaneSize,\n                            connectorPlaneSize\n                        ]\n                    }, void 0, false, {\n                        fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                        lineNumber: 297,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"gridConnectorMaterial\", {\n                        ref: gridConnectorMaterialRef,\n                        transparent: true,\n                        depthTest: false\n                    }, _GridConnectorMaterial__WEBPACK_IMPORTED_MODULE_7__.GridConnectorMaterial.key, false, {\n                        fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                        lineNumber: 298,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                lineNumber: 296,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"instancedMesh\", {\n                ref: instancedMeshRef,\n                args: [\n                    null,\n                    null,\n                    TOTAL_INSTANCES\n                ],\n                onClick: handleClick,\n                position: [\n                    0,\n                    0,\n                    0\n                ],\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"planeGeometry\", {\n                        args: [\n                            connectorPlaneSize,\n                            connectorPlaneSize\n                        ],\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"instancedBufferAttribute\", {\n                                attach: \"attributes-a_instanceShowInner\",\n                                args: [\n                                    instanceShowInner,\n                                    1\n                                ]\n                            }, void 0, false, {\n                                fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                                lineNumber: 314,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"instancedBufferAttribute\", {\n                                attach: \"attributes-a_instanceShowOuter\",\n                                args: [\n                                    instanceShowOuter,\n                                    1\n                                ]\n                            }, void 0, false, {\n                                fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                                lineNumber: 318,\n                                columnNumber: 11\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                        lineNumber: 313,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"connectorMaterial\", {\n                        ref: materialRef,\n                        transparent: true\n                    }, _ConnectorMaterial__WEBPACK_IMPORTED_MODULE_6__.ConnectorMaterial.key, false, {\n                        fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                        lineNumber: 323,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                lineNumber: 307,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"group\", {\n                ref: gridHelperRef,\n                position: [\n                    0,\n                    0,\n                    -0.2\n                ],\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"gridHelper\", {\n                    args: [\n                        10,\n                        10\n                    ],\n                    rotation: [\n                        Math.PI / 2,\n                        0,\n                        0\n                    ]\n                }, void 0, false, {\n                    fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                    lineNumber: 332,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                lineNumber: 331,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true);\n}\nfunction WebGLCanvas() {\n    return(// Set up the R3F Canvas\n    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.Canvas, {\n        style: {\n            background: \"#f0f0f0\"\n        },\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_react_three_drei__WEBPACK_IMPORTED_MODULE_3__.OrthographicCamera, {\n                makeDefault: true,\n                zoom: 100,\n                position: [\n                    0,\n                    0,\n                    5\n                ],\n                rotation: [\n                    0,\n                    0,\n                    0\n                ]\n            }, void 0, false, {\n                fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                lineNumber: 346,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ambientLight\", {\n                intensity: 0.8\n            }, void 0, false, {\n                fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                lineNumber: 352,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Scene, {}, void 0, false, {\n                fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                lineNumber: 353,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n        lineNumber: 344,\n        columnNumber: 5\n    }, this));\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNsRTtvQ0FBbUI7aUNBQUU7Ozs7Ozs7Ozs7OztrQ0FHaEMsOERBQUNnRjt3QkFDQ2hCLEtBQUszRTt3QkFFTGlGLGFBQWE7dUJBRFIxSCxpRUFBaUJBLENBQUM4SCxHQUFHOzs7Ozs7Ozs7OzswQkFNOUIsOERBQUNPO2dCQUFNakIsS0FBS3pFO2dCQUFlMkMsVUFBVTtvQkFBQztvQkFBRztvQkFBRyxDQUFDO2lCQUFJOzBCQUMvQyw0RUFBQ2dEO29CQUNDaEIsTUFBTTt3QkFBQzt3QkFBSTtxQkFBRztvQkFDZGlCLFVBQVU7d0JBQUM3SCxLQUFLOEgsRUFBRSxHQUFHO3dCQUFHO3dCQUFHO3FCQUFFOzs7Ozs7Ozs7Ozs7O0FBS3ZDO0FBRWUsU0FBU0M7SUFDdEIsT0FDRSx3QkFBd0I7a0JBQ3hCLDhEQUFDbEosc0RBQU1BO1FBQUNtSixPQUFPO1lBQUVDLFlBQVk7UUFBVTs7MEJBRXJDLDhEQUFDaEosaUVBQWtCQTtnQkFDakJpSixXQUFXO2dCQUNYdkgsTUFBTTtnQkFDTmlFLFVBQVU7b0JBQUM7b0JBQUc7b0JBQUc7aUJBQUU7Z0JBQ25CaUQsVUFBVTtvQkFBQztvQkFBRztvQkFBRztpQkFBRTs7Ozs7OzBCQUVyQiw4REFBQ007Z0JBQWFDLFdBQVc7Ozs7OzswQkFDekIsOERBQUMzSDs7Ozs7Ozs7Ozs7QUFHUCIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYmdsLWRvdC1ncmlkLW12cC8uL2NvbXBvbmVudHMvV2ViR0xDYW52YXMuanM/MjFlZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlUmVmLCB1c2VNZW1vLCB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgQ2FudmFzLCB1c2VGcmFtZSwgZXh0ZW5kLCB1c2VUaHJlZSB9IGZyb20gJ0ByZWFjdC10aHJlZS9maWJlcic7XG5pbXBvcnQgeyBPcnRob2dyYXBoaWNDYW1lcmEgfSBmcm9tICdAcmVhY3QtdGhyZWUvZHJlaSc7XG5pbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyB1c2VDb250cm9scywgZm9sZGVyLCBidXR0b24gfSBmcm9tICdsZXZhJzsgLy8gSW1wb3J0IGxldmEgd2l0aCBidXR0b24gaW5zdGVhZCBvZiBtb25pdG9yXG5pbXBvcnQgeyBDb25uZWN0b3JNYXRlcmlhbCB9IGZyb20gJy4vQ29ubmVjdG9yTWF0ZXJpYWwnOyAvLyBXZSdsbCBjcmVhdGUgdGhpcyBzaGFkZXIgbWF0ZXJpYWxcbmltcG9ydCB7IEdyaWRDb25uZWN0b3JNYXRlcmlhbCB9IGZyb20gJy4vR3JpZENvbm5lY3Rvck1hdGVyaWFsJzsgLy8gSW1wb3J0IG91ciBuZXcgY29ubmVjdG9yIG1hdGVyaWFsXG5pbXBvcnQgeyBTaW1wbGVDb25uZWN0b3JNYXRlcmlhbCB9IGZyb20gJy4vU2ltcGxlQ29ubmVjdG9yTWF0ZXJpYWwnOyAvLyBJbXBvcnQgc2ltcGxlIGNvbm5lY3RvciBmb3IgZGVidWdnaW5nXG5cbi8vIEV4dGVuZCBUSFJFRSBuYW1lc3BhY2Ugd2l0aCBvdXIgY3VzdG9tIHNoYWRlciBtYXRlcmlhbHNcbmV4dGVuZCh7IENvbm5lY3Rvck1hdGVyaWFsLCBHcmlkQ29ubmVjdG9yTWF0ZXJpYWwsIFNpbXBsZUNvbm5lY3Rvck1hdGVyaWFsIH0pO1xuXG5jb25zdCBHUklEX1NJWkUgPSAyO1xuY29uc3QgVE9UQUxfSU5TVEFOQ0VTID0gR1JJRF9TSVpFICogR1JJRF9TSVpFO1xuXG4vLyBIZWxwZXIgdG8gY29udmVydCBncmlkIGNvb3JkcyB0byBpbnN0YW5jZSBJRFxuY29uc3QgZ2V0SW5zdGFuY2VJZCA9IChyb3csIGNvbCkgPT4gcm93ICogR1JJRF9TSVpFICsgY29sO1xuLy8gSGVscGVyIHRvIGNvbnZlcnQgaW5zdGFuY2UgSUQgdG8gZ3JpZCBjb29yZHNcbmNvbnN0IGdldEdyaWRDb29yZHMgPSAoaWQpID0+ICh7IHJvdzogTWF0aC5mbG9vcihpZCAvIEdSSURfU0laRSksIGNvbDogaWQgJSBHUklEX1NJWkUgfSk7XG5cbi8vIENyZWF0ZSBhIHJldXNhYmxlIGR1bW15IG9iamVjdCBmb3IgbWF0cml4IGNhbGN1bGF0aW9uXG5jb25zdCBkdW1teSA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xuXG4vLyBGaXhlZCBiYXNlIHZhbHVlc1xuY29uc3QgQkFTRV9WQUxVRVMgPSB7XG4gIHJhZGl1c0I6IDAuNCwgIC8vIElubmVyIHJhZGl1c1xuICByYWRpdXNBOiAwLjUsICAvLyBPdXRlciByYWRpdXNcbiAgYm94U2l6ZTogMC41LCAgLy8gQm91bmRpbmcgYm94IHNpemVcbiAgYmFzZVNwYWNpbmc6IDAuODkgLy8gUmVmZXJlbmNlIHNwYWNpbmcgZm9yIHNjYWxpbmdcbn07XG5cbmZ1bmN0aW9uIFNjZW5lKCkge1xuICAvLyBDb250cm9scyBmb3IgcmFkaXVzLCBzcGFjaW5nLCBhbmQgZGVidWdnaW5nXG4gIGNvbnN0IHsgZ3JpZFNwYWNpbmcsIHpvb20sIGRlYnVnLCBzaG93U2ltcGxlIH0gPSB1c2VDb250cm9scyh7XG4gICAgZ3JpZFNwYWNpbmc6IHsgdmFsdWU6IDAuODksIG1pbjogMC41LCBtYXg6IDIuMCwgc3RlcDogMC4wMSwgbGFiZWw6ICdHcmlkIFNwYWNpbmcnIH0sXG4gICAgem9vbTogeyB2YWx1ZTogMS4wLCBtaW46IDAuNSwgbWF4OiAzLjAsIHN0ZXA6IDAuMSwgbGFiZWw6ICdDYW1lcmEgWm9vbScgfSxcbiAgICBkZWJ1ZzogeyB2YWx1ZTogdHJ1ZSwgbGFiZWw6ICdEZWJ1ZyBNb2RlJyB9LFxuICAgIHNob3dTaW1wbGU6IHsgdmFsdWU6IHRydWUsIGxhYmVsOiAnVXNlIFNpbXBsZSBDb25uZWN0b3InIH0sXG4gIH0pO1xuICBcbiAgLy8gQ2FsY3VsYXRlIHNjYWxlZCB2YWx1ZXMgZm9yIGRpc3BsYXlcbiAgY29uc3Qgc2NhbGVGYWN0b3IgPSBncmlkU3BhY2luZyAvIEJBU0VfVkFMVUVTLmJhc2VTcGFjaW5nO1xuICBjb25zdCBzY2FsZWRSYWRpdXNCID0gKEJBU0VfVkFMVUVTLnJhZGl1c0IgKiBzY2FsZUZhY3RvcikudG9GaXhlZCgzKTtcbiAgY29uc3Qgc2NhbGVkUmFkaXVzQSA9IChCQVNFX1ZBTFVFUy5yYWRpdXNBICogc2NhbGVGYWN0b3IpLnRvRml4ZWQoMyk7XG4gIGNvbnN0IHNjYWxlZEJveFNpemUgPSAoQkFTRV9WQUxVRVMuYm94U2l6ZSAqIHNjYWxlRmFjdG9yKS50b0ZpeGVkKDMpO1xuICBcbiAgLy8gRGlzcGxheSBjdXJyZW50IHZhbHVlcyBpbiBhIHNlcGFyYXRlIGNvbnRyb2wgcGFuZWxcbiAgdXNlQ29udHJvbHMoXG4gICAgJ0N1cnJlbnQgVmFsdWVzJyxcbiAgICB7XG4gICAgICBpbm5lclJhZGl1czogeyB2YWx1ZTogc2NhbGVkUmFkaXVzQiwgbGFiZWw6ICdJbm5lciBSYWRpdXMgKEIpJywgZGlzYWJsZWQ6IHRydWUgfSxcbiAgICAgIG91dGVyUmFkaXVzOiB7IHZhbHVlOiBzY2FsZWRSYWRpdXNBLCBsYWJlbDogJ091dGVyIFJhZGl1cyAoQSknLCBkaXNhYmxlZDogdHJ1ZSB9LFxuICAgICAgYm94U2l6ZTogeyB2YWx1ZTogc2NhbGVkQm94U2l6ZSwgbGFiZWw6ICdCQm94IFNpemUnLCBkaXNhYmxlZDogdHJ1ZSB9LFxuICAgIH1cbiAgKTtcblxuICAvLyBTdGF0ZSBmb3IgdGhlIDJ4MiBncmlkIHZpc2liaWxpdHlcbiAgY29uc3QgW2dyaWRTdGF0ZSwgc2V0R3JpZFN0YXRlXSA9IHVzZVN0YXRlKFtcbiAgICAvLyBJbml0aWFsIHN0YXRlIC0gYWxsIGNpcmNsZXMgdmlzaWJsZVxuICAgIFt7IHNob3dJbm5lcjogdHJ1ZSwgc2hvd091dGVyOiB0cnVlIH0sIHsgc2hvd0lubmVyOiB0cnVlLCBzaG93T3V0ZXI6IHRydWUgfV0sXG4gICAgW3sgc2hvd0lubmVyOiB0cnVlLCBzaG93T3V0ZXI6IHRydWUgfSwgeyBzaG93SW5uZXI6IHRydWUsIHNob3dPdXRlcjogdHJ1ZSB9XVxuICBdKTtcblxuICBjb25zdCBtYXRlcmlhbFJlZiA9IHVzZVJlZigpO1xuICBjb25zdCBpbnN0YW5jZWRNZXNoUmVmID0gdXNlUmVmKCk7XG4gIGNvbnN0IGdyaWRIZWxwZXJSZWYgPSB1c2VSZWYoKTtcbiAgY29uc3QgY2FtZXJhUmVmID0gdXNlUmVmKCk7XG5cbiAgLy8gUmVmZXJlbmNlIGZvciBjb25uZWN0b3IgbWF0ZXJpYWxcbiAgY29uc3QgZ3JpZENvbm5lY3Rvck1hdGVyaWFsUmVmID0gdXNlUmVmKCk7XG4gIGNvbnN0IGNvbm5lY3Rvck1lc2hSZWYgPSB1c2VSZWYoKTtcbiAgY29uc3QgZGVidWdNZXNoUmVmID0gdXNlUmVmKCk7XG5cbiAgLy8gUmVmZXJlbmNlIGZvciBzaW1wbGUgY29ubmVjdG9yIG1hdGVyaWFsIChmb3IgZGVidWdnaW5nKVxuICBjb25zdCBzaW1wbGVDb25uZWN0b3JNYXRlcmlhbFJlZiA9IHVzZVJlZigpO1xuICBjb25zdCBzaW1wbGVDb25uZWN0b3JNZXNoUmVmID0gdXNlUmVmKCk7XG5cbiAgLy8gQXR0cmlidXRlcyBmb3IgaW5zdGFuY2UgdmlzaWJpbGl0eSBkYXRhXG4gIGNvbnN0IGluc3RhbmNlU2hvd0lubmVyID0gdXNlTWVtbygoKSA9PiBuZXcgRmxvYXQzMkFycmF5KFRPVEFMX0lOU1RBTkNFUyksIFtdKTtcbiAgY29uc3QgaW5zdGFuY2VTaG93T3V0ZXIgPSB1c2VNZW1vKCgpID0+IG5ldyBGbG9hdDMyQXJyYXkoVE9UQUxfSU5TVEFOQ0VTKSwgW10pO1xuXG4gIC8vIFN0b3JlIHBvc2l0aW9ucyBmb3IgY2xpY2sgZGV0ZWN0aW9uXG4gIGNvbnN0IGluc3RhbmNlUG9zaXRpb25zID0gdXNlUmVmKEFycmF5KFRPVEFMX0lOU1RBTkNFUykuZmlsbCgpLm1hcCgoKSA9PiBuZXcgVEhSRUUuVmVjdG9yMygpKSk7XG5cbiAgLy8gQWNjZXNzIHRocmVlLmpzIGhlbHBlcnNcbiAgY29uc3QgeyBjYW1lcmEsIHJheWNhc3RlciwgbW91c2UgfSA9IHVzZVRocmVlKCk7XG5cbiAgLy8gTG9nIHRoZSBncmlkIHN0YXRlIGZvciBkZWJ1Z2dpbmdcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zb2xlLmxvZygnR3JpZCBTdGF0ZTonLCBncmlkU3RhdGUpO1xuICB9LCBbZ3JpZFN0YXRlXSk7XG5cbiAgLy8gQ3JlYXRlIGEgZGF0YSB0ZXh0dXJlIHRvIHN0b3JlIGdyaWQgc3RhdGUgZm9yIHRoZSBjb25uZWN0b3Igc2hhZGVyXG4gIGNvbnN0IGdyaWRTdGF0ZVRleHR1cmUgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCBkYXRhID0gbmV3IEZsb2F0MzJBcnJheSg0ICogNCk7IC8vIFJHQkEgZm9yIGVhY2ggb2YgdGhlIDQgY2VsbHNcbiAgICBjb25zdCB0ZXh0dXJlID0gbmV3IFRIUkVFLkRhdGFUZXh0dXJlKFxuICAgICAgZGF0YSxcbiAgICAgIDIsIC8vIHdpZHRoIGZvciAyeDIgZ3JpZFxuICAgICAgMiwgLy8gaGVpZ2h0XG4gICAgICBUSFJFRS5SR0JBRm9ybWF0LFxuICAgICAgVEhSRUUuRmxvYXRUeXBlXG4gICAgKTtcbiAgICB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICByZXR1cm4gdGV4dHVyZTtcbiAgfSwgW10pO1xuXG4gIC8vIFVwZGF0ZSB0aGUgZ3JpZCBzdGF0ZSB0ZXh0dXJlIGFuZCB1bmlmb3JtcyB3aGVuIGNvbnRyb2xzIGNoYW5nZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGRhdGEgPSBncmlkU3RhdGVUZXh0dXJlLmltYWdlLmRhdGE7XG4gICAgXG4gICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgR1JJRF9TSVpFOyByb3crKykge1xuICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgR1JJRF9TSVpFOyBjb2wrKykge1xuICAgICAgICBjb25zdCBpZHggPSAocm93ICogR1JJRF9TSVpFICsgY29sKSAqIDQ7XG4gICAgICAgIGRhdGFbaWR4XSA9IGdyaWRTdGF0ZVtyb3ddW2NvbF0uc2hvd0lubmVyID8gMS4wIDogMC4wOyAgICAgLy8gUiAtIElubmVyIGNpcmNsZVxuICAgICAgICBkYXRhW2lkeCArIDFdID0gZ3JpZFN0YXRlW3Jvd11bY29sXS5zaG93T3V0ZXIgPyAxLjAgOiAwLjA7IC8vIEcgLSBPdXRlciBjaXJjbGVcbiAgICAgICAgZGF0YVtpZHggKyAyXSA9IDAuMDsgLy8gQiAtIHVudXNlZFxuICAgICAgICBkYXRhW2lkeCArIDNdID0gMS4wOyAvLyBBIC0gb3BhY2l0eVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBncmlkU3RhdGVUZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICBjb25zb2xlLmxvZygnVXBkYXRlZCBncmlkIHN0YXRlIHRleHR1cmUnLCBkYXRhKTtcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgc2NhbGUgZmFjdG9yIGJhc2VkIG9uIHJhdGlvIHRvIGJhc2UgZ3JpZCBzcGFjaW5nXG4gICAgY29uc3Qgc2NhbGVGYWN0b3IgPSBncmlkU3BhY2luZyAvIEJBU0VfVkFMVUVTLmJhc2VTcGFjaW5nO1xuICAgIFxuICAgIC8vIFVwZGF0ZSBjb25uZWN0b3IgbWF0ZXJpYWwgdW5pZm9ybXMgKG9yaWdpbmFsIGdyaWQgb25lKVxuICAgIGlmIChncmlkQ29ubmVjdG9yTWF0ZXJpYWxSZWYuY3VycmVudCkge1xuICAgICAgZ3JpZENvbm5lY3Rvck1hdGVyaWFsUmVmLmN1cnJlbnQudW5pZm9ybXMudV9yYWRpdXNCLnZhbHVlID0gQkFTRV9WQUxVRVMucmFkaXVzQiAqIHNjYWxlRmFjdG9yO1xuICAgICAgZ3JpZENvbm5lY3Rvck1hdGVyaWFsUmVmLmN1cnJlbnQudW5pZm9ybXMudV9yYWRpdXNBLnZhbHVlID0gQkFTRV9WQUxVRVMucmFkaXVzQSAqIHNjYWxlRmFjdG9yO1xuICAgICAgZ3JpZENvbm5lY3Rvck1hdGVyaWFsUmVmLmN1cnJlbnQudW5pZm9ybXMudV9zcGFjaW5nLnZhbHVlID0gZ3JpZFNwYWNpbmc7XG4gICAgICBncmlkQ29ubmVjdG9yTWF0ZXJpYWxSZWYuY3VycmVudC51bmlmb3Jtcy51X2dyaWRTdGF0ZS52YWx1ZSA9IGdyaWRTdGF0ZVRleHR1cmU7XG4gICAgICAvLyBQYXNzIHRoZSBjb25uZWN0b3IgdGhpY2tuZXNzIHRvIHRoZSBzaGFkZXIgKGlmIGl0IGV4aXN0cyAtIG1pZ2h0IHJlbW92ZSBsYXRlcilcbiAgICAgIGlmIChncmlkQ29ubmVjdG9yTWF0ZXJpYWxSZWYuY3VycmVudC51bmlmb3Jtcy51X3RoaWNrbmVzcykge1xuICAgICAgICAvLyBncmlkQ29ubmVjdG9yTWF0ZXJpYWxSZWYuY3VycmVudC51bmlmb3Jtcy51X3RoaWNrbmVzcy52YWx1ZSA9IGNvbm5lY3RvclRoaWNrbmVzczsgLy8gS2VlcCBjb21tZW50ZWQgb3V0IGZvciBub3dcbiAgICAgIH1cbiAgICAgIC8vIFBhc3MgdGhlIGN1cnZhdHVyZSBwYXJhbWV0ZXIgKGlmIGl0IGV4aXN0cyAtIG1pZ2h0IHJlbW92ZSBsYXRlcilcbiAgICAgIGlmIChncmlkQ29ubmVjdG9yTWF0ZXJpYWxSZWYuY3VycmVudC51bmlmb3Jtcy51X2N1cnZhdHVyZSkge1xuICAgICAgICAvLyBncmlkQ29ubmVjdG9yTWF0ZXJpYWxSZWYuY3VycmVudC51bmlmb3Jtcy51X2N1cnZhdHVyZS52YWx1ZSA9IGNvbm5lY3RvckN1cnZhdHVyZTsgLy8gS2VlcCBjb21tZW50ZWQgb3V0IGZvciBub3dcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gVXBkYXRlIHNpbXBsZSBjb25uZWN0b3IgbWF0ZXJpYWwgdW5pZm9ybXNcbiAgICBpZiAoc2ltcGxlQ29ubmVjdG9yTWF0ZXJpYWxSZWYuY3VycmVudCkge1xuICAgICAgLy8gU2NhbGUgdGhlIHJhZGl1cyBhbmQgYm94IHNpemUgdmFsdWVzIHByb3BvcnRpb25hbGx5XG4gICAgICBzaW1wbGVDb25uZWN0b3JNYXRlcmlhbFJlZi5jdXJyZW50LnVuaWZvcm1zLnVfcmFkaXVzQi52YWx1ZSA9IEJBU0VfVkFMVUVTLnJhZGl1c0IgKiBzY2FsZUZhY3RvcjtcbiAgICAgIHNpbXBsZUNvbm5lY3Rvck1hdGVyaWFsUmVmLmN1cnJlbnQudW5pZm9ybXMudV9yYWRpdXNBLnZhbHVlID0gQkFTRV9WQUxVRVMucmFkaXVzQSAqIHNjYWxlRmFjdG9yO1xuICAgICAgc2ltcGxlQ29ubmVjdG9yTWF0ZXJpYWxSZWYuY3VycmVudC51bmlmb3Jtcy51X2JveFNpemUudmFsdWUgPSBCQVNFX1ZBTFVFUy5ib3hTaXplICogc2NhbGVGYWN0b3I7XG4gICAgICBzaW1wbGVDb25uZWN0b3JNYXRlcmlhbFJlZi5jdXJyZW50LnVuaWZvcm1zLnVfc3BhY2luZy52YWx1ZSA9IGdyaWRTcGFjaW5nO1xuICAgICAgc2ltcGxlQ29ubmVjdG9yTWF0ZXJpYWxSZWYuY3VycmVudC51bmlmb3Jtcy51X2dyaWRTdGF0ZS52YWx1ZSA9IGdyaWRTdGF0ZVRleHR1cmU7XG4gICAgfVxuICB9LCBbZ3JpZFN0YXRlLCBncmlkU3RhdGVUZXh0dXJlLCBncmlkU3BhY2luZywgZGVidWcsIHNob3dTaW1wbGVdKTtcblxuICAvLyBVcGRhdGUgY2FtZXJhIHpvb20gYmFzZWQgb24gY29udHJvbFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChjYW1lcmEpIHtcbiAgICAgIGNhbWVyYS56b29tID0gMTAwICogKDEvem9vbSk7IC8vIEFkanVzdCBhcyBuZWVkZWQgZm9yIHNjYWxlXG4gICAgICBjYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICAgIH1cbiAgfSwgW2NhbWVyYSwgem9vbV0pO1xuXG4gIC8vIFVwZGF0ZSBpbnN0YW5jZSBtYXRyaWNlcyBhbmQgdmlzaWJpbGl0eSBhdHRyaWJ1dGVzIGJhc2VkIG9uIHN0YXRlXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFpbnN0YW5jZWRNZXNoUmVmLmN1cnJlbnQpIHJldHVybjtcblxuICAgIGxldCBpbnN0YW5jZUlkID0gMDtcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgZ3JpZCBzdGFydGluZyBwb3NpdGlvblxuICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gKEdSSURfU0laRSAtIDEpICogMC41ICogZ3JpZFNwYWNpbmc7XG4gICAgXG4gICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgR1JJRF9TSVpFOyByb3crKykge1xuICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgR1JJRF9TSVpFOyBjb2wrKykge1xuICAgICAgICAvLyBQb3NpdGlvbiBhdCBncmlkIGludGVyc2VjdGlvbnNcbiAgICAgICAgY29uc3QgeCA9IGNvbCAqIGdyaWRTcGFjaW5nIC0gc3RhcnRPZmZzZXQ7XG4gICAgICAgIGNvbnN0IHkgPSAtKHJvdyAqIGdyaWRTcGFjaW5nIC0gc3RhcnRPZmZzZXQpOyAvLyBZIGlzIGludmVydGVkIGZvciBzY3JlZW4gY29vcmRpbmF0ZXNcbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgZHVtbXkgb2JqZWN0J3MgcG9zaXRpb25cbiAgICAgICAgZHVtbXkucG9zaXRpb24uc2V0KHgsIHksIDApO1xuICAgICAgICBkdW1teS51cGRhdGVNYXRyaXgoKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNldCB0aGUgaW5zdGFuY2UgbWF0cml4XG4gICAgICAgIGluc3RhbmNlZE1lc2hSZWYuY3VycmVudC5zZXRNYXRyaXhBdChpbnN0YW5jZUlkLCBkdW1teS5tYXRyaXgpO1xuICAgICAgICBcbiAgICAgICAgLy8gU3RvcmUgcG9zaXRpb24gZm9yIGNsaWNrIGRldGVjdGlvblxuICAgICAgICBpbnN0YW5jZVBvc2l0aW9ucy5jdXJyZW50W2luc3RhbmNlSWRdLnNldCh4LCB5LCAwKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSB2aXNpYmlsaXR5IGF0dHJpYnV0ZXNcbiAgICAgICAgaW5zdGFuY2VTaG93SW5uZXJbaW5zdGFuY2VJZF0gPSBncmlkU3RhdGVbcm93XVtjb2xdLnNob3dJbm5lciA/IDEuMCA6IDAuMDtcbiAgICAgICAgaW5zdGFuY2VTaG93T3V0ZXJbaW5zdGFuY2VJZF0gPSBncmlkU3RhdGVbcm93XVtjb2xdLnNob3dPdXRlciA/IDEuMCA6IDAuMDtcbiAgICAgICAgXG4gICAgICAgIGluc3RhbmNlSWQrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNYXJrIGF0dHJpYnV0ZXMgYW5kIG1hdHJpeCBmb3IgdXBkYXRlXG4gICAgaW5zdGFuY2VkTWVzaFJlZi5jdXJyZW50Lmdlb21ldHJ5LmF0dHJpYnV0ZXMuYV9pbnN0YW5jZVNob3dJbm5lci5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgaW5zdGFuY2VkTWVzaFJlZi5jdXJyZW50Lmdlb21ldHJ5LmF0dHJpYnV0ZXMuYV9pbnN0YW5jZVNob3dPdXRlci5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgaW5zdGFuY2VkTWVzaFJlZi5jdXJyZW50Lmluc3RhbmNlTWF0cml4Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgIC8vIFVwZGF0ZSBnbG9iYWwgdW5pZm9ybXMgd2l0aCB0aGUgcmFkaXVzIHZhbHVlc1xuICAgIGlmIChtYXRlcmlhbFJlZi5jdXJyZW50KSB7XG4gICAgICAvLyBDYWxjdWxhdGUgc2NhbGUgZmFjdG9yIGJhc2VkIG9uIHJhdGlvIHRvIGJhc2UgZ3JpZCBzcGFjaW5nXG4gICAgICBjb25zdCBzY2FsZUZhY3RvciA9IGdyaWRTcGFjaW5nIC8gQkFTRV9WQUxVRVMuYmFzZVNwYWNpbmc7XG4gICAgICBcbiAgICAgIG1hdGVyaWFsUmVmLmN1cnJlbnQudW5pZm9ybXMudV9yYWRpdXNCLnZhbHVlID0gQkFTRV9WQUxVRVMucmFkaXVzQiAqIHNjYWxlRmFjdG9yO1xuICAgICAgbWF0ZXJpYWxSZWYuY3VycmVudC51bmlmb3Jtcy51X3JhZGl1c0EudmFsdWUgPSBCQVNFX1ZBTFVFUy5yYWRpdXNBICogc2NhbGVGYWN0b3I7XG4gICAgICBtYXRlcmlhbFJlZi5jdXJyZW50LnVuaWZvcm1zLnVfc3BhY2luZy52YWx1ZSA9IGdyaWRTcGFjaW5nO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBncmlkIGhlbHBlciB0byBtYXRjaCBzcGFjaW5nXG4gICAgaWYgKGdyaWRIZWxwZXJSZWYuY3VycmVudCkge1xuICAgICAgZ3JpZEhlbHBlclJlZi5jdXJyZW50LnNjYWxlLnNldChncmlkU3BhY2luZywgZ3JpZFNwYWNpbmcsIDEpO1xuICAgIH1cblxuICB9LCBbZ3JpZFN0YXRlLCBncmlkU3BhY2luZywgaW5zdGFuY2VTaG93SW5uZXIsIGluc3RhbmNlU2hvd091dGVyXSk7XG5cbiAgLy8gSGFuZGxlIGNsaWNrIG9uIHRoZSBjYW52YXNcbiAgY29uc3QgaGFuZGxlQ2xpY2sgPSAoZXZlbnQpID0+IHtcbiAgICBpZiAoIWluc3RhbmNlZE1lc2hSZWYuY3VycmVudCkgcmV0dXJuO1xuICAgIFxuICAgIC8vIElmIG5vIGluc3RhbmNlIHdhcyBoaXQsIHJldHVyblxuICAgIGlmIChldmVudC5pbnN0YW5jZUlkID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICBcbiAgICBjb25zdCBpbnN0YW5jZUlkID0gZXZlbnQuaW5zdGFuY2VJZDtcbiAgICBjb25zdCB7IHJvdywgY29sIH0gPSBnZXRHcmlkQ29vcmRzKGluc3RhbmNlSWQpO1xuICAgIGNvbnNvbGUubG9nKGBDbGlja2VkIGluc3RhbmNlOiByb3c9JHtyb3d9LCBjb2w9JHtjb2x9YCk7XG4gICAgXG4gICAgY29uc3QgY3VycmVudFN0YXRlID0gZ3JpZFN0YXRlW3Jvd11bY29sXTtcbiAgICBcbiAgICAvLyBHZXQgaW5zdGFuY2UgcG9zaXRpb24gZnJvbSBvdXIgc3RvcmVkIHJlZmVyZW5jZVxuICAgIGNvbnN0IGluc3RhbmNlUG9zaXRpb24gPSBpbnN0YW5jZVBvc2l0aW9ucy5jdXJyZW50W2luc3RhbmNlSWRdO1xuICAgIFxuICAgIC8vIENyZWF0ZSBhIGNvcHkgb2YgdGhlIGNsaWNrIHBvaW50XG4gICAgY29uc3QgcG9pbnRDb3B5ID0gZXZlbnQucG9pbnQuY2xvbmUoKTtcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgZGlzdGFuY2UgZnJvbSBjbGljayB0byBpbnN0YW5jZSBjZW50ZXJcbiAgICBjb25zdCBkaXN0RnJvbUNlbnRlciA9IHBvaW50Q29weS5kaXN0YW5jZVRvKGluc3RhbmNlUG9zaXRpb24pO1xuICAgIFxuICAgIC8vIENhbGN1bGF0ZSBzY2FsZSBmYWN0b3IgYmFzZWQgb24gcmF0aW8gdG8gYmFzZSBncmlkIHNwYWNpbmdcbiAgICBjb25zdCBzY2FsZUZhY3RvciA9IGdyaWRTcGFjaW5nIC8gQkFTRV9WQUxVRVMuYmFzZVNwYWNpbmc7XG4gICAgXG4gICAgLy8gU2NhbGUgdGhlIHJhZGl1cyB2YWx1ZXMgZm9yIGhpdCBkZXRlY3Rpb25cbiAgICBjb25zdCBzY2FsZWRSYWRpdXNCID0gQkFTRV9WQUxVRVMucmFkaXVzQiAqIHNjYWxlRmFjdG9yO1xuICAgIGNvbnN0IHNjYWxlZFJhZGl1c0EgPSBCQVNFX1ZBTFVFUy5yYWRpdXNBICogc2NhbGVGYWN0b3I7XG4gICAgXG4gICAgbGV0IG5ld0lubmVyID0gY3VycmVudFN0YXRlLnNob3dJbm5lcjtcbiAgICBsZXQgbmV3T3V0ZXIgPSBjdXJyZW50U3RhdGUuc2hvd091dGVyO1xuXG4gICAgaWYgKGRpc3RGcm9tQ2VudGVyIDw9IHNjYWxlZFJhZGl1c0IpIHtcbiAgICAgIC8vIENsaWNrZWQgaW5uZXIgY2lyY2xlXG4gICAgICBuZXdJbm5lciA9ICFjdXJyZW50U3RhdGUuc2hvd0lubmVyO1xuICAgICAgY29uc29sZS5sb2coYFRvZ2dsaW5nIGlubmVyIGNpcmNsZTogJHtjdXJyZW50U3RhdGUuc2hvd0lubmVyfSAtPiAke25ld0lubmVyfWApO1xuICAgIH0gZWxzZSBpZiAoZGlzdEZyb21DZW50ZXIgPD0gc2NhbGVkUmFkaXVzQSkge1xuICAgICAgLy8gQ2xpY2tlZCBvdXRlciBjaXJjbGVcbiAgICAgIG5ld091dGVyID0gIWN1cnJlbnRTdGF0ZS5zaG93T3V0ZXI7XG4gICAgICBjb25zb2xlLmxvZyhgVG9nZ2xpbmcgb3V0ZXIgY2lyY2xlOiAke2N1cnJlbnRTdGF0ZS5zaG93T3V0ZXJ9IC0+ICR7bmV3T3V0ZXJ9YCk7XG4gICAgfVxuICAgIFxuICAgIGlmIChuZXdJbm5lciAhPT0gY3VycmVudFN0YXRlLnNob3dJbm5lciB8fCBuZXdPdXRlciAhPT0gY3VycmVudFN0YXRlLnNob3dPdXRlcikge1xuICAgICAgc2V0R3JpZFN0YXRlKHByZXZTdGF0ZSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld1N0YXRlID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShwcmV2U3RhdGUpKTsgLy8gRGVlcCBjb3B5XG4gICAgICAgIG5ld1N0YXRlW3Jvd11bY29sXSA9IHsgc2hvd0lubmVyOiBuZXdJbm5lciwgc2hvd091dGVyOiBuZXdPdXRlciB9O1xuICAgICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gQ2FsY3VsYXRlIHBsYW5lIHNpemUgYmFzZWQgb24gdGhlIGdyaWQgc2l6ZSBhbmQgc3BhY2luZ1xuICBjb25zdCBjb25uZWN0b3JQbGFuZVNpemUgPSB1c2VNZW1vKCgpID0+IFxuICAgIEdSSURfU0laRSAqIGdyaWRTcGFjaW5nICsgTWF0aC5tYXgoQkFTRV9WQUxVRVMucmFkaXVzQSwgQkFTRV9WQUxVRVMucmFkaXVzQikgKiAyLFxuICAgIFtncmlkU3BhY2luZywgQkFTRV9WQUxVRVMucmFkaXVzQSwgQkFTRV9WQUxVRVMucmFkaXVzQl1cbiAgKTtcblxuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICB7LyogRGVidWcgY29sb3JlZCBwbGFuZSB0byB2ZXJpZnkgcmVuZGVyaW5nICovfVxuICAgICAge2RlYnVnICYmIChcbiAgICAgICAgPG1lc2ggcmVmPXtkZWJ1Z01lc2hSZWZ9IHBvc2l0aW9uPXtbMCwgMCwgLTAuMl19PlxuICAgICAgICAgIDxwbGFuZUdlb21ldHJ5IGFyZ3M9e1tjb25uZWN0b3JQbGFuZVNpemUsIGNvbm5lY3RvclBsYW5lU2l6ZV19IC8+XG4gICAgICAgICAgPG1lc2hCYXNpY01hdGVyaWFsIGNvbG9yPVwiYmx1ZVwiIG9wYWNpdHk9ezAuMX0gdHJhbnNwYXJlbnQgLz5cbiAgICAgICAgPC9tZXNoPlxuICAgICAgKX1cblxuICAgICAgey8qIFNpbXBsZSBjb25uZWN0b3IgZm9yIGRlYnVnZ2luZyAoaGlnaGVyIHotaW5kZXggc28gaXQncyB2aXNpYmxlKSAqL31cbiAgICAgIDxtZXNoIHJlZj17c2ltcGxlQ29ubmVjdG9yTWVzaFJlZn0gcG9zaXRpb249e1swLCAwLCAwLjFdfSB2aXNpYmxlPXtzaG93U2ltcGxlfT5cbiAgICAgICAgPHBsYW5lR2VvbWV0cnkgYXJncz17W2Nvbm5lY3RvclBsYW5lU2l6ZSwgY29ubmVjdG9yUGxhbmVTaXplXX0gLz5cbiAgICAgICAgPHNpbXBsZUNvbm5lY3Rvck1hdGVyaWFsXG4gICAgICAgICAgcmVmPXtzaW1wbGVDb25uZWN0b3JNYXRlcmlhbFJlZn1cbiAgICAgICAgICBrZXk9e1NpbXBsZUNvbm5lY3Rvck1hdGVyaWFsLmtleX1cbiAgICAgICAgICB0cmFuc3BhcmVudD17dHJ1ZX1cbiAgICAgICAgICBkZXB0aFRlc3Q9e2ZhbHNlfVxuICAgICAgICAvPlxuICAgICAgPC9tZXNoPlxuXG4gICAgICB7LyogQWRkIG9yaWdpbmFsIGNvbm5lY3RvciBtZXNoIGZvciB0aGUgc2hhcGVzIGJldHdlZW4gY2lyY2xlcyAqL31cbiAgICAgIDxtZXNoIHJlZj17Y29ubmVjdG9yTWVzaFJlZn0gcG9zaXRpb249e1swLCAwLCAtMC4xXX0gdmlzaWJsZT17IXNob3dTaW1wbGV9PlxuICAgICAgICA8cGxhbmVHZW9tZXRyeSBhcmdzPXtbY29ubmVjdG9yUGxhbmVTaXplLCBjb25uZWN0b3JQbGFuZVNpemVdfSAvPlxuICAgICAgICA8Z3JpZENvbm5lY3Rvck1hdGVyaWFsXG4gICAgICAgICAgcmVmPXtncmlkQ29ubmVjdG9yTWF0ZXJpYWxSZWZ9XG4gICAgICAgICAga2V5PXtHcmlkQ29ubmVjdG9yTWF0ZXJpYWwua2V5fVxuICAgICAgICAgIHRyYW5zcGFyZW50PXt0cnVlfVxuICAgICAgICAgIGRlcHRoVGVzdD17ZmFsc2V9XG4gICAgICAgIC8+XG4gICAgICA8L21lc2g+XG5cbiAgICAgIHsvKiBDaXJjbGVzICovfVxuICAgICAgPGluc3RhbmNlZE1lc2hcbiAgICAgICAgcmVmPXtpbnN0YW5jZWRNZXNoUmVmfVxuICAgICAgICBhcmdzPXtbbnVsbCwgbnVsbCwgVE9UQUxfSU5TVEFOQ0VTXX1cbiAgICAgICAgb25DbGljaz17aGFuZGxlQ2xpY2t9XG4gICAgICAgIHBvc2l0aW9uPXtbMCwgMCwgMF19XG4gICAgICA+XG4gICAgICAgIDxwbGFuZUdlb21ldHJ5IGFyZ3M9e1tjb25uZWN0b3JQbGFuZVNpemUsIGNvbm5lY3RvclBsYW5lU2l6ZV19PlxuICAgICAgICAgIDxpbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgXG4gICAgICAgICAgICBhdHRhY2g9XCJhdHRyaWJ1dGVzLWFfaW5zdGFuY2VTaG93SW5uZXJcIiBcbiAgICAgICAgICAgIGFyZ3M9e1tpbnN0YW5jZVNob3dJbm5lciwgMV19IFxuICAgICAgICAgIC8+XG4gICAgICAgICAgPGluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSBcbiAgICAgICAgICAgIGF0dGFjaD1cImF0dHJpYnV0ZXMtYV9pbnN0YW5jZVNob3dPdXRlclwiIFxuICAgICAgICAgICAgYXJncz17W2luc3RhbmNlU2hvd091dGVyLCAxXX0gXG4gICAgICAgICAgLz5cbiAgICAgICAgPC9wbGFuZUdlb21ldHJ5PlxuICAgICAgICA8Y29ubmVjdG9yTWF0ZXJpYWxcbiAgICAgICAgICByZWY9e21hdGVyaWFsUmVmfVxuICAgICAgICAgIGtleT17Q29ubmVjdG9yTWF0ZXJpYWwua2V5fVxuICAgICAgICAgIHRyYW5zcGFyZW50PXt0cnVlfVxuICAgICAgICAvPlxuICAgICAgPC9pbnN0YW5jZWRNZXNoPlxuXG4gICAgICB7LyogR3JpZCBsaW5lcyB0aGF0IG1hdGNoIHRoZSBncmlkIHNwYWNpbmcgKi99XG4gICAgICA8Z3JvdXAgcmVmPXtncmlkSGVscGVyUmVmfSBwb3NpdGlvbj17WzAsIDAsIC0wLjJdfT5cbiAgICAgICAgPGdyaWRIZWxwZXIgXG4gICAgICAgICAgYXJncz17WzEwLCAxMF19IFxuICAgICAgICAgIHJvdGF0aW9uPXtbTWF0aC5QSSAvIDIsIDAsIDBdfVxuICAgICAgICAvPlxuICAgICAgPC9ncm91cD5cbiAgICA8Lz5cbiAgKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gV2ViR0xDYW52YXMoKSB7XG4gIHJldHVybiAoXG4gICAgLy8gU2V0IHVwIHRoZSBSM0YgQ2FudmFzXG4gICAgPENhbnZhcyBzdHlsZT17eyBiYWNrZ3JvdW5kOiAnI2YwZjBmMCcgfX0+XG4gICAgICB7LyogT3J0aG9ncmFwaGljIGNhbWVyYSBmb3IgdHJ1ZSAyRCB2aWV3ICovfVxuICAgICAgPE9ydGhvZ3JhcGhpY0NhbWVyYSBcbiAgICAgICAgbWFrZURlZmF1bHQgXG4gICAgICAgIHpvb209ezEwMH0gXG4gICAgICAgIHBvc2l0aW9uPXtbMCwgMCwgNV19IFxuICAgICAgICByb3RhdGlvbj17WzAsIDAsIDBdfVxuICAgICAgLz5cbiAgICAgIDxhbWJpZW50TGlnaHQgaW50ZW5zaXR5PXswLjh9IC8+XG4gICAgICA8U2NlbmUgLz5cbiAgICA8L0NhbnZhcz5cbiAgKTtcbn0gIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlUmVmIiwidXNlTWVtbyIsInVzZUVmZmVjdCIsInVzZVN0YXRlIiwiQ2FudmFzIiwidXNlRnJhbWUiLCJleHRlbmQiLCJ1c2VUaHJlZSIsIk9ydGhvZ3JhcGhpY0NhbWVyYSIsIlRIUkVFIiwidXNlQ29udHJvbHMiLCJmb2xkZXIiLCJidXR0b24iLCJDb25uZWN0b3JNYXRlcmlhbCIsIkdyaWRDb25uZWN0b3JNYXRlcmlhbCIsIlNpbXBsZUNvbm5lY3Rvck1hdGVyaWFsIiwiR1JJRF9TSVpFIiwiVE9UQUxfSU5TVEFOQ0VTIiwiZ2V0SW5zdGFuY2VJZCIsInJvdyIsImNvbCIsImdldEdyaWRDb29yZHMiLCJpZCIsIk1hdGgiLCJmbG9vciIsImR1bW15IiwiT2JqZWN0M0QiLCJCQVNFX1ZBTFVFUyIsInJhZGl1c0IiLCJyYWRpdXNBIiwiYm94U2l6ZSIsImJhc2VTcGFjaW5nIiwiU2NlbmUiLCJncmlkU3BhY2luZyIsInpvb20iLCJkZWJ1ZyIsInNob3dTaW1wbGUiLCJ2YWx1ZSIsIm1pbiIsIm1heCIsInN0ZXAiLCJsYWJlbCIsInNjYWxlRmFjdG9yIiwic2NhbGVkUmFkaXVzQiIsInRvRml4ZWQiLCJzY2FsZWRSYWRpdXNBIiwic2NhbGVkQm94U2l6ZSIsImlubmVyUmFkaXVzIiwiZGlzYWJsZWQiLCJvdXRlclJhZGl1cyIsImdyaWRTdGF0ZSIsInNldEdyaWRTdGF0ZSIsInNob3dJbm5lciIsInNob3dPdXRlciIsIm1hdGVyaWFsUmVmIiwiaW5zdGFuY2VkTWVzaFJlZiIsImdyaWRIZWxwZXJSZWYiLCJjYW1lcmFSZWYiLCJncmlkQ29ubmVjdG9yTWF0ZXJpYWxSZWYiLCJjb25uZWN0b3JNZXNoUmVmIiwiZGVidWdNZXNoUmVmIiwic2ltcGxlQ29ubmVjdG9yTWF0ZXJpYWxSZWYiLCJzaW1wbGVDb25uZWN0b3JNZXNoUmVmIiwiaW5zdGFuY2VTaG93SW5uZXIiLCJGbG9hdDMyQXJyYXkiLCJpbnN0YW5jZVNob3dPdXRlciIsImluc3RhbmNlUG9zaXRpb25zIiwiQXJyYXkiLCJmaWxsIiwibWFwIiwiVmVjdG9yMyIsImNhbWVyYSIsInJheWNhc3RlciIsIm1vdXNlIiwiY29uc29sZSIsImxvZyIsImdyaWRTdGF0ZVRleHR1cmUiLCJkYXRhIiwidGV4dHVyZSIsIkRhdGFUZXh0dXJlIiwiUkdCQUZvcm1hdCIsIkZsb2F0VHlwZSIsIm5lZWRzVXBkYXRlIiwiaW1hZ2UiLCJpZHgiLCJjdXJyZW50IiwidW5pZm9ybXMiLCJ1X3JhZGl1c0IiLCJ1X3JhZGl1c0EiLCJ1X3NwYWNpbmciLCJ1X2dyaWRTdGF0ZSIsInVfdGhpY2tuZXNzIiwidV9jdXJ2YXR1cmUiLCJ1X2JveFNpemUiLCJ1cGRhdGVQcm9qZWN0aW9uTWF0cml4IiwiaW5zdGFuY2VJZCIsInN0YXJ0T2Zmc2V0IiwieCIsInkiLCJwb3NpdGlvbiIsInNldCIsInVwZGF0ZU1hdHJpeCIsInNldE1hdHJpeEF0IiwibWF0cml4IiwiZ2VvbWV0cnkiLCJhdHRyaWJ1dGVzIiwiYV9pbnN0YW5jZVNob3dJbm5lciIsImFfaW5zdGFuY2VTaG93T3V0ZXIiLCJpbnN0YW5jZU1hdHJpeCIsInNjYWxlIiwiaGFuZGxlQ2xpY2siLCJldmVudCIsInVuZGVmaW5lZCIsImN1cnJlbnRTdGF0ZSIsImluc3RhbmNlUG9zaXRpb24iLCJwb2ludENvcHkiLCJwb2ludCIsImNsb25lIiwiZGlzdEZyb21DZW50ZXIiLCJkaXN0YW5jZVRvIiwibmV3SW5uZXIiLCJuZXdPdXRlciIsInByZXZTdGF0ZSIsIm5ld1N0YXRlIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5IiwiY29ubmVjdG9yUGxhbmVTaXplIiwibWVzaCIsInJlZiIsInBsYW5lR2VvbWV0cnkiLCJhcmdzIiwibWVzaEJhc2ljTWF0ZXJpYWwiLCJjb2xvciIsIm9wYWNpdHkiLCJ0cmFuc3BhcmVudCIsInZpc2libGUiLCJzaW1wbGVDb25uZWN0b3JNYXRlcmlhbCIsImRlcHRoVGVzdCIsImtleSIsImdyaWRDb25uZWN0b3JNYXRlcmlhbCIsImluc3RhbmNlZE1lc2giLCJvbkNsaWNrIiwiaW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlIiwiYXR0YWNoIiwiY29ubmVjdG9yTWF0ZXJpYWwiLCJncm91cCIsImdyaWRIZWxwZXIiLCJyb3RhdGlvbiIsIlBJIiwiV2ViR0xDYW52YXMiLCJzdHlsZSIsImJhY2tncm91bmQiLCJtYWtlRGVmYXVsdCIsImFtYmllbnRMaWdodCIsImludGVuc2l0eSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./components/WebGLCanvas.js\n");

/***/ })

};
;