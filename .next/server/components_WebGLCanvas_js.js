"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "components_WebGLCanvas_js";
exports.ids = ["components_WebGLCanvas_js"];
exports.modules = {

/***/ "./components/ConnectorMaterial.js":
/*!*****************************************!*\
  !*** ./components/ConnectorMaterial.js ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConnectorMaterial: () => (/* binding */ ConnectorMaterial)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-three/drei */ \"@react-three/drei\");\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_react_three_drei__WEBPACK_IMPORTED_MODULE_1__);\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([three__WEBPACK_IMPORTED_MODULE_0__]);\nthree__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n// Define uniforms and shader code\n// Adapted for InstancedMesh with matrix-based positioning\nconst ConnectorMaterial = (0,_react_three_drei__WEBPACK_IMPORTED_MODULE_1__.shaderMaterial)(// Uniforms (global settings)\n{\n    u_radiusB: 0.4,\n    u_radiusA: 0.5,\n    u_spacing: 1.5,\n    u_resolution: new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(1, 1)\n}, // Vertex Shader - Pass instance visibility and world center\n/*glsl*/ `\n    // Instance attributes\n    attribute float a_instanceShowInner;\n    attribute float a_instanceShowOuter;\n\n    // Varyings to pass data to fragment shader\n    varying vec2 vUv;\n    varying vec2 vWorldPos;\n    varying vec2 vInstanceCenterWorld; // Pass instance center in world space\n    varying float v_showInner;\n    varying float v_showOuter;\n\n    void main() {\n      vUv = uv;\n      v_showInner = a_instanceShowInner;\n      v_showOuter = a_instanceShowOuter;\n\n      // World position of the vertex\n      vec4 worldPos = instanceMatrix * vec4(position, 1.0);\n      vWorldPos = worldPos.xy;\n      \n      // World position of the instance center (origin of the instance's local space)\n      vec4 instanceCenterWorld = instanceMatrix * vec4(0.0, 0.0, 0.0, 1.0);\n      vInstanceCenterWorld = instanceCenterWorld.xy;\n      \n      gl_Position = projectionMatrix * modelViewMatrix * worldPos;\n    }\n  `, // Fragment Shader - Use instance visibility and world center\n/*glsl*/ `\n    varying vec2 vUv;\n    varying vec2 vWorldPos;\n    varying vec2 vInstanceCenterWorld;\n    varying float v_showInner;\n    varying float v_showOuter;\n\n    uniform float u_radiusB; // Inner circle radius\n    uniform float u_radiusA; // Outer circle radius\n    uniform float u_spacing;\n    uniform vec2 u_resolution;\n\n    void main() {\n      // Calculate distance from pixel's world position to the instance's world center\n      float dist = length(vWorldPos - vInstanceCenterWorld);\n      \n      // Signed distance field for inner circle (radiusB)\n      float innerCircleSDF = dist - u_radiusB;\n      \n      // Signed distance field for outer circle (radiusA)\n      float outerCircleSDF = dist - u_radiusA;\n      \n      // Edge width for anti-aliasing\n      float edgeWidth = 0.01;\n      \n      // Line width for outlines\n      float lineWidth = 0.01;\n      \n      // Inner circle - use v_showInner (attribute)\n      float innerAlpha = 0.0;\n      bool isInnerVisible = v_showInner > 0.5;\n      if (isInnerVisible) {\n        // Full circle\n        innerAlpha = 1.0 - smoothstep(-edgeWidth, edgeWidth, innerCircleSDF);\n      } else {\n        // Just an outline\n        innerAlpha = (1.0 - smoothstep(-lineWidth/2.0, lineWidth/2.0, abs(innerCircleSDF) - lineWidth/2.0)) * 0.8;\n      }\n      \n      // Outer circle - use v_showOuter (attribute)\n      float ringAlpha = 0.0;\n      bool isOuterVisible = v_showOuter > 0.5;\n      // Always render outer circle as outline only, never filled\n      ringAlpha = (1.0 - smoothstep(-lineWidth/2.0, lineWidth/2.0, abs(outerCircleSDF) - lineWidth/2.0)) * 0.8;\n      \n      // Combine both shapes\n      float finalAlpha = max(innerAlpha, ringAlpha * 0.7);\n      \n      // If nearly transparent, discard the pixel\n      if (finalAlpha < 0.01) discard;\n      \n      // Create different colors based on instance visibility\n      vec3 innerColor = isInnerVisible ? vec3(0.0) : vec3(0.3); // Black when on, gray when outline\n      vec3 ringColor = vec3(0.5);  // Always light gray for outer circle outline\n      \n      // Determine final color\n      vec3 color = vec3(1.0); // Default white (shouldn't be visible)\n      if(abs(innerCircleSDF) < lineWidth / 2.0 + edgeWidth && !isInnerVisible) {\n        color = innerColor; // Inner outline\n      } else if (abs(outerCircleSDF) < lineWidth / 2.0 + edgeWidth) {\n         color = ringColor; // Outer outline - always render as outline\n      } else if (innerCircleSDF < 0.0 && isInnerVisible) {\n        color = innerColor; // Inner fill\n      } \n      // Removed the else if for outer circle fill since we never want it filled\n\n      // Output with calculated alpha\n      gl_FragColor = vec4(color, finalAlpha);\n    }\n  `);\n// Add a unique key for HMR purposes with R3F\nConnectorMaterial.key = three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.generateUUID();\n\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL0Nvbm5lY3Rvck1hdGVyaWFsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBK0I7QUFDb0I7QUFFbkQsa0NBQWtDO0FBQ2xDLDBEQUEwRDtBQUUxRCxNQUFNRSxvQkFBb0JELGlFQUFjQSxDQUN0Qyw2QkFBNkI7QUFDN0I7SUFDRUUsV0FBVztJQUNYQyxXQUFXO0lBQ1hDLFdBQVc7SUFDWEMsY0FBYyxJQUFJTiwwQ0FBYSxDQUFDLEdBQUc7QUFDckMsR0FDQSw0REFBNEQ7QUFDNUQsTUFBTSxHQUFFLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQTJCVCxDQUFDLEVBQ0QsNkRBQTZEO0FBQzdELE1BQU0sR0FBRSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFxRVQsQ0FBQztBQUdILDZDQUE2QztBQUM3Q0Usa0JBQWtCTSxHQUFHLEdBQUdSLDRDQUFlLENBQUNVLFlBQVk7QUFFdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWJnbC1kb3QtZ3JpZC1tdnAvLi9jb21wb25lbnRzL0Nvbm5lY3Rvck1hdGVyaWFsLmpzPzQxNDIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgc2hhZGVyTWF0ZXJpYWwgfSBmcm9tICdAcmVhY3QtdGhyZWUvZHJlaSc7XG5cbi8vIERlZmluZSB1bmlmb3JtcyBhbmQgc2hhZGVyIGNvZGVcbi8vIEFkYXB0ZWQgZm9yIEluc3RhbmNlZE1lc2ggd2l0aCBtYXRyaXgtYmFzZWQgcG9zaXRpb25pbmdcblxuY29uc3QgQ29ubmVjdG9yTWF0ZXJpYWwgPSBzaGFkZXJNYXRlcmlhbChcbiAgLy8gVW5pZm9ybXMgKGdsb2JhbCBzZXR0aW5ncylcbiAge1xuICAgIHVfcmFkaXVzQjogMC40LCAvLyBJbm5lciBjaXJjbGUgcmFkaXVzXG4gICAgdV9yYWRpdXNBOiAwLjUsIC8vIE91dGVyIGNpcmNsZSByYWRpdXNcbiAgICB1X3NwYWNpbmc6IDEuNSxcbiAgICB1X3Jlc29sdXRpb246IG5ldyBUSFJFRS5WZWN0b3IyKDEsIDEpLFxuICB9LFxuICAvLyBWZXJ0ZXggU2hhZGVyIC0gUGFzcyBpbnN0YW5jZSB2aXNpYmlsaXR5IGFuZCB3b3JsZCBjZW50ZXJcbiAgLypnbHNsKi9gXG4gICAgLy8gSW5zdGFuY2UgYXR0cmlidXRlc1xuICAgIGF0dHJpYnV0ZSBmbG9hdCBhX2luc3RhbmNlU2hvd0lubmVyO1xuICAgIGF0dHJpYnV0ZSBmbG9hdCBhX2luc3RhbmNlU2hvd091dGVyO1xuXG4gICAgLy8gVmFyeWluZ3MgdG8gcGFzcyBkYXRhIHRvIGZyYWdtZW50IHNoYWRlclxuICAgIHZhcnlpbmcgdmVjMiB2VXY7XG4gICAgdmFyeWluZyB2ZWMyIHZXb3JsZFBvcztcbiAgICB2YXJ5aW5nIHZlYzIgdkluc3RhbmNlQ2VudGVyV29ybGQ7IC8vIFBhc3MgaW5zdGFuY2UgY2VudGVyIGluIHdvcmxkIHNwYWNlXG4gICAgdmFyeWluZyBmbG9hdCB2X3Nob3dJbm5lcjtcbiAgICB2YXJ5aW5nIGZsb2F0IHZfc2hvd091dGVyO1xuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgdlV2ID0gdXY7XG4gICAgICB2X3Nob3dJbm5lciA9IGFfaW5zdGFuY2VTaG93SW5uZXI7XG4gICAgICB2X3Nob3dPdXRlciA9IGFfaW5zdGFuY2VTaG93T3V0ZXI7XG5cbiAgICAgIC8vIFdvcmxkIHBvc2l0aW9uIG9mIHRoZSB2ZXJ0ZXhcbiAgICAgIHZlYzQgd29ybGRQb3MgPSBpbnN0YW5jZU1hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XG4gICAgICB2V29ybGRQb3MgPSB3b3JsZFBvcy54eTtcbiAgICAgIFxuICAgICAgLy8gV29ybGQgcG9zaXRpb24gb2YgdGhlIGluc3RhbmNlIGNlbnRlciAob3JpZ2luIG9mIHRoZSBpbnN0YW5jZSdzIGxvY2FsIHNwYWNlKVxuICAgICAgdmVjNCBpbnN0YW5jZUNlbnRlcldvcmxkID0gaW5zdGFuY2VNYXRyaXggKiB2ZWM0KDAuMCwgMC4wLCAwLjAsIDEuMCk7XG4gICAgICB2SW5zdGFuY2VDZW50ZXJXb3JsZCA9IGluc3RhbmNlQ2VudGVyV29ybGQueHk7XG4gICAgICBcbiAgICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHdvcmxkUG9zO1xuICAgIH1cbiAgYCxcbiAgLy8gRnJhZ21lbnQgU2hhZGVyIC0gVXNlIGluc3RhbmNlIHZpc2liaWxpdHkgYW5kIHdvcmxkIGNlbnRlclxuICAvKmdsc2wqL2BcbiAgICB2YXJ5aW5nIHZlYzIgdlV2O1xuICAgIHZhcnlpbmcgdmVjMiB2V29ybGRQb3M7XG4gICAgdmFyeWluZyB2ZWMyIHZJbnN0YW5jZUNlbnRlcldvcmxkO1xuICAgIHZhcnlpbmcgZmxvYXQgdl9zaG93SW5uZXI7XG4gICAgdmFyeWluZyBmbG9hdCB2X3Nob3dPdXRlcjtcblxuICAgIHVuaWZvcm0gZmxvYXQgdV9yYWRpdXNCOyAvLyBJbm5lciBjaXJjbGUgcmFkaXVzXG4gICAgdW5pZm9ybSBmbG9hdCB1X3JhZGl1c0E7IC8vIE91dGVyIGNpcmNsZSByYWRpdXNcbiAgICB1bmlmb3JtIGZsb2F0IHVfc3BhY2luZztcbiAgICB1bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uO1xuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgLy8gQ2FsY3VsYXRlIGRpc3RhbmNlIGZyb20gcGl4ZWwncyB3b3JsZCBwb3NpdGlvbiB0byB0aGUgaW5zdGFuY2UncyB3b3JsZCBjZW50ZXJcbiAgICAgIGZsb2F0IGRpc3QgPSBsZW5ndGgodldvcmxkUG9zIC0gdkluc3RhbmNlQ2VudGVyV29ybGQpO1xuICAgICAgXG4gICAgICAvLyBTaWduZWQgZGlzdGFuY2UgZmllbGQgZm9yIGlubmVyIGNpcmNsZSAocmFkaXVzQilcbiAgICAgIGZsb2F0IGlubmVyQ2lyY2xlU0RGID0gZGlzdCAtIHVfcmFkaXVzQjtcbiAgICAgIFxuICAgICAgLy8gU2lnbmVkIGRpc3RhbmNlIGZpZWxkIGZvciBvdXRlciBjaXJjbGUgKHJhZGl1c0EpXG4gICAgICBmbG9hdCBvdXRlckNpcmNsZVNERiA9IGRpc3QgLSB1X3JhZGl1c0E7XG4gICAgICBcbiAgICAgIC8vIEVkZ2Ugd2lkdGggZm9yIGFudGktYWxpYXNpbmdcbiAgICAgIGZsb2F0IGVkZ2VXaWR0aCA9IDAuMDE7XG4gICAgICBcbiAgICAgIC8vIExpbmUgd2lkdGggZm9yIG91dGxpbmVzXG4gICAgICBmbG9hdCBsaW5lV2lkdGggPSAwLjAxO1xuICAgICAgXG4gICAgICAvLyBJbm5lciBjaXJjbGUgLSB1c2Ugdl9zaG93SW5uZXIgKGF0dHJpYnV0ZSlcbiAgICAgIGZsb2F0IGlubmVyQWxwaGEgPSAwLjA7XG4gICAgICBib29sIGlzSW5uZXJWaXNpYmxlID0gdl9zaG93SW5uZXIgPiAwLjU7XG4gICAgICBpZiAoaXNJbm5lclZpc2libGUpIHtcbiAgICAgICAgLy8gRnVsbCBjaXJjbGVcbiAgICAgICAgaW5uZXJBbHBoYSA9IDEuMCAtIHNtb290aHN0ZXAoLWVkZ2VXaWR0aCwgZWRnZVdpZHRoLCBpbm5lckNpcmNsZVNERik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBKdXN0IGFuIG91dGxpbmVcbiAgICAgICAgaW5uZXJBbHBoYSA9ICgxLjAgLSBzbW9vdGhzdGVwKC1saW5lV2lkdGgvMi4wLCBsaW5lV2lkdGgvMi4wLCBhYnMoaW5uZXJDaXJjbGVTREYpIC0gbGluZVdpZHRoLzIuMCkpICogMC44O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBPdXRlciBjaXJjbGUgLSB1c2Ugdl9zaG93T3V0ZXIgKGF0dHJpYnV0ZSlcbiAgICAgIGZsb2F0IHJpbmdBbHBoYSA9IDAuMDtcbiAgICAgIGJvb2wgaXNPdXRlclZpc2libGUgPSB2X3Nob3dPdXRlciA+IDAuNTtcbiAgICAgIC8vIEFsd2F5cyByZW5kZXIgb3V0ZXIgY2lyY2xlIGFzIG91dGxpbmUgb25seSwgbmV2ZXIgZmlsbGVkXG4gICAgICByaW5nQWxwaGEgPSAoMS4wIC0gc21vb3Roc3RlcCgtbGluZVdpZHRoLzIuMCwgbGluZVdpZHRoLzIuMCwgYWJzKG91dGVyQ2lyY2xlU0RGKSAtIGxpbmVXaWR0aC8yLjApKSAqIDAuODtcbiAgICAgIFxuICAgICAgLy8gQ29tYmluZSBib3RoIHNoYXBlc1xuICAgICAgZmxvYXQgZmluYWxBbHBoYSA9IG1heChpbm5lckFscGhhLCByaW5nQWxwaGEgKiAwLjcpO1xuICAgICAgXG4gICAgICAvLyBJZiBuZWFybHkgdHJhbnNwYXJlbnQsIGRpc2NhcmQgdGhlIHBpeGVsXG4gICAgICBpZiAoZmluYWxBbHBoYSA8IDAuMDEpIGRpc2NhcmQ7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBkaWZmZXJlbnQgY29sb3JzIGJhc2VkIG9uIGluc3RhbmNlIHZpc2liaWxpdHlcbiAgICAgIHZlYzMgaW5uZXJDb2xvciA9IGlzSW5uZXJWaXNpYmxlID8gdmVjMygwLjApIDogdmVjMygwLjMpOyAvLyBCbGFjayB3aGVuIG9uLCBncmF5IHdoZW4gb3V0bGluZVxuICAgICAgdmVjMyByaW5nQ29sb3IgPSB2ZWMzKDAuNSk7ICAvLyBBbHdheXMgbGlnaHQgZ3JheSBmb3Igb3V0ZXIgY2lyY2xlIG91dGxpbmVcbiAgICAgIFxuICAgICAgLy8gRGV0ZXJtaW5lIGZpbmFsIGNvbG9yXG4gICAgICB2ZWMzIGNvbG9yID0gdmVjMygxLjApOyAvLyBEZWZhdWx0IHdoaXRlIChzaG91bGRuJ3QgYmUgdmlzaWJsZSlcbiAgICAgIGlmKGFicyhpbm5lckNpcmNsZVNERikgPCBsaW5lV2lkdGggLyAyLjAgKyBlZGdlV2lkdGggJiYgIWlzSW5uZXJWaXNpYmxlKSB7XG4gICAgICAgIGNvbG9yID0gaW5uZXJDb2xvcjsgLy8gSW5uZXIgb3V0bGluZVxuICAgICAgfSBlbHNlIGlmIChhYnMob3V0ZXJDaXJjbGVTREYpIDwgbGluZVdpZHRoIC8gMi4wICsgZWRnZVdpZHRoKSB7XG4gICAgICAgICBjb2xvciA9IHJpbmdDb2xvcjsgLy8gT3V0ZXIgb3V0bGluZSAtIGFsd2F5cyByZW5kZXIgYXMgb3V0bGluZVxuICAgICAgfSBlbHNlIGlmIChpbm5lckNpcmNsZVNERiA8IDAuMCAmJiBpc0lubmVyVmlzaWJsZSkge1xuICAgICAgICBjb2xvciA9IGlubmVyQ29sb3I7IC8vIElubmVyIGZpbGxcbiAgICAgIH0gXG4gICAgICAvLyBSZW1vdmVkIHRoZSBlbHNlIGlmIGZvciBvdXRlciBjaXJjbGUgZmlsbCBzaW5jZSB3ZSBuZXZlciB3YW50IGl0IGZpbGxlZFxuXG4gICAgICAvLyBPdXRwdXQgd2l0aCBjYWxjdWxhdGVkIGFscGhhXG4gICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLCBmaW5hbEFscGhhKTtcbiAgICB9XG4gIGBcbik7XG5cbi8vIEFkZCBhIHVuaXF1ZSBrZXkgZm9yIEhNUiBwdXJwb3NlcyB3aXRoIFIzRlxuQ29ubmVjdG9yTWF0ZXJpYWwua2V5ID0gVEhSRUUuTWF0aFV0aWxzLmdlbmVyYXRlVVVJRCgpO1xuXG5leHBvcnQgeyBDb25uZWN0b3JNYXRlcmlhbCB9OyAiXSwibmFtZXMiOlsiVEhSRUUiLCJzaGFkZXJNYXRlcmlhbCIsIkNvbm5lY3Rvck1hdGVyaWFsIiwidV9yYWRpdXNCIiwidV9yYWRpdXNBIiwidV9zcGFjaW5nIiwidV9yZXNvbHV0aW9uIiwiVmVjdG9yMiIsImtleSIsIk1hdGhVdGlscyIsImdlbmVyYXRlVVVJRCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./components/ConnectorMaterial.js\n");

/***/ }),

/***/ "./components/GridConnectorMaterial.js":
/*!*********************************************!*\
  !*** ./components/GridConnectorMaterial.js ***!
  \*********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GridConnectorMaterial: () => (/* binding */ GridConnectorMaterial)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-three/drei */ \"@react-three/drei\");\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_react_three_drei__WEBPACK_IMPORTED_MODULE_1__);\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([three__WEBPACK_IMPORTED_MODULE_0__]);\nthree__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n// This material handles the connector shapes between active points on the grid\nconst GridConnectorMaterial = (0,_react_three_drei__WEBPACK_IMPORTED_MODULE_1__.shaderMaterial)(// Uniforms\n{\n    u_radiusB: 0.4,\n    u_radiusA: 0.5,\n    u_spacing: 1.0,\n    u_thickness: 0.2,\n    u_curvature: 0.5,\n    u_resolution: new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(1, 1),\n    u_activeConnector: 0,\n    u_gridState: new three__WEBPACK_IMPORTED_MODULE_0__.DataTexture(new Float32Array(4), 2, 2, three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat, three__WEBPACK_IMPORTED_MODULE_0__.FloatType)\n}, // Vertex Shader\n/*glsl*/ `\n    varying vec2 vUv;\n    varying vec2 vWorldPos;\n\n    void main() {\n      vUv = uv;\n      \n      // World position of the vertex\n      vec4 worldPos = modelMatrix * vec4(position, 1.0);\n      vWorldPos = worldPos.xy;\n      \n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n  `, // Fragment Shader\n/*glsl*/ `\n    varying vec2 vUv;\n    varying vec2 vWorldPos;\n\n    uniform float u_radiusB; // Inner circle radius (black circle)\n    uniform float u_radiusA; // Outer circle radius (for connector shape)\n    uniform float u_spacing;\n    uniform float u_thickness; // Controls connector thickness\n    uniform float u_curvature; // Controls the curve shape\n    uniform vec2 u_resolution;\n    uniform float u_activeConnector; // 0 = none, 1 = red (AB), 2 = blue (CD), 3 = orange top row, 4 = orange bottom row\n    uniform sampler2D u_gridState;\n\n    // Helper function to get circle state from the grid state texture\n    vec4 getGridState(int row, int col) {\n      return texture2D(u_gridState, vec2(float(col) + 0.5, float(row) + 0.5) / 2.0);\n    }\n\n    // Helper function to calculate distance to a circle\n    float distToCircle(vec2 point, vec2 center) {\n      return length(point - center);\n    }\n\n    // Create a smooth minimum function to blend the connector\n    float smin(float a, float b, float k) {\n      float h = max(k - abs(a - b), 0.0) / k;\n      return min(a, b) - h * h * k * 0.25;\n    }\n\n    // Helper function for horizontal connector\n    bool isInHorizontalConnector(vec2 point, vec2 center1, vec2 center2, float radius) {\n      // Calculate rectangle bounds\n      float midY = (center1.y + center2.y) * 0.5;\n      float leftX = min(center1.x, center2.x);\n      float rightX = max(center1.x, center2.x);\n      \n      // Check if inside the rectangle\n      if (point.x >= leftX && point.x <= rightX && \n          point.y >= midY - radius && point.y <= midY + radius) {\n        return true;\n      }\n      \n      return false;\n    }\n\n    void main() {\n      // If no connector is active, discard immediately\n      if (u_activeConnector < 0.5) {\n        discard;\n        return;\n      }\n      \n      // Calculate grid positions (2x2 grid)\n      float gridOffset = u_spacing * 0.5;\n      vec2 center_A = vec2(-gridOffset, gridOffset);   // Top-left (A)\n      vec2 center_B = vec2(gridOffset, -gridOffset);   // Bottom-right (B)\n      vec2 center_C = vec2(-gridOffset, -gridOffset);  // Bottom-left (C)\n      vec2 center_D = vec2(gridOffset, gridOffset);    // Top-right (D)\n\n      // Calculate distances from current pixel to each circle center\n      float dist_A = distToCircle(vWorldPos, center_A);\n      float dist_B = distToCircle(vWorldPos, center_B);\n      float dist_C = distToCircle(vWorldPos, center_C);\n      float dist_D = distToCircle(vWorldPos, center_D);\n\n      // Get circle states\n      vec4 stateA = getGridState(0, 0); // Top-left\n      vec4 stateB = getGridState(1, 1); // Bottom-right\n      vec4 stateC = getGridState(1, 0); // Bottom-left\n      vec4 stateD = getGridState(0, 1); // Top-right\n\n      // Check if relevant circles are active \n      bool circleAInnerActive = stateA.r > 0.5; // Top-left inner circle\n      bool circleBInnerActive = stateB.r > 0.5; // Bottom-right inner circle\n      bool circleCInnerActive = stateC.r > 0.5; // Bottom-left inner circle\n      bool circleDInnerActive = stateD.r > 0.5; // Top-right inner circle\n      \n      // Determine connector type based on active connector state\n      bool drawABConnector = u_activeConnector == 1.0;\n      bool drawCDConnector = u_activeConnector == 2.0;\n      bool drawTopRowConnector = u_activeConnector == 3.0;\n      bool drawBottomRowConnector = u_activeConnector == 4.0;\n      \n      // Handle the horizontal connectors first (orange)\n      if (drawTopRowConnector) {\n        // Verify the required circles are active\n        if (!circleAInnerActive || !circleDInnerActive) {\n          discard;\n          return;\n        }\n        \n        // Check if we're outside the inner circles\n        if (dist_A <= u_radiusB || dist_D <= u_radiusB) {\n          discard;\n          return;\n        }\n        \n        // Check if the point is within the horizontal connector area\n        if (isInHorizontalConnector(vWorldPos, center_A, center_D, u_radiusB)) {\n          // Draw the horizontal connector\n          gl_FragColor = vec4(1.0, 0.5, 0.0, 1.0); // Orange for horizontal connector\n          return;\n        }\n        \n        discard;\n        return;\n      }\n      \n      if (drawBottomRowConnector) {\n        // Verify the required circles are active\n        if (!circleCInnerActive || !circleBInnerActive) {\n          discard;\n          return;\n        }\n        \n        // Check if we're outside the inner circles\n        if (dist_C <= u_radiusB || dist_B <= u_radiusB) {\n          discard;\n          return;\n        }\n        \n        // Check if the point is within the horizontal connector area\n        if (isInHorizontalConnector(vWorldPos, center_C, center_B, u_radiusB)) {\n          // Draw the horizontal connector\n          gl_FragColor = vec4(1.0, 0.5, 0.0, 1.0); // Orange for horizontal connector\n          return;\n        }\n        \n        discard;\n        return;\n      }\n      \n      // Handle diagonal connectors (original functionality)\n      // Verify the required circles are active for the selected connector\n      if (drawABConnector && (!circleAInnerActive || !circleBInnerActive)) {\n        discard;\n        return;\n      }\n      \n      if (drawCDConnector && (!circleCInnerActive || !circleDInnerActive)) {\n        discard;\n        return;\n      }\n      \n      // Distance fields for the inner black circles\n      float sdfA = dist_A - u_radiusB;\n      float sdfB = dist_B - u_radiusB;\n      float sdfC = dist_C - u_radiusB;\n      float sdfD = dist_D - u_radiusB;\n      \n      // We only continue if we're outside the relevant black circles\n      bool outsideRelevantCircles = true;\n      \n      if (drawABConnector) {\n        outsideRelevantCircles = (sdfA > 0.0) && (sdfB > 0.0);\n      }\n      \n      if (drawCDConnector) {\n        outsideRelevantCircles = (sdfC > 0.0) && (sdfD > 0.0);\n      }\n      \n      if (!outsideRelevantCircles) {\n        discard;\n        return;\n      }\n      \n      // Check if inside influence areas\n      bool insideInfluenceArea = false;\n      \n      if (drawABConnector) {\n        // For Red AB connector:\n        // Must be outside inner B circles (we already checked this with outsideRelevantCircles)\n        // Must be outside outer A circles (represented by the gray circles)\n        // Notice how we're checking if we're outside both outer A circles (C and D)\n        insideInfluenceArea = (dist_C > u_radiusA) && (dist_D > u_radiusA);\n      }\n      \n      if (drawCDConnector) {\n        // For Blue CD connector:\n        // Must be outside inner A circles (we already checked this with outsideRelevantCircles)\n        // Must be outside outer B circles (represented by the gray circles)\n        // Notice how we're checking if we're outside both outer B circles (A and B)\n        insideInfluenceArea = (dist_A > u_radiusA) && (dist_B > u_radiusA);\n      }\n      \n      if (!insideInfluenceArea) {\n        discard;\n        return;\n      }\n      \n      // Calculate vector between the active circles\n      vec2 activeDirection;\n      vec2 startCenter;\n      vec2 endCenter;\n      float distStart;\n      float distEnd;\n      \n      if (drawABConnector) {\n        activeDirection = center_B - center_A;\n        startCenter = center_A;\n        endCenter = center_B;\n        distStart = dist_A;\n        distEnd = dist_B;\n      }\n      \n      if (drawCDConnector) {\n        activeDirection = center_D - center_C;\n        startCenter = center_C;\n        endCenter = center_D;\n        distStart = dist_C;\n        distEnd = dist_D;\n      }\n      \n      // Continue with existing connector logic, but use the active centers\n      float lengthAB = length(activeDirection);\n      vec2 AB_normalized = activeDirection / lengthAB;\n      \n      // Project current point onto line\n      vec2 AP = vWorldPos - startCenter;\n      float projection = dot(AP, AB_normalized);\n      \n      // Create a field that represents the \"pathway\" between the two circles\n      // This creates a curved shape that narrows in the middle\n      float pathwayField;\n      \n      // For the first part of the curvature range, use distance-based shape\n      if (u_curvature < 0.5) {\n        // Method 1: Path with varying width based on projection along AB\n        \n        // Only proceed if the pixel is reasonably near the AB line\n        if (projection >= -u_radiusA && projection <= lengthAB + u_radiusA) {\n          // Calculate perpendicular distance from point to AB line\n          vec2 perpendicular = AP - projection * AB_normalized;\n          float perpDistance = length(perpendicular);\n          \n          // Base width based on thickness\n          float baseWidth = u_thickness * u_radiusA;\n          float midPoint = lengthAB * 0.5;\n          float distFromMid = abs(projection - midPoint);\n          \n          // Make narrower in middle based on curvature\n          float t = distFromMid / midPoint; // 0 at center, 1 at endpoints\n          float narrowingFactor = mix(0.5, 0.9, u_curvature * 2.0); // More narrow at higher curvature\n          float widthCurve = 1.0 - pow(t, 1.5) * narrowingFactor;\n          \n          // Calculate the adjusted width based on position\n          float adjustedWidth;\n          \n          if (projection < 0.0) {\n            // Near endpoint A - blend with circle\n            adjustedWidth = mix(u_radiusA * 0.8, baseWidth, 1.0 + projection / u_radiusA);\n          } else if (projection > lengthAB) {\n            // Near endpoint B - blend with circle\n            adjustedWidth = mix(u_radiusA * 0.8, baseWidth, 1.0 - (projection - lengthAB) / u_radiusA);\n          } else {\n            // Between endpoints - use curved width\n            adjustedWidth = baseWidth * widthCurve;\n          }\n          \n          // If within the adjusted width, we're in the connector\n          if (perpDistance < adjustedWidth) {\n            // Set color based on which connector is being drawn\n            if (drawABConnector) {\n              gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); // Red for AB connector\n            } else {\n              gl_FragColor = vec4(0.0, 0.5, 1.0, 1.0); // Blue for CD connector\n            }\n            return;\n          }\n        }\n      }\n      else {\n        // Method 2: Use hyperbolic distance field for higher curvature\n        // Normalize distances for better control\n        float d1 = max(0.0, distStart - u_radiusB) / u_radiusA; \n        float d2 = max(0.0, distEnd - u_radiusB) / u_radiusA;\n        \n        // Create hyperbolic field (product of distances)\n        pathwayField = d1 * d2;\n        \n        // Adjust field strength based on distance to make shape more compact\n        float distanceScale = 3.0 / lengthAB;\n        pathwayField *= distanceScale;\n        \n        // Thickness controls the threshold\n        float threshold = u_thickness * 0.2 * mix(1.0, 2.0, u_curvature - 0.5);\n        \n        // Check if within the field threshold\n        if (pathwayField < threshold) {\n          // Only show connector between the circles (not extending out the other sides)\n          float dotProductA = dot(AP, AB_normalized);\n          float dotProductB = dot(vWorldPos - endCenter, -AB_normalized);\n          \n          if (dotProductA >= -u_radiusB * 0.5 && dotProductB >= -u_radiusB * 0.5) {\n            // Set color based on which connector is being drawn\n            if (drawABConnector) {\n              gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); // Red for AB connector\n            } else {\n              gl_FragColor = vec4(0.0, 0.5, 1.0, 1.0); // Blue for CD connector\n            }\n            return;\n          }\n        }\n      }\n      \n      // If we got here, the pixel is outside the connector shape\n      discard;\n    }\n  `);\n// Add a unique key for HMR purposes with R3F\nGridConnectorMaterial.key = three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.generateUUID();\n\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL0dyaWRDb25uZWN0b3JNYXRlcmlhbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQStCO0FBQ29CO0FBRW5ELCtFQUErRTtBQUMvRSxNQUFNRSx3QkFBd0JELGlFQUFjQSxDQUMxQyxXQUFXO0FBQ1g7SUFDRUUsV0FBVztJQUNYQyxXQUFXO0lBQ1hDLFdBQVc7SUFDWEMsYUFBYTtJQUNiQyxhQUFhO0lBQ2JDLGNBQWMsSUFBSVIsMENBQWEsQ0FBQyxHQUFHO0lBQ25DVSxtQkFBbUI7SUFDbkJDLGFBQWEsSUFBSVgsOENBQWlCLENBQ2hDLElBQUlhLGFBQWEsSUFDakIsR0FDQSxHQUNBYiw2Q0FBZ0IsRUFDaEJBLDRDQUFlO0FBRW5CLEdBQ0EsZ0JBQWdCO0FBQ2hCLE1BQU0sR0FBRSxDQUFDOzs7Ozs7Ozs7Ozs7O0VBYVQsQ0FBQyxFQUNELGtCQUFrQjtBQUNsQixNQUFNLEdBQUUsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFvVFQsQ0FBQztBQUdILDZDQUE2QztBQUM3Q0Usc0JBQXNCYyxHQUFHLEdBQUdoQiw0Q0FBZSxDQUFDa0IsWUFBWTtBQUV2QiIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYmdsLWRvdC1ncmlkLW12cC8uL2NvbXBvbmVudHMvR3JpZENvbm5lY3Rvck1hdGVyaWFsLmpzP2IyMWQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgc2hhZGVyTWF0ZXJpYWwgfSBmcm9tICdAcmVhY3QtdGhyZWUvZHJlaSc7XG5cbi8vIFRoaXMgbWF0ZXJpYWwgaGFuZGxlcyB0aGUgY29ubmVjdG9yIHNoYXBlcyBiZXR3ZWVuIGFjdGl2ZSBwb2ludHMgb24gdGhlIGdyaWRcbmNvbnN0IEdyaWRDb25uZWN0b3JNYXRlcmlhbCA9IHNoYWRlck1hdGVyaWFsKFxuICAvLyBVbmlmb3Jtc1xuICB7XG4gICAgdV9yYWRpdXNCOiAwLjQsIC8vIElubmVyIGNpcmNsZSByYWRpdXMgKGJsYWNrIGNpcmNsZSlcbiAgICB1X3JhZGl1c0E6IDAuNSwgLy8gT3V0ZXIgY2lyY2xlIHJhZGl1cyAoZm9yIGNvbm5lY3RvciBzaGFwZSBjYWxjdWxhdGlvbilcbiAgICB1X3NwYWNpbmc6IDEuMCwgLy8gR3JpZCBzcGFjaW5nXG4gICAgdV90aGlja25lc3M6IDAuMiwgLy8gQ29ubmVjdG9yIHRoaWNrbmVzcyBjb250cm9sXG4gICAgdV9jdXJ2YXR1cmU6IDAuNSwgLy8gQ29udHJvbHMgdGhlIGN1cnZhdHVyZSBvZiB0aGUgY29ubmVjdG9yXG4gICAgdV9yZXNvbHV0aW9uOiBuZXcgVEhSRUUuVmVjdG9yMigxLCAxKSxcbiAgICB1X2FjdGl2ZUNvbm5lY3RvcjogMCwgLy8gMCA9IG5vbmUsIDEgPSByZWQgKEFCKSwgMiA9IGJsdWUgKENEKSwgMyA9IG9yYW5nZSB0b3Agcm93LCA0ID0gb3JhbmdlIGJvdHRvbSByb3dcbiAgICB1X2dyaWRTdGF0ZTogbmV3IFRIUkVFLkRhdGFUZXh0dXJlKCAvLyBXaWxsIHN0b3JlIGdyaWQgc3RhdGUgaW4gYSB0ZXh0dXJlXG4gICAgICBuZXcgRmxvYXQzMkFycmF5KDQpLCAvLyBSR0JBIHZhbHVlcyBwZXIgY2VsbFxuICAgICAgMiwgLy8gd2lkdGggKGZvciAyeDIgZ3JpZClcbiAgICAgIDIsIC8vIGhlaWdodCAoZm9yIDJ4MiBncmlkKVxuICAgICAgVEhSRUUuUkdCQUZvcm1hdCxcbiAgICAgIFRIUkVFLkZsb2F0VHlwZVxuICAgICksXG4gIH0sXG4gIC8vIFZlcnRleCBTaGFkZXJcbiAgLypnbHNsKi9gXG4gICAgdmFyeWluZyB2ZWMyIHZVdjtcbiAgICB2YXJ5aW5nIHZlYzIgdldvcmxkUG9zO1xuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgdlV2ID0gdXY7XG4gICAgICBcbiAgICAgIC8vIFdvcmxkIHBvc2l0aW9uIG9mIHRoZSB2ZXJ0ZXhcbiAgICAgIHZlYzQgd29ybGRQb3MgPSBtb2RlbE1hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XG4gICAgICB2V29ybGRQb3MgPSB3b3JsZFBvcy54eTtcbiAgICAgIFxuICAgICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTtcbiAgICB9XG4gIGAsXG4gIC8vIEZyYWdtZW50IFNoYWRlclxuICAvKmdsc2wqL2BcbiAgICB2YXJ5aW5nIHZlYzIgdlV2O1xuICAgIHZhcnlpbmcgdmVjMiB2V29ybGRQb3M7XG5cbiAgICB1bmlmb3JtIGZsb2F0IHVfcmFkaXVzQjsgLy8gSW5uZXIgY2lyY2xlIHJhZGl1cyAoYmxhY2sgY2lyY2xlKVxuICAgIHVuaWZvcm0gZmxvYXQgdV9yYWRpdXNBOyAvLyBPdXRlciBjaXJjbGUgcmFkaXVzIChmb3IgY29ubmVjdG9yIHNoYXBlKVxuICAgIHVuaWZvcm0gZmxvYXQgdV9zcGFjaW5nO1xuICAgIHVuaWZvcm0gZmxvYXQgdV90aGlja25lc3M7IC8vIENvbnRyb2xzIGNvbm5lY3RvciB0aGlja25lc3NcbiAgICB1bmlmb3JtIGZsb2F0IHVfY3VydmF0dXJlOyAvLyBDb250cm9scyB0aGUgY3VydmUgc2hhcGVcbiAgICB1bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uO1xuICAgIHVuaWZvcm0gZmxvYXQgdV9hY3RpdmVDb25uZWN0b3I7IC8vIDAgPSBub25lLCAxID0gcmVkIChBQiksIDIgPSBibHVlIChDRCksIDMgPSBvcmFuZ2UgdG9wIHJvdywgNCA9IG9yYW5nZSBib3R0b20gcm93XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdV9ncmlkU3RhdGU7XG5cbiAgICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IGNpcmNsZSBzdGF0ZSBmcm9tIHRoZSBncmlkIHN0YXRlIHRleHR1cmVcbiAgICB2ZWM0IGdldEdyaWRTdGF0ZShpbnQgcm93LCBpbnQgY29sKSB7XG4gICAgICByZXR1cm4gdGV4dHVyZTJEKHVfZ3JpZFN0YXRlLCB2ZWMyKGZsb2F0KGNvbCkgKyAwLjUsIGZsb2F0KHJvdykgKyAwLjUpIC8gMi4wKTtcbiAgICB9XG5cbiAgICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gY2FsY3VsYXRlIGRpc3RhbmNlIHRvIGEgY2lyY2xlXG4gICAgZmxvYXQgZGlzdFRvQ2lyY2xlKHZlYzIgcG9pbnQsIHZlYzIgY2VudGVyKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoKHBvaW50IC0gY2VudGVyKTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgYSBzbW9vdGggbWluaW11bSBmdW5jdGlvbiB0byBibGVuZCB0aGUgY29ubmVjdG9yXG4gICAgZmxvYXQgc21pbihmbG9hdCBhLCBmbG9hdCBiLCBmbG9hdCBrKSB7XG4gICAgICBmbG9hdCBoID0gbWF4KGsgLSBhYnMoYSAtIGIpLCAwLjApIC8gaztcbiAgICAgIHJldHVybiBtaW4oYSwgYikgLSBoICogaCAqIGsgKiAwLjI1O1xuICAgIH1cblxuICAgIC8vIEhlbHBlciBmdW5jdGlvbiBmb3IgaG9yaXpvbnRhbCBjb25uZWN0b3JcbiAgICBib29sIGlzSW5Ib3Jpem9udGFsQ29ubmVjdG9yKHZlYzIgcG9pbnQsIHZlYzIgY2VudGVyMSwgdmVjMiBjZW50ZXIyLCBmbG9hdCByYWRpdXMpIHtcbiAgICAgIC8vIENhbGN1bGF0ZSByZWN0YW5nbGUgYm91bmRzXG4gICAgICBmbG9hdCBtaWRZID0gKGNlbnRlcjEueSArIGNlbnRlcjIueSkgKiAwLjU7XG4gICAgICBmbG9hdCBsZWZ0WCA9IG1pbihjZW50ZXIxLngsIGNlbnRlcjIueCk7XG4gICAgICBmbG9hdCByaWdodFggPSBtYXgoY2VudGVyMS54LCBjZW50ZXIyLngpO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiBpbnNpZGUgdGhlIHJlY3RhbmdsZVxuICAgICAgaWYgKHBvaW50LnggPj0gbGVmdFggJiYgcG9pbnQueCA8PSByaWdodFggJiYgXG4gICAgICAgICAgcG9pbnQueSA+PSBtaWRZIC0gcmFkaXVzICYmIHBvaW50LnkgPD0gbWlkWSArIHJhZGl1cykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZvaWQgbWFpbigpIHtcbiAgICAgIC8vIElmIG5vIGNvbm5lY3RvciBpcyBhY3RpdmUsIGRpc2NhcmQgaW1tZWRpYXRlbHlcbiAgICAgIGlmICh1X2FjdGl2ZUNvbm5lY3RvciA8IDAuNSkge1xuICAgICAgICBkaXNjYXJkO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENhbGN1bGF0ZSBncmlkIHBvc2l0aW9ucyAoMngyIGdyaWQpXG4gICAgICBmbG9hdCBncmlkT2Zmc2V0ID0gdV9zcGFjaW5nICogMC41O1xuICAgICAgdmVjMiBjZW50ZXJfQSA9IHZlYzIoLWdyaWRPZmZzZXQsIGdyaWRPZmZzZXQpOyAgIC8vIFRvcC1sZWZ0IChBKVxuICAgICAgdmVjMiBjZW50ZXJfQiA9IHZlYzIoZ3JpZE9mZnNldCwgLWdyaWRPZmZzZXQpOyAgIC8vIEJvdHRvbS1yaWdodCAoQilcbiAgICAgIHZlYzIgY2VudGVyX0MgPSB2ZWMyKC1ncmlkT2Zmc2V0LCAtZ3JpZE9mZnNldCk7ICAvLyBCb3R0b20tbGVmdCAoQylcbiAgICAgIHZlYzIgY2VudGVyX0QgPSB2ZWMyKGdyaWRPZmZzZXQsIGdyaWRPZmZzZXQpOyAgICAvLyBUb3AtcmlnaHQgKEQpXG5cbiAgICAgIC8vIENhbGN1bGF0ZSBkaXN0YW5jZXMgZnJvbSBjdXJyZW50IHBpeGVsIHRvIGVhY2ggY2lyY2xlIGNlbnRlclxuICAgICAgZmxvYXQgZGlzdF9BID0gZGlzdFRvQ2lyY2xlKHZXb3JsZFBvcywgY2VudGVyX0EpO1xuICAgICAgZmxvYXQgZGlzdF9CID0gZGlzdFRvQ2lyY2xlKHZXb3JsZFBvcywgY2VudGVyX0IpO1xuICAgICAgZmxvYXQgZGlzdF9DID0gZGlzdFRvQ2lyY2xlKHZXb3JsZFBvcywgY2VudGVyX0MpO1xuICAgICAgZmxvYXQgZGlzdF9EID0gZGlzdFRvQ2lyY2xlKHZXb3JsZFBvcywgY2VudGVyX0QpO1xuXG4gICAgICAvLyBHZXQgY2lyY2xlIHN0YXRlc1xuICAgICAgdmVjNCBzdGF0ZUEgPSBnZXRHcmlkU3RhdGUoMCwgMCk7IC8vIFRvcC1sZWZ0XG4gICAgICB2ZWM0IHN0YXRlQiA9IGdldEdyaWRTdGF0ZSgxLCAxKTsgLy8gQm90dG9tLXJpZ2h0XG4gICAgICB2ZWM0IHN0YXRlQyA9IGdldEdyaWRTdGF0ZSgxLCAwKTsgLy8gQm90dG9tLWxlZnRcbiAgICAgIHZlYzQgc3RhdGVEID0gZ2V0R3JpZFN0YXRlKDAsIDEpOyAvLyBUb3AtcmlnaHRcblxuICAgICAgLy8gQ2hlY2sgaWYgcmVsZXZhbnQgY2lyY2xlcyBhcmUgYWN0aXZlIFxuICAgICAgYm9vbCBjaXJjbGVBSW5uZXJBY3RpdmUgPSBzdGF0ZUEuciA+IDAuNTsgLy8gVG9wLWxlZnQgaW5uZXIgY2lyY2xlXG4gICAgICBib29sIGNpcmNsZUJJbm5lckFjdGl2ZSA9IHN0YXRlQi5yID4gMC41OyAvLyBCb3R0b20tcmlnaHQgaW5uZXIgY2lyY2xlXG4gICAgICBib29sIGNpcmNsZUNJbm5lckFjdGl2ZSA9IHN0YXRlQy5yID4gMC41OyAvLyBCb3R0b20tbGVmdCBpbm5lciBjaXJjbGVcbiAgICAgIGJvb2wgY2lyY2xlRElubmVyQWN0aXZlID0gc3RhdGVELnIgPiAwLjU7IC8vIFRvcC1yaWdodCBpbm5lciBjaXJjbGVcbiAgICAgIFxuICAgICAgLy8gRGV0ZXJtaW5lIGNvbm5lY3RvciB0eXBlIGJhc2VkIG9uIGFjdGl2ZSBjb25uZWN0b3Igc3RhdGVcbiAgICAgIGJvb2wgZHJhd0FCQ29ubmVjdG9yID0gdV9hY3RpdmVDb25uZWN0b3IgPT0gMS4wO1xuICAgICAgYm9vbCBkcmF3Q0RDb25uZWN0b3IgPSB1X2FjdGl2ZUNvbm5lY3RvciA9PSAyLjA7XG4gICAgICBib29sIGRyYXdUb3BSb3dDb25uZWN0b3IgPSB1X2FjdGl2ZUNvbm5lY3RvciA9PSAzLjA7XG4gICAgICBib29sIGRyYXdCb3R0b21Sb3dDb25uZWN0b3IgPSB1X2FjdGl2ZUNvbm5lY3RvciA9PSA0LjA7XG4gICAgICBcbiAgICAgIC8vIEhhbmRsZSB0aGUgaG9yaXpvbnRhbCBjb25uZWN0b3JzIGZpcnN0IChvcmFuZ2UpXG4gICAgICBpZiAoZHJhd1RvcFJvd0Nvbm5lY3Rvcikge1xuICAgICAgICAvLyBWZXJpZnkgdGhlIHJlcXVpcmVkIGNpcmNsZXMgYXJlIGFjdGl2ZVxuICAgICAgICBpZiAoIWNpcmNsZUFJbm5lckFjdGl2ZSB8fCAhY2lyY2xlRElubmVyQWN0aXZlKSB7XG4gICAgICAgICAgZGlzY2FyZDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGlmIHdlJ3JlIG91dHNpZGUgdGhlIGlubmVyIGNpcmNsZXNcbiAgICAgICAgaWYgKGRpc3RfQSA8PSB1X3JhZGl1c0IgfHwgZGlzdF9EIDw9IHVfcmFkaXVzQikge1xuICAgICAgICAgIGRpc2NhcmQ7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgcG9pbnQgaXMgd2l0aGluIHRoZSBob3Jpem9udGFsIGNvbm5lY3RvciBhcmVhXG4gICAgICAgIGlmIChpc0luSG9yaXpvbnRhbENvbm5lY3Rvcih2V29ybGRQb3MsIGNlbnRlcl9BLCBjZW50ZXJfRCwgdV9yYWRpdXNCKSkge1xuICAgICAgICAgIC8vIERyYXcgdGhlIGhvcml6b250YWwgY29ubmVjdG9yXG4gICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgxLjAsIDAuNSwgMC4wLCAxLjApOyAvLyBPcmFuZ2UgZm9yIGhvcml6b250YWwgY29ubmVjdG9yXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBkaXNjYXJkO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChkcmF3Qm90dG9tUm93Q29ubmVjdG9yKSB7XG4gICAgICAgIC8vIFZlcmlmeSB0aGUgcmVxdWlyZWQgY2lyY2xlcyBhcmUgYWN0aXZlXG4gICAgICAgIGlmICghY2lyY2xlQ0lubmVyQWN0aXZlIHx8ICFjaXJjbGVCSW5uZXJBY3RpdmUpIHtcbiAgICAgICAgICBkaXNjYXJkO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgb3V0c2lkZSB0aGUgaW5uZXIgY2lyY2xlc1xuICAgICAgICBpZiAoZGlzdF9DIDw9IHVfcmFkaXVzQiB8fCBkaXN0X0IgPD0gdV9yYWRpdXNCKSB7XG4gICAgICAgICAgZGlzY2FyZDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBwb2ludCBpcyB3aXRoaW4gdGhlIGhvcml6b250YWwgY29ubmVjdG9yIGFyZWFcbiAgICAgICAgaWYgKGlzSW5Ib3Jpem9udGFsQ29ubmVjdG9yKHZXb3JsZFBvcywgY2VudGVyX0MsIGNlbnRlcl9CLCB1X3JhZGl1c0IpKSB7XG4gICAgICAgICAgLy8gRHJhdyB0aGUgaG9yaXpvbnRhbCBjb25uZWN0b3JcbiAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDEuMCwgMC41LCAwLjAsIDEuMCk7IC8vIE9yYW5nZSBmb3IgaG9yaXpvbnRhbCBjb25uZWN0b3JcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGRpc2NhcmQ7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gSGFuZGxlIGRpYWdvbmFsIGNvbm5lY3RvcnMgKG9yaWdpbmFsIGZ1bmN0aW9uYWxpdHkpXG4gICAgICAvLyBWZXJpZnkgdGhlIHJlcXVpcmVkIGNpcmNsZXMgYXJlIGFjdGl2ZSBmb3IgdGhlIHNlbGVjdGVkIGNvbm5lY3RvclxuICAgICAgaWYgKGRyYXdBQkNvbm5lY3RvciAmJiAoIWNpcmNsZUFJbm5lckFjdGl2ZSB8fCAhY2lyY2xlQklubmVyQWN0aXZlKSkge1xuICAgICAgICBkaXNjYXJkO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChkcmF3Q0RDb25uZWN0b3IgJiYgKCFjaXJjbGVDSW5uZXJBY3RpdmUgfHwgIWNpcmNsZURJbm5lckFjdGl2ZSkpIHtcbiAgICAgICAgZGlzY2FyZDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBEaXN0YW5jZSBmaWVsZHMgZm9yIHRoZSBpbm5lciBibGFjayBjaXJjbGVzXG4gICAgICBmbG9hdCBzZGZBID0gZGlzdF9BIC0gdV9yYWRpdXNCO1xuICAgICAgZmxvYXQgc2RmQiA9IGRpc3RfQiAtIHVfcmFkaXVzQjtcbiAgICAgIGZsb2F0IHNkZkMgPSBkaXN0X0MgLSB1X3JhZGl1c0I7XG4gICAgICBmbG9hdCBzZGZEID0gZGlzdF9EIC0gdV9yYWRpdXNCO1xuICAgICAgXG4gICAgICAvLyBXZSBvbmx5IGNvbnRpbnVlIGlmIHdlJ3JlIG91dHNpZGUgdGhlIHJlbGV2YW50IGJsYWNrIGNpcmNsZXNcbiAgICAgIGJvb2wgb3V0c2lkZVJlbGV2YW50Q2lyY2xlcyA9IHRydWU7XG4gICAgICBcbiAgICAgIGlmIChkcmF3QUJDb25uZWN0b3IpIHtcbiAgICAgICAgb3V0c2lkZVJlbGV2YW50Q2lyY2xlcyA9IChzZGZBID4gMC4wKSAmJiAoc2RmQiA+IDAuMCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChkcmF3Q0RDb25uZWN0b3IpIHtcbiAgICAgICAgb3V0c2lkZVJlbGV2YW50Q2lyY2xlcyA9IChzZGZDID4gMC4wKSAmJiAoc2RmRCA+IDAuMCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmICghb3V0c2lkZVJlbGV2YW50Q2lyY2xlcykge1xuICAgICAgICBkaXNjYXJkO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIGluc2lkZSBpbmZsdWVuY2UgYXJlYXNcbiAgICAgIGJvb2wgaW5zaWRlSW5mbHVlbmNlQXJlYSA9IGZhbHNlO1xuICAgICAgXG4gICAgICBpZiAoZHJhd0FCQ29ubmVjdG9yKSB7XG4gICAgICAgIC8vIEZvciBSZWQgQUIgY29ubmVjdG9yOlxuICAgICAgICAvLyBNdXN0IGJlIG91dHNpZGUgaW5uZXIgQiBjaXJjbGVzICh3ZSBhbHJlYWR5IGNoZWNrZWQgdGhpcyB3aXRoIG91dHNpZGVSZWxldmFudENpcmNsZXMpXG4gICAgICAgIC8vIE11c3QgYmUgb3V0c2lkZSBvdXRlciBBIGNpcmNsZXMgKHJlcHJlc2VudGVkIGJ5IHRoZSBncmF5IGNpcmNsZXMpXG4gICAgICAgIC8vIE5vdGljZSBob3cgd2UncmUgY2hlY2tpbmcgaWYgd2UncmUgb3V0c2lkZSBib3RoIG91dGVyIEEgY2lyY2xlcyAoQyBhbmQgRClcbiAgICAgICAgaW5zaWRlSW5mbHVlbmNlQXJlYSA9IChkaXN0X0MgPiB1X3JhZGl1c0EpICYmIChkaXN0X0QgPiB1X3JhZGl1c0EpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoZHJhd0NEQ29ubmVjdG9yKSB7XG4gICAgICAgIC8vIEZvciBCbHVlIENEIGNvbm5lY3RvcjpcbiAgICAgICAgLy8gTXVzdCBiZSBvdXRzaWRlIGlubmVyIEEgY2lyY2xlcyAod2UgYWxyZWFkeSBjaGVja2VkIHRoaXMgd2l0aCBvdXRzaWRlUmVsZXZhbnRDaXJjbGVzKVxuICAgICAgICAvLyBNdXN0IGJlIG91dHNpZGUgb3V0ZXIgQiBjaXJjbGVzIChyZXByZXNlbnRlZCBieSB0aGUgZ3JheSBjaXJjbGVzKVxuICAgICAgICAvLyBOb3RpY2UgaG93IHdlJ3JlIGNoZWNraW5nIGlmIHdlJ3JlIG91dHNpZGUgYm90aCBvdXRlciBCIGNpcmNsZXMgKEEgYW5kIEIpXG4gICAgICAgIGluc2lkZUluZmx1ZW5jZUFyZWEgPSAoZGlzdF9BID4gdV9yYWRpdXNBKSAmJiAoZGlzdF9CID4gdV9yYWRpdXNBKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKCFpbnNpZGVJbmZsdWVuY2VBcmVhKSB7XG4gICAgICAgIGRpc2NhcmQ7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2FsY3VsYXRlIHZlY3RvciBiZXR3ZWVuIHRoZSBhY3RpdmUgY2lyY2xlc1xuICAgICAgdmVjMiBhY3RpdmVEaXJlY3Rpb247XG4gICAgICB2ZWMyIHN0YXJ0Q2VudGVyO1xuICAgICAgdmVjMiBlbmRDZW50ZXI7XG4gICAgICBmbG9hdCBkaXN0U3RhcnQ7XG4gICAgICBmbG9hdCBkaXN0RW5kO1xuICAgICAgXG4gICAgICBpZiAoZHJhd0FCQ29ubmVjdG9yKSB7XG4gICAgICAgIGFjdGl2ZURpcmVjdGlvbiA9IGNlbnRlcl9CIC0gY2VudGVyX0E7XG4gICAgICAgIHN0YXJ0Q2VudGVyID0gY2VudGVyX0E7XG4gICAgICAgIGVuZENlbnRlciA9IGNlbnRlcl9CO1xuICAgICAgICBkaXN0U3RhcnQgPSBkaXN0X0E7XG4gICAgICAgIGRpc3RFbmQgPSBkaXN0X0I7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChkcmF3Q0RDb25uZWN0b3IpIHtcbiAgICAgICAgYWN0aXZlRGlyZWN0aW9uID0gY2VudGVyX0QgLSBjZW50ZXJfQztcbiAgICAgICAgc3RhcnRDZW50ZXIgPSBjZW50ZXJfQztcbiAgICAgICAgZW5kQ2VudGVyID0gY2VudGVyX0Q7XG4gICAgICAgIGRpc3RTdGFydCA9IGRpc3RfQztcbiAgICAgICAgZGlzdEVuZCA9IGRpc3RfRDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ29udGludWUgd2l0aCBleGlzdGluZyBjb25uZWN0b3IgbG9naWMsIGJ1dCB1c2UgdGhlIGFjdGl2ZSBjZW50ZXJzXG4gICAgICBmbG9hdCBsZW5ndGhBQiA9IGxlbmd0aChhY3RpdmVEaXJlY3Rpb24pO1xuICAgICAgdmVjMiBBQl9ub3JtYWxpemVkID0gYWN0aXZlRGlyZWN0aW9uIC8gbGVuZ3RoQUI7XG4gICAgICBcbiAgICAgIC8vIFByb2plY3QgY3VycmVudCBwb2ludCBvbnRvIGxpbmVcbiAgICAgIHZlYzIgQVAgPSB2V29ybGRQb3MgLSBzdGFydENlbnRlcjtcbiAgICAgIGZsb2F0IHByb2plY3Rpb24gPSBkb3QoQVAsIEFCX25vcm1hbGl6ZWQpO1xuICAgICAgXG4gICAgICAvLyBDcmVhdGUgYSBmaWVsZCB0aGF0IHJlcHJlc2VudHMgdGhlIFwicGF0aHdheVwiIGJldHdlZW4gdGhlIHR3byBjaXJjbGVzXG4gICAgICAvLyBUaGlzIGNyZWF0ZXMgYSBjdXJ2ZWQgc2hhcGUgdGhhdCBuYXJyb3dzIGluIHRoZSBtaWRkbGVcbiAgICAgIGZsb2F0IHBhdGh3YXlGaWVsZDtcbiAgICAgIFxuICAgICAgLy8gRm9yIHRoZSBmaXJzdCBwYXJ0IG9mIHRoZSBjdXJ2YXR1cmUgcmFuZ2UsIHVzZSBkaXN0YW5jZS1iYXNlZCBzaGFwZVxuICAgICAgaWYgKHVfY3VydmF0dXJlIDwgMC41KSB7XG4gICAgICAgIC8vIE1ldGhvZCAxOiBQYXRoIHdpdGggdmFyeWluZyB3aWR0aCBiYXNlZCBvbiBwcm9qZWN0aW9uIGFsb25nIEFCXG4gICAgICAgIFxuICAgICAgICAvLyBPbmx5IHByb2NlZWQgaWYgdGhlIHBpeGVsIGlzIHJlYXNvbmFibHkgbmVhciB0aGUgQUIgbGluZVxuICAgICAgICBpZiAocHJvamVjdGlvbiA+PSAtdV9yYWRpdXNBICYmIHByb2plY3Rpb24gPD0gbGVuZ3RoQUIgKyB1X3JhZGl1c0EpIHtcbiAgICAgICAgICAvLyBDYWxjdWxhdGUgcGVycGVuZGljdWxhciBkaXN0YW5jZSBmcm9tIHBvaW50IHRvIEFCIGxpbmVcbiAgICAgICAgICB2ZWMyIHBlcnBlbmRpY3VsYXIgPSBBUCAtIHByb2plY3Rpb24gKiBBQl9ub3JtYWxpemVkO1xuICAgICAgICAgIGZsb2F0IHBlcnBEaXN0YW5jZSA9IGxlbmd0aChwZXJwZW5kaWN1bGFyKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBCYXNlIHdpZHRoIGJhc2VkIG9uIHRoaWNrbmVzc1xuICAgICAgICAgIGZsb2F0IGJhc2VXaWR0aCA9IHVfdGhpY2tuZXNzICogdV9yYWRpdXNBO1xuICAgICAgICAgIGZsb2F0IG1pZFBvaW50ID0gbGVuZ3RoQUIgKiAwLjU7XG4gICAgICAgICAgZmxvYXQgZGlzdEZyb21NaWQgPSBhYnMocHJvamVjdGlvbiAtIG1pZFBvaW50KTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBNYWtlIG5hcnJvd2VyIGluIG1pZGRsZSBiYXNlZCBvbiBjdXJ2YXR1cmVcbiAgICAgICAgICBmbG9hdCB0ID0gZGlzdEZyb21NaWQgLyBtaWRQb2ludDsgLy8gMCBhdCBjZW50ZXIsIDEgYXQgZW5kcG9pbnRzXG4gICAgICAgICAgZmxvYXQgbmFycm93aW5nRmFjdG9yID0gbWl4KDAuNSwgMC45LCB1X2N1cnZhdHVyZSAqIDIuMCk7IC8vIE1vcmUgbmFycm93IGF0IGhpZ2hlciBjdXJ2YXR1cmVcbiAgICAgICAgICBmbG9hdCB3aWR0aEN1cnZlID0gMS4wIC0gcG93KHQsIDEuNSkgKiBuYXJyb3dpbmdGYWN0b3I7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBhZGp1c3RlZCB3aWR0aCBiYXNlZCBvbiBwb3NpdGlvblxuICAgICAgICAgIGZsb2F0IGFkanVzdGVkV2lkdGg7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKHByb2plY3Rpb24gPCAwLjApIHtcbiAgICAgICAgICAgIC8vIE5lYXIgZW5kcG9pbnQgQSAtIGJsZW5kIHdpdGggY2lyY2xlXG4gICAgICAgICAgICBhZGp1c3RlZFdpZHRoID0gbWl4KHVfcmFkaXVzQSAqIDAuOCwgYmFzZVdpZHRoLCAxLjAgKyBwcm9qZWN0aW9uIC8gdV9yYWRpdXNBKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHByb2plY3Rpb24gPiBsZW5ndGhBQikge1xuICAgICAgICAgICAgLy8gTmVhciBlbmRwb2ludCBCIC0gYmxlbmQgd2l0aCBjaXJjbGVcbiAgICAgICAgICAgIGFkanVzdGVkV2lkdGggPSBtaXgodV9yYWRpdXNBICogMC44LCBiYXNlV2lkdGgsIDEuMCAtIChwcm9qZWN0aW9uIC0gbGVuZ3RoQUIpIC8gdV9yYWRpdXNBKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQmV0d2VlbiBlbmRwb2ludHMgLSB1c2UgY3VydmVkIHdpZHRoXG4gICAgICAgICAgICBhZGp1c3RlZFdpZHRoID0gYmFzZVdpZHRoICogd2lkdGhDdXJ2ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gSWYgd2l0aGluIHRoZSBhZGp1c3RlZCB3aWR0aCwgd2UncmUgaW4gdGhlIGNvbm5lY3RvclxuICAgICAgICAgIGlmIChwZXJwRGlzdGFuY2UgPCBhZGp1c3RlZFdpZHRoKSB7XG4gICAgICAgICAgICAvLyBTZXQgY29sb3IgYmFzZWQgb24gd2hpY2ggY29ubmVjdG9yIGlzIGJlaW5nIGRyYXduXG4gICAgICAgICAgICBpZiAoZHJhd0FCQ29ubmVjdG9yKSB7XG4gICAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMS4wLCAwLjAsIDAuMCwgMS4wKTsgLy8gUmVkIGZvciBBQiBjb25uZWN0b3JcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4wLCAwLjUsIDEuMCwgMS4wKTsgLy8gQmx1ZSBmb3IgQ0QgY29ubmVjdG9yXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gTWV0aG9kIDI6IFVzZSBoeXBlcmJvbGljIGRpc3RhbmNlIGZpZWxkIGZvciBoaWdoZXIgY3VydmF0dXJlXG4gICAgICAgIC8vIE5vcm1hbGl6ZSBkaXN0YW5jZXMgZm9yIGJldHRlciBjb250cm9sXG4gICAgICAgIGZsb2F0IGQxID0gbWF4KDAuMCwgZGlzdFN0YXJ0IC0gdV9yYWRpdXNCKSAvIHVfcmFkaXVzQTsgXG4gICAgICAgIGZsb2F0IGQyID0gbWF4KDAuMCwgZGlzdEVuZCAtIHVfcmFkaXVzQikgLyB1X3JhZGl1c0E7XG4gICAgICAgIFxuICAgICAgICAvLyBDcmVhdGUgaHlwZXJib2xpYyBmaWVsZCAocHJvZHVjdCBvZiBkaXN0YW5jZXMpXG4gICAgICAgIHBhdGh3YXlGaWVsZCA9IGQxICogZDI7XG4gICAgICAgIFxuICAgICAgICAvLyBBZGp1c3QgZmllbGQgc3RyZW5ndGggYmFzZWQgb24gZGlzdGFuY2UgdG8gbWFrZSBzaGFwZSBtb3JlIGNvbXBhY3RcbiAgICAgICAgZmxvYXQgZGlzdGFuY2VTY2FsZSA9IDMuMCAvIGxlbmd0aEFCO1xuICAgICAgICBwYXRod2F5RmllbGQgKj0gZGlzdGFuY2VTY2FsZTtcbiAgICAgICAgXG4gICAgICAgIC8vIFRoaWNrbmVzcyBjb250cm9scyB0aGUgdGhyZXNob2xkXG4gICAgICAgIGZsb2F0IHRocmVzaG9sZCA9IHVfdGhpY2tuZXNzICogMC4yICogbWl4KDEuMCwgMi4wLCB1X2N1cnZhdHVyZSAtIDAuNSk7XG4gICAgICAgIFxuICAgICAgICAvLyBDaGVjayBpZiB3aXRoaW4gdGhlIGZpZWxkIHRocmVzaG9sZFxuICAgICAgICBpZiAocGF0aHdheUZpZWxkIDwgdGhyZXNob2xkKSB7XG4gICAgICAgICAgLy8gT25seSBzaG93IGNvbm5lY3RvciBiZXR3ZWVuIHRoZSBjaXJjbGVzIChub3QgZXh0ZW5kaW5nIG91dCB0aGUgb3RoZXIgc2lkZXMpXG4gICAgICAgICAgZmxvYXQgZG90UHJvZHVjdEEgPSBkb3QoQVAsIEFCX25vcm1hbGl6ZWQpO1xuICAgICAgICAgIGZsb2F0IGRvdFByb2R1Y3RCID0gZG90KHZXb3JsZFBvcyAtIGVuZENlbnRlciwgLUFCX25vcm1hbGl6ZWQpO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChkb3RQcm9kdWN0QSA+PSAtdV9yYWRpdXNCICogMC41ICYmIGRvdFByb2R1Y3RCID49IC11X3JhZGl1c0IgKiAwLjUpIHtcbiAgICAgICAgICAgIC8vIFNldCBjb2xvciBiYXNlZCBvbiB3aGljaCBjb25uZWN0b3IgaXMgYmVpbmcgZHJhd25cbiAgICAgICAgICAgIGlmIChkcmF3QUJDb25uZWN0b3IpIHtcbiAgICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgxLjAsIDAuMCwgMC4wLCAxLjApOyAvLyBSZWQgZm9yIEFCIGNvbm5lY3RvclxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjAsIDAuNSwgMS4wLCAxLjApOyAvLyBCbHVlIGZvciBDRCBjb25uZWN0b3JcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gSWYgd2UgZ290IGhlcmUsIHRoZSBwaXhlbCBpcyBvdXRzaWRlIHRoZSBjb25uZWN0b3Igc2hhcGVcbiAgICAgIGRpc2NhcmQ7XG4gICAgfVxuICBgXG4pO1xuXG4vLyBBZGQgYSB1bmlxdWUga2V5IGZvciBITVIgcHVycG9zZXMgd2l0aCBSM0ZcbkdyaWRDb25uZWN0b3JNYXRlcmlhbC5rZXkgPSBUSFJFRS5NYXRoVXRpbHMuZ2VuZXJhdGVVVUlEKCk7XG5cbmV4cG9ydCB7IEdyaWRDb25uZWN0b3JNYXRlcmlhbCB9OyAiXSwibmFtZXMiOlsiVEhSRUUiLCJzaGFkZXJNYXRlcmlhbCIsIkdyaWRDb25uZWN0b3JNYXRlcmlhbCIsInVfcmFkaXVzQiIsInVfcmFkaXVzQSIsInVfc3BhY2luZyIsInVfdGhpY2tuZXNzIiwidV9jdXJ2YXR1cmUiLCJ1X3Jlc29sdXRpb24iLCJWZWN0b3IyIiwidV9hY3RpdmVDb25uZWN0b3IiLCJ1X2dyaWRTdGF0ZSIsIkRhdGFUZXh0dXJlIiwiRmxvYXQzMkFycmF5IiwiUkdCQUZvcm1hdCIsIkZsb2F0VHlwZSIsImtleSIsIk1hdGhVdGlscyIsImdlbmVyYXRlVVVJRCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./components/GridConnectorMaterial.js\n");

/***/ }),

/***/ "./components/SimpleConnectorMaterial.js":
/*!***********************************************!*\
  !*** ./components/SimpleConnectorMaterial.js ***!
  \***********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SimpleConnectorMaterial: () => (/* binding */ SimpleConnectorMaterial)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-three/drei */ \"@react-three/drei\");\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_react_three_drei__WEBPACK_IMPORTED_MODULE_1__);\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([three__WEBPACK_IMPORTED_MODULE_0__]);\nthree__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n// A very simple connector material for debugging\nconst SimpleConnectorMaterial = (0,_react_three_drei__WEBPACK_IMPORTED_MODULE_1__.shaderMaterial)(// Uniforms\n{\n    u_radiusB: 0.4,\n    u_radiusA: 0.5,\n    u_boxSize: 0.5,\n    u_spacing: 0.89,\n    u_activeConnector: 0,\n    u_gridState: new three__WEBPACK_IMPORTED_MODULE_0__.DataTexture(new Float32Array(4), 2, 2, three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat, three__WEBPACK_IMPORTED_MODULE_0__.FloatType)\n}, // Vertex Shader\n/*glsl*/ `\n    varying vec2 vUv;\n    varying vec2 vWorldPos;\n\n    void main() {\n      vUv = uv;\n\n      // World position of the vertex\n      vec4 worldPos = modelMatrix * vec4(position, 1.0);\n      vWorldPos = worldPos.xy;\n\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n  `, // Fragment Shader\n/*glsl*/ `\n    varying vec2 vUv;\n    varying vec2 vWorldPos; // Pixel position in world space\n\n    uniform float u_radiusB; // Radius for target circles B1, B2\n    uniform float u_radiusA; // Radius for defining circles A1, A2\n    uniform float u_boxSize; // Receive box size from JS\n    uniform float u_spacing; // Grid spacing between centers\n    uniform float u_activeConnector; // 0 = none, 1 = red (AB), 2 = blue (CD), 3 = orange top row, 4 = orange bottom row\n    uniform sampler2D u_gridState; // Grid state texture\n\n    // Helper function to get circle state from the grid state texture\n    vec4 getGridState(int row, int col) {\n      return texture2D(u_gridState, vec2(float(col) + 0.5, float(row) + 0.5) / 2.0);\n    }\n\n    // SDF for a 2D circle\n    float sdCircle( vec2 p, vec2 c, float r ) {\n        return length(p-c) - r;\n    }\n\n    // SDF for a 2D Box\n    // p: point, c: center, b: half-size\n    float sdBox( vec2 p, vec2 c, vec2 b ) {\n        vec2 q = abs(p - c) - b;\n        return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n    }\n\n    // Smooth minimum function (use log/exp, base-e is fine)\n    float smin( float a, float b, float k ) {\n        float h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n        return mix( b, a, h ) - k*h*(1.0-h);\n        // Alternative formulation using exp:\n        // k = max(k, 0.0001); // Ensure k is positive\n        // return -log(exp(-k*a) + exp(-k*b))/k;\n    }\n\n    void main() {\n      // If no connector is active, discard immediately\n      if (u_activeConnector < 0.5) {\n        discard;\n        return;\n      }\n      \n      // Check if relevant circles are active\n      vec4 stateA = getGridState(0, 0); // Top-left\n      vec4 stateB = getGridState(1, 1); // Bottom-right\n      vec4 stateC = getGridState(1, 0); // Bottom-left  \n      vec4 stateD = getGridState(0, 1); // Top-right\n      \n      // Check if inner circles are active (red channel = inner circle)\n      bool circleB1Active = stateA.r > 0.5; // Top-left inner circle\n      bool circleB2Active = stateB.r > 0.5; // Bottom-right inner circle\n      bool circleA1Active = stateC.r > 0.5; // Bottom-left inner circle\n      bool circleA2Active = stateD.r > 0.5; // Top-right inner circle\n      \n      // Determine which connector to draw based on active connector state\n      bool drawRedConnector = u_activeConnector == 1.0;\n      bool drawBlueConnector = u_activeConnector == 2.0;\n      bool drawTopOrangeConnector = u_activeConnector == 3.0;\n      bool drawBottomOrangeConnector = u_activeConnector == 4.0;\n      \n      // Verify the required circles are active for the selected connector\n      if (drawRedConnector && (!circleB1Active || !circleB2Active)) {\n        discard;\n        return;\n      }\n      \n      if (drawBlueConnector && (!circleA1Active || !circleA2Active)) {\n        discard;\n        return;\n      }\n      \n      if (drawTopOrangeConnector && (!circleB1Active || !circleA2Active)) {\n        discard;\n        return;\n      }\n      \n      if (drawBottomOrangeConnector && (!circleA1Active || !circleB2Active)) {\n        discard;\n        return;\n      }\n    \n      // Calculate offset based on half the grid spacing\n      float offset = u_spacing * 0.5;\n      \n      // Define circle centers dynamically based on grid spacing\n      vec2 centerB1 = vec2(-offset, offset);    // Top-left\n      vec2 centerB2 = vec2(offset, -offset);    // Bottom-right\n      vec2 centerA1 = vec2(-offset, -offset);   // Bottom-left\n      vec2 centerA2 = vec2(offset, offset);     // Top-right\n\n      // Calculate SDFs for each circle - both inner and outer radii\n      // Inner circles (B radius)\n      float sdB1Inner = sdCircle(vWorldPos, centerB1, u_radiusB);\n      float sdB2Inner = sdCircle(vWorldPos, centerB2, u_radiusB);\n      float sdA1Inner = sdCircle(vWorldPos, centerA1, u_radiusB);\n      float sdA2Inner = sdCircle(vWorldPos, centerA2, u_radiusB);\n      \n      // Outer circles (A radius)\n      float sdB1Outer = sdCircle(vWorldPos, centerB1, u_radiusA);\n      float sdB2Outer = sdCircle(vWorldPos, centerB2, u_radiusA);\n      float sdA1Outer = sdCircle(vWorldPos, centerA1, u_radiusA);\n      float sdA2Outer = sdCircle(vWorldPos, centerA2, u_radiusA);\n      \n      // Calculate SDF for a bounding box using the uniform size\n      vec2 boxCenter = vec2(0.0);\n      vec2 boxHalfSize = vec2(u_boxSize);\n      float sdfBoundingBox = sdBox(vWorldPos, boxCenter, boxHalfSize);\n      \n      // Handle horizontal connectors (orange)\n      if (drawTopOrangeConnector || drawBottomOrangeConnector) {\n        // Define horizontal connector dimensions\n        vec2 connector1Start, connector1End;\n        \n        if (drawTopOrangeConnector) {\n          connector1Start = centerB1;\n          connector1End = centerA2;\n        } else { // Bottom row\n          connector1Start = centerA1;\n          connector1End = centerB2;\n        }\n        \n        // Calculate if we're inside the horizontal connector\n        float midY = (connector1Start.y + connector1End.y) * 0.5;\n        float leftX = min(connector1Start.x, connector1End.x);\n        float rightX = max(connector1Start.x, connector1End.x);\n        \n        // Check if inside rect of height 2*radiusB\n        if (vWorldPos.x >= leftX && vWorldPos.x <= rightX && \n            vWorldPos.y >= midY - u_radiusB && vWorldPos.y <= midY + u_radiusB) {\n          // Orange for horizontal connector\n          gl_FragColor = vec4(1.0, 0.5, 0.0, 1.0);\n          return;\n        }\n        \n        discard;\n        return;\n      }\n      \n      // Calculate connector shapes for diagonal connectors\n      // Red connector (B1-B2 diagonal):\n      // - Must be outside inner B circles (B1 and B2)\n      // - Must be outside outer A circles (A1 and A2)\n      float sdRedConnector = 1.0;\n      if (drawRedConnector) {\n        bool outsideInnerB = (sdB1Inner > 0.0) && (sdB2Inner > 0.0);\n        bool outsideOuterA = (sdA1Outer > 0.0) && (sdA2Outer > 0.0);\n        \n        if (outsideInnerB && outsideOuterA && sdfBoundingBox < 0.0) {\n          sdRedConnector = -1.0; // Inside the connector\n        }\n      }\n      \n      // Blue connector (A1-A2 diagonal):\n      // - Must be outside inner A circles (A1 and A2)\n      // - Must be outside outer B circles (B1 and B2)\n      float sdBlueConnector = 1.0;\n      if (drawBlueConnector) {\n        bool outsideInnerA = (sdA1Inner > 0.0) && (sdA2Inner > 0.0);\n        bool outsideOuterB = (sdB1Outer > 0.0) && (sdB2Outer > 0.0);\n        \n        if (outsideInnerA && outsideOuterB && sdfBoundingBox < 0.0) {\n          sdBlueConnector = -1.0; // Inside the connector\n        }\n      }\n      \n      // Determine if we're inside either connector\n      if (sdRedConnector < 0.0 || sdBlueConnector < 0.0) {\n        // Choose color based on which connector we're inside\n        if (sdRedConnector < 0.0) {\n          // Red connector\n          gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); // Red\n        } else {\n          // Blue connector\n          gl_FragColor = vec4(0.0, 0.5, 1.0, 1.0); // Blue\n        }\n      } else {\n        discard; // Outside both connectors\n      }\n    }\n  `);\n// Add a unique key for HMR purposes with R3F\nSimpleConnectorMaterial.key = three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.generateUUID();\n\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL1NpbXBsZUNvbm5lY3Rvck1hdGVyaWFsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBK0I7QUFDb0I7QUFFbkQsaURBQWlEO0FBQ2pELE1BQU1FLDBCQUEwQkQsaUVBQWNBLENBQzVDLFdBQVc7QUFDWDtJQUNFRSxXQUFXO0lBQ1hDLFdBQVc7SUFDWEMsV0FBVztJQUNYQyxXQUFXO0lBQ1hDLG1CQUFtQjtJQUNuQkMsYUFBYSxJQUFJUiw4Q0FBaUIsQ0FDaEMsSUFBSVUsYUFBYSxJQUNqQixHQUNBLEdBQ0FWLDZDQUFnQixFQUNoQkEsNENBQWU7QUFHbkIsR0FDQSxnQkFBZ0I7QUFDaEIsTUFBTSxHQUFFLENBQUM7Ozs7Ozs7Ozs7Ozs7RUFhVCxDQUFDLEVBQ0Qsa0JBQWtCO0FBQ2xCLE1BQU0sR0FBRSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBcUxULENBQUM7QUFHSCw2Q0FBNkM7QUFDN0NFLHdCQUF3QlcsR0FBRyxHQUFHYiw0Q0FBZSxDQUFDZSxZQUFZO0FBRXZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViZ2wtZG90LWdyaWQtbXZwLy4vY29tcG9uZW50cy9TaW1wbGVDb25uZWN0b3JNYXRlcmlhbC5qcz8zZjhiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcbmltcG9ydCB7IHNoYWRlck1hdGVyaWFsIH0gZnJvbSAnQHJlYWN0LXRocmVlL2RyZWknO1xuXG4vLyBBIHZlcnkgc2ltcGxlIGNvbm5lY3RvciBtYXRlcmlhbCBmb3IgZGVidWdnaW5nXG5jb25zdCBTaW1wbGVDb25uZWN0b3JNYXRlcmlhbCA9IHNoYWRlck1hdGVyaWFsKFxuICAvLyBVbmlmb3Jtc1xuICB7XG4gICAgdV9yYWRpdXNCOiAwLjQsIC8vIFJhZGl1cyBmb3IgdGFyZ2V0IGNpcmNsZXMgQjEsIEIyIChpbm5lcilcbiAgICB1X3JhZGl1c0E6IDAuNSwgLy8gUmFkaXVzIGZvciBkZWZpbmluZyBjaXJjbGVzIEExLCBBMiAob3V0ZXIpXG4gICAgdV9ib3hTaXplOiAwLjUsIC8vIERlZmF1bHQgaGFsZi1zaXplIGZvciB0aGUgYm91bmRpbmcgYm94IFxuICAgIHVfc3BhY2luZzogMC44OSwgLy8gR3JpZCBzcGFjaW5nIGJldHdlZW4gY2VudGVyc1xuICAgIHVfYWN0aXZlQ29ubmVjdG9yOiAwLCAvLyAwID0gbm9uZSwgMSA9IHJlZCAoQUIpLCAyID0gYmx1ZSAoQ0QpLCAzID0gb3JhbmdlIHRvcCByb3csIDQgPSBvcmFuZ2UgYm90dG9tIHJvd1xuICAgIHVfZ3JpZFN0YXRlOiBuZXcgVEhSRUUuRGF0YVRleHR1cmUoIC8vIEFkZCBncmlkIHN0YXRlIHRleHR1cmVcbiAgICAgIG5ldyBGbG9hdDMyQXJyYXkoNCksIC8vIFJHQkEgdmFsdWVzIHBlciBjZWxsXG4gICAgICAyLCAvLyB3aWR0aCAoZm9yIDJ4MiBncmlkKVxuICAgICAgMiwgLy8gaGVpZ2h0IChmb3IgMngyIGdyaWQpXG4gICAgICBUSFJFRS5SR0JBRm9ybWF0LFxuICAgICAgVEhSRUUuRmxvYXRUeXBlXG4gICAgKVxuICAgIC8vIHVfdGhpY2tuZXNzLCB1X2N1cnZhdHVyZSwgdV9yZXNvbHV0aW9uIGFyZSByZW1vdmVkIGFzIHRoZXkgYXJlIG5vdCBuZWVkZWQgZm9yIHRoaXMgU0RGIGxvZ2ljXG4gIH0sXG4gIC8vIFZlcnRleCBTaGFkZXJcbiAgLypnbHNsKi9gXG4gICAgdmFyeWluZyB2ZWMyIHZVdjtcbiAgICB2YXJ5aW5nIHZlYzIgdldvcmxkUG9zO1xuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgdlV2ID0gdXY7XG5cbiAgICAgIC8vIFdvcmxkIHBvc2l0aW9uIG9mIHRoZSB2ZXJ0ZXhcbiAgICAgIHZlYzQgd29ybGRQb3MgPSBtb2RlbE1hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XG4gICAgICB2V29ybGRQb3MgPSB3b3JsZFBvcy54eTtcblxuICAgICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTtcbiAgICB9XG4gIGAsXG4gIC8vIEZyYWdtZW50IFNoYWRlclxuICAvKmdsc2wqL2BcbiAgICB2YXJ5aW5nIHZlYzIgdlV2O1xuICAgIHZhcnlpbmcgdmVjMiB2V29ybGRQb3M7IC8vIFBpeGVsIHBvc2l0aW9uIGluIHdvcmxkIHNwYWNlXG5cbiAgICB1bmlmb3JtIGZsb2F0IHVfcmFkaXVzQjsgLy8gUmFkaXVzIGZvciB0YXJnZXQgY2lyY2xlcyBCMSwgQjJcbiAgICB1bmlmb3JtIGZsb2F0IHVfcmFkaXVzQTsgLy8gUmFkaXVzIGZvciBkZWZpbmluZyBjaXJjbGVzIEExLCBBMlxuICAgIHVuaWZvcm0gZmxvYXQgdV9ib3hTaXplOyAvLyBSZWNlaXZlIGJveCBzaXplIGZyb20gSlNcbiAgICB1bmlmb3JtIGZsb2F0IHVfc3BhY2luZzsgLy8gR3JpZCBzcGFjaW5nIGJldHdlZW4gY2VudGVyc1xuICAgIHVuaWZvcm0gZmxvYXQgdV9hY3RpdmVDb25uZWN0b3I7IC8vIDAgPSBub25lLCAxID0gcmVkIChBQiksIDIgPSBibHVlIChDRCksIDMgPSBvcmFuZ2UgdG9wIHJvdywgNCA9IG9yYW5nZSBib3R0b20gcm93XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdV9ncmlkU3RhdGU7IC8vIEdyaWQgc3RhdGUgdGV4dHVyZVxuXG4gICAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGdldCBjaXJjbGUgc3RhdGUgZnJvbSB0aGUgZ3JpZCBzdGF0ZSB0ZXh0dXJlXG4gICAgdmVjNCBnZXRHcmlkU3RhdGUoaW50IHJvdywgaW50IGNvbCkge1xuICAgICAgcmV0dXJuIHRleHR1cmUyRCh1X2dyaWRTdGF0ZSwgdmVjMihmbG9hdChjb2wpICsgMC41LCBmbG9hdChyb3cpICsgMC41KSAvIDIuMCk7XG4gICAgfVxuXG4gICAgLy8gU0RGIGZvciBhIDJEIGNpcmNsZVxuICAgIGZsb2F0IHNkQ2lyY2xlKCB2ZWMyIHAsIHZlYzIgYywgZmxvYXQgciApIHtcbiAgICAgICAgcmV0dXJuIGxlbmd0aChwLWMpIC0gcjtcbiAgICB9XG5cbiAgICAvLyBTREYgZm9yIGEgMkQgQm94XG4gICAgLy8gcDogcG9pbnQsIGM6IGNlbnRlciwgYjogaGFsZi1zaXplXG4gICAgZmxvYXQgc2RCb3goIHZlYzIgcCwgdmVjMiBjLCB2ZWMyIGIgKSB7XG4gICAgICAgIHZlYzIgcSA9IGFicyhwIC0gYykgLSBiO1xuICAgICAgICByZXR1cm4gbGVuZ3RoKG1heChxLDAuMCkpICsgbWluKG1heChxLngscS55KSwwLjApO1xuICAgIH1cblxuICAgIC8vIFNtb290aCBtaW5pbXVtIGZ1bmN0aW9uICh1c2UgbG9nL2V4cCwgYmFzZS1lIGlzIGZpbmUpXG4gICAgZmxvYXQgc21pbiggZmxvYXQgYSwgZmxvYXQgYiwgZmxvYXQgayApIHtcbiAgICAgICAgZmxvYXQgaCA9IGNsYW1wKCAwLjUgKyAwLjUqKGItYSkvaywgMC4wLCAxLjAgKTtcbiAgICAgICAgcmV0dXJuIG1peCggYiwgYSwgaCApIC0gaypoKigxLjAtaCk7XG4gICAgICAgIC8vIEFsdGVybmF0aXZlIGZvcm11bGF0aW9uIHVzaW5nIGV4cDpcbiAgICAgICAgLy8gayA9IG1heChrLCAwLjAwMDEpOyAvLyBFbnN1cmUgayBpcyBwb3NpdGl2ZVxuICAgICAgICAvLyByZXR1cm4gLWxvZyhleHAoLWsqYSkgKyBleHAoLWsqYikpL2s7XG4gICAgfVxuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgLy8gSWYgbm8gY29ubmVjdG9yIGlzIGFjdGl2ZSwgZGlzY2FyZCBpbW1lZGlhdGVseVxuICAgICAgaWYgKHVfYWN0aXZlQ29ubmVjdG9yIDwgMC41KSB7XG4gICAgICAgIGRpc2NhcmQ7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgcmVsZXZhbnQgY2lyY2xlcyBhcmUgYWN0aXZlXG4gICAgICB2ZWM0IHN0YXRlQSA9IGdldEdyaWRTdGF0ZSgwLCAwKTsgLy8gVG9wLWxlZnRcbiAgICAgIHZlYzQgc3RhdGVCID0gZ2V0R3JpZFN0YXRlKDEsIDEpOyAvLyBCb3R0b20tcmlnaHRcbiAgICAgIHZlYzQgc3RhdGVDID0gZ2V0R3JpZFN0YXRlKDEsIDApOyAvLyBCb3R0b20tbGVmdCAgXG4gICAgICB2ZWM0IHN0YXRlRCA9IGdldEdyaWRTdGF0ZSgwLCAxKTsgLy8gVG9wLXJpZ2h0XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIGlubmVyIGNpcmNsZXMgYXJlIGFjdGl2ZSAocmVkIGNoYW5uZWwgPSBpbm5lciBjaXJjbGUpXG4gICAgICBib29sIGNpcmNsZUIxQWN0aXZlID0gc3RhdGVBLnIgPiAwLjU7IC8vIFRvcC1sZWZ0IGlubmVyIGNpcmNsZVxuICAgICAgYm9vbCBjaXJjbGVCMkFjdGl2ZSA9IHN0YXRlQi5yID4gMC41OyAvLyBCb3R0b20tcmlnaHQgaW5uZXIgY2lyY2xlXG4gICAgICBib29sIGNpcmNsZUExQWN0aXZlID0gc3RhdGVDLnIgPiAwLjU7IC8vIEJvdHRvbS1sZWZ0IGlubmVyIGNpcmNsZVxuICAgICAgYm9vbCBjaXJjbGVBMkFjdGl2ZSA9IHN0YXRlRC5yID4gMC41OyAvLyBUb3AtcmlnaHQgaW5uZXIgY2lyY2xlXG4gICAgICBcbiAgICAgIC8vIERldGVybWluZSB3aGljaCBjb25uZWN0b3IgdG8gZHJhdyBiYXNlZCBvbiBhY3RpdmUgY29ubmVjdG9yIHN0YXRlXG4gICAgICBib29sIGRyYXdSZWRDb25uZWN0b3IgPSB1X2FjdGl2ZUNvbm5lY3RvciA9PSAxLjA7XG4gICAgICBib29sIGRyYXdCbHVlQ29ubmVjdG9yID0gdV9hY3RpdmVDb25uZWN0b3IgPT0gMi4wO1xuICAgICAgYm9vbCBkcmF3VG9wT3JhbmdlQ29ubmVjdG9yID0gdV9hY3RpdmVDb25uZWN0b3IgPT0gMy4wO1xuICAgICAgYm9vbCBkcmF3Qm90dG9tT3JhbmdlQ29ubmVjdG9yID0gdV9hY3RpdmVDb25uZWN0b3IgPT0gNC4wO1xuICAgICAgXG4gICAgICAvLyBWZXJpZnkgdGhlIHJlcXVpcmVkIGNpcmNsZXMgYXJlIGFjdGl2ZSBmb3IgdGhlIHNlbGVjdGVkIGNvbm5lY3RvclxuICAgICAgaWYgKGRyYXdSZWRDb25uZWN0b3IgJiYgKCFjaXJjbGVCMUFjdGl2ZSB8fCAhY2lyY2xlQjJBY3RpdmUpKSB7XG4gICAgICAgIGRpc2NhcmQ7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKGRyYXdCbHVlQ29ubmVjdG9yICYmICghY2lyY2xlQTFBY3RpdmUgfHwgIWNpcmNsZUEyQWN0aXZlKSkge1xuICAgICAgICBkaXNjYXJkO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChkcmF3VG9wT3JhbmdlQ29ubmVjdG9yICYmICghY2lyY2xlQjFBY3RpdmUgfHwgIWNpcmNsZUEyQWN0aXZlKSkge1xuICAgICAgICBkaXNjYXJkO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChkcmF3Qm90dG9tT3JhbmdlQ29ubmVjdG9yICYmICghY2lyY2xlQTFBY3RpdmUgfHwgIWNpcmNsZUIyQWN0aXZlKSkge1xuICAgICAgICBkaXNjYXJkO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgXG4gICAgICAvLyBDYWxjdWxhdGUgb2Zmc2V0IGJhc2VkIG9uIGhhbGYgdGhlIGdyaWQgc3BhY2luZ1xuICAgICAgZmxvYXQgb2Zmc2V0ID0gdV9zcGFjaW5nICogMC41O1xuICAgICAgXG4gICAgICAvLyBEZWZpbmUgY2lyY2xlIGNlbnRlcnMgZHluYW1pY2FsbHkgYmFzZWQgb24gZ3JpZCBzcGFjaW5nXG4gICAgICB2ZWMyIGNlbnRlckIxID0gdmVjMigtb2Zmc2V0LCBvZmZzZXQpOyAgICAvLyBUb3AtbGVmdFxuICAgICAgdmVjMiBjZW50ZXJCMiA9IHZlYzIob2Zmc2V0LCAtb2Zmc2V0KTsgICAgLy8gQm90dG9tLXJpZ2h0XG4gICAgICB2ZWMyIGNlbnRlckExID0gdmVjMigtb2Zmc2V0LCAtb2Zmc2V0KTsgICAvLyBCb3R0b20tbGVmdFxuICAgICAgdmVjMiBjZW50ZXJBMiA9IHZlYzIob2Zmc2V0LCBvZmZzZXQpOyAgICAgLy8gVG9wLXJpZ2h0XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBTREZzIGZvciBlYWNoIGNpcmNsZSAtIGJvdGggaW5uZXIgYW5kIG91dGVyIHJhZGlpXG4gICAgICAvLyBJbm5lciBjaXJjbGVzIChCIHJhZGl1cylcbiAgICAgIGZsb2F0IHNkQjFJbm5lciA9IHNkQ2lyY2xlKHZXb3JsZFBvcywgY2VudGVyQjEsIHVfcmFkaXVzQik7XG4gICAgICBmbG9hdCBzZEIySW5uZXIgPSBzZENpcmNsZSh2V29ybGRQb3MsIGNlbnRlckIyLCB1X3JhZGl1c0IpO1xuICAgICAgZmxvYXQgc2RBMUlubmVyID0gc2RDaXJjbGUodldvcmxkUG9zLCBjZW50ZXJBMSwgdV9yYWRpdXNCKTtcbiAgICAgIGZsb2F0IHNkQTJJbm5lciA9IHNkQ2lyY2xlKHZXb3JsZFBvcywgY2VudGVyQTIsIHVfcmFkaXVzQik7XG4gICAgICBcbiAgICAgIC8vIE91dGVyIGNpcmNsZXMgKEEgcmFkaXVzKVxuICAgICAgZmxvYXQgc2RCMU91dGVyID0gc2RDaXJjbGUodldvcmxkUG9zLCBjZW50ZXJCMSwgdV9yYWRpdXNBKTtcbiAgICAgIGZsb2F0IHNkQjJPdXRlciA9IHNkQ2lyY2xlKHZXb3JsZFBvcywgY2VudGVyQjIsIHVfcmFkaXVzQSk7XG4gICAgICBmbG9hdCBzZEExT3V0ZXIgPSBzZENpcmNsZSh2V29ybGRQb3MsIGNlbnRlckExLCB1X3JhZGl1c0EpO1xuICAgICAgZmxvYXQgc2RBMk91dGVyID0gc2RDaXJjbGUodldvcmxkUG9zLCBjZW50ZXJBMiwgdV9yYWRpdXNBKTtcbiAgICAgIFxuICAgICAgLy8gQ2FsY3VsYXRlIFNERiBmb3IgYSBib3VuZGluZyBib3ggdXNpbmcgdGhlIHVuaWZvcm0gc2l6ZVxuICAgICAgdmVjMiBib3hDZW50ZXIgPSB2ZWMyKDAuMCk7XG4gICAgICB2ZWMyIGJveEhhbGZTaXplID0gdmVjMih1X2JveFNpemUpO1xuICAgICAgZmxvYXQgc2RmQm91bmRpbmdCb3ggPSBzZEJveCh2V29ybGRQb3MsIGJveENlbnRlciwgYm94SGFsZlNpemUpO1xuICAgICAgXG4gICAgICAvLyBIYW5kbGUgaG9yaXpvbnRhbCBjb25uZWN0b3JzIChvcmFuZ2UpXG4gICAgICBpZiAoZHJhd1RvcE9yYW5nZUNvbm5lY3RvciB8fCBkcmF3Qm90dG9tT3JhbmdlQ29ubmVjdG9yKSB7XG4gICAgICAgIC8vIERlZmluZSBob3Jpem9udGFsIGNvbm5lY3RvciBkaW1lbnNpb25zXG4gICAgICAgIHZlYzIgY29ubmVjdG9yMVN0YXJ0LCBjb25uZWN0b3IxRW5kO1xuICAgICAgICBcbiAgICAgICAgaWYgKGRyYXdUb3BPcmFuZ2VDb25uZWN0b3IpIHtcbiAgICAgICAgICBjb25uZWN0b3IxU3RhcnQgPSBjZW50ZXJCMTtcbiAgICAgICAgICBjb25uZWN0b3IxRW5kID0gY2VudGVyQTI7XG4gICAgICAgIH0gZWxzZSB7IC8vIEJvdHRvbSByb3dcbiAgICAgICAgICBjb25uZWN0b3IxU3RhcnQgPSBjZW50ZXJBMTtcbiAgICAgICAgICBjb25uZWN0b3IxRW5kID0gY2VudGVyQjI7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIENhbGN1bGF0ZSBpZiB3ZSdyZSBpbnNpZGUgdGhlIGhvcml6b250YWwgY29ubmVjdG9yXG4gICAgICAgIGZsb2F0IG1pZFkgPSAoY29ubmVjdG9yMVN0YXJ0LnkgKyBjb25uZWN0b3IxRW5kLnkpICogMC41O1xuICAgICAgICBmbG9hdCBsZWZ0WCA9IG1pbihjb25uZWN0b3IxU3RhcnQueCwgY29ubmVjdG9yMUVuZC54KTtcbiAgICAgICAgZmxvYXQgcmlnaHRYID0gbWF4KGNvbm5lY3RvcjFTdGFydC54LCBjb25uZWN0b3IxRW5kLngpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgaWYgaW5zaWRlIHJlY3Qgb2YgaGVpZ2h0IDIqcmFkaXVzQlxuICAgICAgICBpZiAodldvcmxkUG9zLnggPj0gbGVmdFggJiYgdldvcmxkUG9zLnggPD0gcmlnaHRYICYmIFxuICAgICAgICAgICAgdldvcmxkUG9zLnkgPj0gbWlkWSAtIHVfcmFkaXVzQiAmJiB2V29ybGRQb3MueSA8PSBtaWRZICsgdV9yYWRpdXNCKSB7XG4gICAgICAgICAgLy8gT3JhbmdlIGZvciBob3Jpem9udGFsIGNvbm5lY3RvclxuICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMS4wLCAwLjUsIDAuMCwgMS4wKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGRpc2NhcmQ7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2FsY3VsYXRlIGNvbm5lY3RvciBzaGFwZXMgZm9yIGRpYWdvbmFsIGNvbm5lY3RvcnNcbiAgICAgIC8vIFJlZCBjb25uZWN0b3IgKEIxLUIyIGRpYWdvbmFsKTpcbiAgICAgIC8vIC0gTXVzdCBiZSBvdXRzaWRlIGlubmVyIEIgY2lyY2xlcyAoQjEgYW5kIEIyKVxuICAgICAgLy8gLSBNdXN0IGJlIG91dHNpZGUgb3V0ZXIgQSBjaXJjbGVzIChBMSBhbmQgQTIpXG4gICAgICBmbG9hdCBzZFJlZENvbm5lY3RvciA9IDEuMDtcbiAgICAgIGlmIChkcmF3UmVkQ29ubmVjdG9yKSB7XG4gICAgICAgIGJvb2wgb3V0c2lkZUlubmVyQiA9IChzZEIxSW5uZXIgPiAwLjApICYmIChzZEIySW5uZXIgPiAwLjApO1xuICAgICAgICBib29sIG91dHNpZGVPdXRlckEgPSAoc2RBMU91dGVyID4gMC4wKSAmJiAoc2RBMk91dGVyID4gMC4wKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChvdXRzaWRlSW5uZXJCICYmIG91dHNpZGVPdXRlckEgJiYgc2RmQm91bmRpbmdCb3ggPCAwLjApIHtcbiAgICAgICAgICBzZFJlZENvbm5lY3RvciA9IC0xLjA7IC8vIEluc2lkZSB0aGUgY29ubmVjdG9yXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQmx1ZSBjb25uZWN0b3IgKEExLUEyIGRpYWdvbmFsKTpcbiAgICAgIC8vIC0gTXVzdCBiZSBvdXRzaWRlIGlubmVyIEEgY2lyY2xlcyAoQTEgYW5kIEEyKVxuICAgICAgLy8gLSBNdXN0IGJlIG91dHNpZGUgb3V0ZXIgQiBjaXJjbGVzIChCMSBhbmQgQjIpXG4gICAgICBmbG9hdCBzZEJsdWVDb25uZWN0b3IgPSAxLjA7XG4gICAgICBpZiAoZHJhd0JsdWVDb25uZWN0b3IpIHtcbiAgICAgICAgYm9vbCBvdXRzaWRlSW5uZXJBID0gKHNkQTFJbm5lciA+IDAuMCkgJiYgKHNkQTJJbm5lciA+IDAuMCk7XG4gICAgICAgIGJvb2wgb3V0c2lkZU91dGVyQiA9IChzZEIxT3V0ZXIgPiAwLjApICYmIChzZEIyT3V0ZXIgPiAwLjApO1xuICAgICAgICBcbiAgICAgICAgaWYgKG91dHNpZGVJbm5lckEgJiYgb3V0c2lkZU91dGVyQiAmJiBzZGZCb3VuZGluZ0JveCA8IDAuMCkge1xuICAgICAgICAgIHNkQmx1ZUNvbm5lY3RvciA9IC0xLjA7IC8vIEluc2lkZSB0aGUgY29ubmVjdG9yXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gRGV0ZXJtaW5lIGlmIHdlJ3JlIGluc2lkZSBlaXRoZXIgY29ubmVjdG9yXG4gICAgICBpZiAoc2RSZWRDb25uZWN0b3IgPCAwLjAgfHwgc2RCbHVlQ29ubmVjdG9yIDwgMC4wKSB7XG4gICAgICAgIC8vIENob29zZSBjb2xvciBiYXNlZCBvbiB3aGljaCBjb25uZWN0b3Igd2UncmUgaW5zaWRlXG4gICAgICAgIGlmIChzZFJlZENvbm5lY3RvciA8IDAuMCkge1xuICAgICAgICAgIC8vIFJlZCBjb25uZWN0b3JcbiAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDEuMCwgMC4wLCAwLjAsIDEuMCk7IC8vIFJlZFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEJsdWUgY29ubmVjdG9yXG4gICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjAsIDAuNSwgMS4wLCAxLjApOyAvLyBCbHVlXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpc2NhcmQ7IC8vIE91dHNpZGUgYm90aCBjb25uZWN0b3JzXG4gICAgICB9XG4gICAgfVxuICBgXG4pO1xuXG4vLyBBZGQgYSB1bmlxdWUga2V5IGZvciBITVIgcHVycG9zZXMgd2l0aCBSM0ZcblNpbXBsZUNvbm5lY3Rvck1hdGVyaWFsLmtleSA9IFRIUkVFLk1hdGhVdGlscy5nZW5lcmF0ZVVVSUQoKTtcblxuZXhwb3J0IHsgU2ltcGxlQ29ubmVjdG9yTWF0ZXJpYWwgfTsgIl0sIm5hbWVzIjpbIlRIUkVFIiwic2hhZGVyTWF0ZXJpYWwiLCJTaW1wbGVDb25uZWN0b3JNYXRlcmlhbCIsInVfcmFkaXVzQiIsInVfcmFkaXVzQSIsInVfYm94U2l6ZSIsInVfc3BhY2luZyIsInVfYWN0aXZlQ29ubmVjdG9yIiwidV9ncmlkU3RhdGUiLCJEYXRhVGV4dHVyZSIsIkZsb2F0MzJBcnJheSIsIlJHQkFGb3JtYXQiLCJGbG9hdFR5cGUiLCJrZXkiLCJNYXRoVXRpbHMiLCJnZW5lcmF0ZVVVSUQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/SimpleConnectorMaterial.js\n");

/***/ }),

/***/ "./components/WebGLCanvas.js":
/*!***********************************!*\
  !*** ./components/WebGLCanvas.js ***!
  \***********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ WebGLCanvas)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-three/fiber */ \"@react-three/fiber\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-three/drei */ \"@react-three/drei\");\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_react_three_drei__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var leva__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! leva */ \"leva\");\n/* harmony import */ var leva__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(leva__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _ConnectorMaterial__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ConnectorMaterial */ \"./components/ConnectorMaterial.js\");\n/* harmony import */ var _GridConnectorMaterial__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./GridConnectorMaterial */ \"./components/GridConnectorMaterial.js\");\n/* harmony import */ var _SimpleConnectorMaterial__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./SimpleConnectorMaterial */ \"./components/SimpleConnectorMaterial.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([three__WEBPACK_IMPORTED_MODULE_4__, _ConnectorMaterial__WEBPACK_IMPORTED_MODULE_6__, _GridConnectorMaterial__WEBPACK_IMPORTED_MODULE_7__, _SimpleConnectorMaterial__WEBPACK_IMPORTED_MODULE_8__]);\n([three__WEBPACK_IMPORTED_MODULE_4__, _ConnectorMaterial__WEBPACK_IMPORTED_MODULE_6__, _GridConnectorMaterial__WEBPACK_IMPORTED_MODULE_7__, _SimpleConnectorMaterial__WEBPACK_IMPORTED_MODULE_8__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n\n // Import leva with button instead of monitor\n // We'll create this shader material\n // Import our new connector material\n // Import simple connector for debugging\n\n// Extend THREE namespace with our custom shader materials\n(0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.extend)({\n    ConnectorMaterial: _ConnectorMaterial__WEBPACK_IMPORTED_MODULE_6__.ConnectorMaterial,\n    GridConnectorMaterial: _GridConnectorMaterial__WEBPACK_IMPORTED_MODULE_7__.GridConnectorMaterial,\n    SimpleConnectorMaterial: _SimpleConnectorMaterial__WEBPACK_IMPORTED_MODULE_8__.SimpleConnectorMaterial\n});\nconst GRID_SIZE = 2;\nconst TOTAL_INSTANCES = GRID_SIZE * GRID_SIZE;\n// Helper to convert grid coords to instance ID\nconst getInstanceId = (row, col)=>row * GRID_SIZE + col;\n// Helper to convert instance ID to grid coords\nconst getGridCoords = (id)=>({\n        row: Math.floor(id / GRID_SIZE),\n        col: id % GRID_SIZE\n    });\n// Create a reusable dummy object for matrix calculation\nconst dummy = new three__WEBPACK_IMPORTED_MODULE_4__.Object3D();\n// Fixed base values\nconst BASE_VALUES = {\n    radiusB: 0.4,\n    radiusA: 0.5,\n    boxSize: 0.5,\n    baseSpacing: 0.89 // Reference spacing for scaling\n};\nfunction Scene() {\n    // Controls for radius, spacing, and debugging\n    const { gridSpacing, zoom, debug, showSimple } = (0,leva__WEBPACK_IMPORTED_MODULE_5__.useControls)({\n        gridSpacing: {\n            value: 0.89,\n            min: 0.5,\n            max: 2.0,\n            step: 0.01,\n            label: \"Grid Spacing\"\n        },\n        zoom: {\n            value: 1.0,\n            min: 0.5,\n            max: 3.0,\n            step: 0.1,\n            label: \"Camera Zoom\"\n        },\n        debug: {\n            value: true,\n            label: \"Debug Mode\"\n        },\n        showSimple: {\n            value: true,\n            label: \"Use Simple Connector\"\n        }\n    });\n    // Calculate scaled values for display\n    const scaleFactor = gridSpacing / BASE_VALUES.baseSpacing;\n    const scaledRadiusB = (BASE_VALUES.radiusB * scaleFactor).toFixed(3);\n    const scaledRadiusA = (BASE_VALUES.radiusA * scaleFactor).toFixed(3);\n    const scaledBoxSize = (BASE_VALUES.boxSize * scaleFactor).toFixed(3);\n    // State for active connector - 0: none, 1: red (AB), 2: blue (CD), 3: orange top row, 4: orange bottom row\n    const [activeConnector, setActiveConnector] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    // Display current values in a separate control panel\n    (0,leva__WEBPACK_IMPORTED_MODULE_5__.useControls)(\"Current Values\", {\n        innerRadius: {\n            value: scaledRadiusB,\n            label: \"Inner Radius (B)\",\n            disabled: true\n        },\n        outerRadius: {\n            value: scaledRadiusA,\n            label: \"Outer Radius (A)\",\n            disabled: true\n        },\n        boxSize: {\n            value: scaledBoxSize,\n            label: \"BBox Size\",\n            disabled: true\n        },\n        activeConnector: {\n            value: activeConnector.toString(),\n            label: \"Active Connector\",\n            disabled: true,\n            onChange: ()=>{}\n        }\n    });\n    // State for the 2x2 grid visibility\n    const [gridState, setGridState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([\n        // Initial state - all circles visible\n        [\n            {\n                showInner: true,\n                showOuter: true\n            },\n            {\n                showInner: true,\n                showOuter: true\n            }\n        ],\n        [\n            {\n                showInner: true,\n                showOuter: true\n            },\n            {\n                showInner: true,\n                showOuter: true\n            }\n        ]\n    ]);\n    const materialRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    const instancedMeshRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    const gridHelperRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    const cameraRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    // Reference for connector material\n    const gridConnectorMaterialRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    const connectorMeshRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    const debugMeshRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    // Reference for simple connector material (for debugging)\n    const simpleConnectorMaterialRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    const simpleConnectorMeshRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    // Attributes for instance visibility data\n    const instanceShowInner = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>new Float32Array(TOTAL_INSTANCES), []);\n    const instanceShowOuter = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>new Float32Array(TOTAL_INSTANCES), []);\n    // Store positions for click detection\n    const instancePositions = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(Array(TOTAL_INSTANCES).fill().map(()=>new three__WEBPACK_IMPORTED_MODULE_4__.Vector3()));\n    // Access three.js helpers\n    const { camera, raycaster, mouse } = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.useThree)();\n    // Log the grid state for debugging\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        console.log(\"Grid State:\", gridState);\n    }, [\n        gridState\n    ]);\n    // Create a data texture to store grid state for the connector shader\n    const gridStateTexture = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        const data = new Float32Array(4 * 4); // RGBA for each of the 4 cells\n        const texture = new three__WEBPACK_IMPORTED_MODULE_4__.DataTexture(data, 2, 2, three__WEBPACK_IMPORTED_MODULE_4__.RGBAFormat, three__WEBPACK_IMPORTED_MODULE_4__.FloatType);\n        texture.needsUpdate = true;\n        return texture;\n    }, []);\n    // Update the grid state texture and uniforms when controls change\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const data = gridStateTexture.image.data;\n        for(let row = 0; row < GRID_SIZE; row++){\n            for(let col = 0; col < GRID_SIZE; col++){\n                const idx = (row * GRID_SIZE + col) * 4;\n                data[idx] = gridState[row][col].showInner ? 1.0 : 0.0; // R - Inner circle\n                data[idx + 1] = gridState[row][col].showOuter ? 1.0 : 0.0; // G - Outer circle\n                data[idx + 2] = 0.0; // B - unused\n                data[idx + 3] = 1.0; // A - opacity\n            }\n        }\n        gridStateTexture.needsUpdate = true;\n        console.log(\"Updated grid state texture\", data);\n        // Calculate scale factor based on ratio to base grid spacing\n        const scaleFactor = gridSpacing / BASE_VALUES.baseSpacing;\n        // Update connector material uniforms (original grid one)\n        if (gridConnectorMaterialRef.current) {\n            gridConnectorMaterialRef.current.uniforms.u_radiusB.value = BASE_VALUES.radiusB * scaleFactor;\n            gridConnectorMaterialRef.current.uniforms.u_radiusA.value = BASE_VALUES.radiusA * scaleFactor;\n            gridConnectorMaterialRef.current.uniforms.u_spacing.value = gridSpacing;\n            gridConnectorMaterialRef.current.uniforms.u_gridState.value = gridStateTexture;\n            gridConnectorMaterialRef.current.uniforms.u_activeConnector = {\n                value: activeConnector\n            };\n            // Pass the connector thickness to the shader (if it exists - might remove later)\n            if (gridConnectorMaterialRef.current.uniforms.u_thickness) {\n            // gridConnectorMaterialRef.current.uniforms.u_thickness.value = connectorThickness; // Keep commented out for now\n            }\n            // Pass the curvature parameter (if it exists - might remove later)\n            if (gridConnectorMaterialRef.current.uniforms.u_curvature) {\n            // gridConnectorMaterialRef.current.uniforms.u_curvature.value = connectorCurvature; // Keep commented out for now\n            }\n        }\n        // Update simple connector material uniforms\n        if (simpleConnectorMaterialRef.current) {\n            // Scale the radius and box size values proportionally\n            simpleConnectorMaterialRef.current.uniforms.u_radiusB.value = BASE_VALUES.radiusB * scaleFactor;\n            simpleConnectorMaterialRef.current.uniforms.u_radiusA.value = BASE_VALUES.radiusA * scaleFactor;\n            simpleConnectorMaterialRef.current.uniforms.u_boxSize.value = BASE_VALUES.boxSize * scaleFactor;\n            simpleConnectorMaterialRef.current.uniforms.u_spacing.value = gridSpacing;\n            simpleConnectorMaterialRef.current.uniforms.u_gridState.value = gridStateTexture;\n            simpleConnectorMaterialRef.current.uniforms.u_activeConnector = {\n                value: activeConnector\n            };\n        }\n    }, [\n        gridState,\n        gridStateTexture,\n        gridSpacing,\n        debug,\n        showSimple,\n        activeConnector\n    ]);\n    // Update camera zoom based on control\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (camera) {\n            camera.zoom = 100 * (1 / zoom); // Adjust as needed for scale\n            camera.updateProjectionMatrix();\n        }\n    }, [\n        camera,\n        zoom\n    ]);\n    // Update instance matrices and visibility attributes based on state\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!instancedMeshRef.current) return;\n        let instanceId = 0;\n        // Calculate grid starting position\n        const startOffset = (GRID_SIZE - 1) * 0.5 * gridSpacing;\n        for(let row = 0; row < GRID_SIZE; row++){\n            for(let col = 0; col < GRID_SIZE; col++){\n                // Position at grid intersections\n                const x = col * gridSpacing - startOffset;\n                const y = -(row * gridSpacing - startOffset); // Y is inverted for screen coordinates\n                // Update the dummy object's position\n                dummy.position.set(x, y, 0);\n                dummy.updateMatrix();\n                // Set the instance matrix\n                instancedMeshRef.current.setMatrixAt(instanceId, dummy.matrix);\n                // Store position for click detection\n                instancePositions.current[instanceId].set(x, y, 0);\n                // Update visibility attributes\n                instanceShowInner[instanceId] = gridState[row][col].showInner ? 1.0 : 0.0;\n                instanceShowOuter[instanceId] = gridState[row][col].showOuter ? 1.0 : 0.0;\n                instanceId++;\n            }\n        }\n        // Mark attributes and matrix for update\n        instancedMeshRef.current.geometry.attributes.a_instanceShowInner.needsUpdate = true;\n        instancedMeshRef.current.geometry.attributes.a_instanceShowOuter.needsUpdate = true;\n        instancedMeshRef.current.instanceMatrix.needsUpdate = true;\n        // Update global uniforms with the radius values\n        if (materialRef.current) {\n            // Calculate scale factor based on ratio to base grid spacing\n            const scaleFactor = gridSpacing / BASE_VALUES.baseSpacing;\n            materialRef.current.uniforms.u_radiusB.value = BASE_VALUES.radiusB * scaleFactor;\n            materialRef.current.uniforms.u_radiusA.value = BASE_VALUES.radiusA * scaleFactor;\n            materialRef.current.uniforms.u_spacing.value = gridSpacing;\n        }\n        // Update grid helper to match spacing\n        if (gridHelperRef.current) {\n            gridHelperRef.current.scale.set(gridSpacing, gridSpacing, 1);\n        }\n    }, [\n        gridState,\n        gridSpacing,\n        instanceShowInner,\n        instanceShowOuter\n    ]);\n    // Handle click on the canvas\n    const handleClick = (event)=>{\n        if (!instancedMeshRef.current) return;\n        // Calculate scale factor based on ratio to base grid spacing\n        const scaleFactor = gridSpacing / BASE_VALUES.baseSpacing;\n        // Scale the radius values for hit detection\n        const scaledRadiusB = BASE_VALUES.radiusB * scaleFactor;\n        const scaledRadiusA = BASE_VALUES.radiusA * scaleFactor;\n        // Grid positions for detecting connector areas\n        const centerA = new three__WEBPACK_IMPORTED_MODULE_4__.Vector2(-gridSpacing * 0.5, gridSpacing * 0.5); // Top-left (A)\n        const centerB = new three__WEBPACK_IMPORTED_MODULE_4__.Vector2(gridSpacing * 0.5, -gridSpacing * 0.5); // Bottom-right (B)\n        const centerC = new three__WEBPACK_IMPORTED_MODULE_4__.Vector2(-gridSpacing * 0.5, -gridSpacing * 0.5); // Bottom-left (C)\n        const centerD = new three__WEBPACK_IMPORTED_MODULE_4__.Vector2(gridSpacing * 0.5, gridSpacing * 0.5); // Top-right (D)\n        // Create a 2D point from the click event for easier calculations\n        const clickPoint = new three__WEBPACK_IMPORTED_MODULE_4__.Vector2(event.point.x, event.point.y);\n        console.log(\"Click position:\", clickPoint);\n        console.log(\"Grid centers:\", {\n            A: centerA,\n            B: centerB,\n            C: centerC,\n            D: centerD\n        });\n        // First check if we clicked in any of the horizontal connector areas\n        const isInTopRowConnectorArea = isPointInHorizontalConnectorArea(clickPoint, centerA, centerD, scaledRadiusB);\n        const isInBottomRowConnectorArea = isPointInHorizontalConnectorArea(clickPoint, centerC, centerB, scaledRadiusB);\n        // Then check if we clicked in any diagonal connector area\n        const isInAnyDiagonalArea = isPointInConnectorArea(clickPoint, centerA, centerB, scaledRadiusB, scaledRadiusA) || isPointInConnectorArea(clickPoint, centerC, centerD, scaledRadiusB, scaledRadiusA);\n        console.log(\"Connector area detection:\", {\n            \"Top row\": isInTopRowConnectorArea,\n            \"Bottom row\": isInBottomRowConnectorArea,\n            \"Diagonal\": isInAnyDiagonalArea\n        });\n        // Handle clicks on connector areas\n        if (isInTopRowConnectorArea || isInBottomRowConnectorArea) {\n            console.log(\"Handling horizontal connector click\");\n            if (isInTopRowConnectorArea) {\n                console.log(\"Clicked top row connector\");\n                handleHorizontalConnectorClick(0, 0, 0, 1); // Top row: (0,0) to (0,1)\n                return;\n            }\n            if (isInBottomRowConnectorArea) {\n                console.log(\"Clicked bottom row connector\");\n                handleHorizontalConnectorClick(1, 0, 1, 1); // Bottom row: (1,0) to (1,1)\n                return;\n            }\n        } else if (isInAnyDiagonalArea) {\n            console.log(\"Handling diagonal connector click\");\n            handleDiagonalConnectorCycle();\n            return;\n        }\n        // If no connector area was hit, check for circle clicks\n        if (event.instanceId === undefined) return;\n        const instanceId = event.instanceId;\n        const { row, col } = getGridCoords(instanceId);\n        console.log(`Clicked instance: row=${row}, col=${col}`);\n        const currentState = gridState[row][col];\n        // Get instance position from our stored reference\n        const instancePosition = instancePositions.current[instanceId];\n        // Create a copy of the click point\n        const pointCopy = event.point.clone();\n        // Calculate distance from click to instance center\n        const distFromCenter = pointCopy.distanceTo(instancePosition);\n        let newInner = currentState.showInner;\n        let newOuter = currentState.showOuter;\n        if (distFromCenter <= scaledRadiusB) {\n            // Clicked inner circle\n            newInner = !currentState.showInner;\n            console.log(`Toggling inner circle: ${currentState.showInner} -> ${newInner}`);\n            // Check if toggling off an inner circle that was part of an active connector\n            if (!newInner) {\n                // Top-left circle is part of red connector or top horizontal connector\n                if (row === 0 && col === 0 && (activeConnector === 1 || activeConnector === 3)) {\n                    setActiveConnector(0);\n                } else if (row === 1 && col === 1 && (activeConnector === 1 || activeConnector === 4)) {\n                    setActiveConnector(0);\n                } else if (row === 1 && col === 0 && (activeConnector === 2 || activeConnector === 4)) {\n                    setActiveConnector(0);\n                } else if (row === 0 && col === 1 && (activeConnector === 2 || activeConnector === 3)) {\n                    setActiveConnector(0);\n                }\n            } else if (newInner) {\n                // Only activate connector if no connector is currently active,\n                // or if a connector is active in a different row\n                const currentRow = row;\n                const isConnectorInOtherRow = activeConnector === 3 && currentRow === 1 || // Top row connector active but we're in bottom row \n                activeConnector === 4 && currentRow === 0; // Bottom row connector active but we're in top row\n                if (activeConnector === 0 || isConnectorInOtherRow) {\n                    // Check for diagonal pairs - only if no connectors are active\n                    if (activeConnector === 0) {\n                        // Red connector (top-left to bottom-right)\n                        if (row === 0 && col === 0 && gridState[1][1].showInner || row === 1 && col === 1 && gridState[0][0].showInner) {\n                            setActiveConnector(1); // Activate red connector\n                            return;\n                        } else if (row === 1 && col === 0 && gridState[0][1].showInner || row === 0 && col === 1 && gridState[1][0].showInner) {\n                            setActiveConnector(2); // Activate blue connector\n                            return;\n                        }\n                    }\n                    // Check for horizontal pairs in the current row\n                    if (currentRow === 0) {\n                        // Top row connector - only activate if no bottom connector exists\n                        if (activeConnector !== 4 && (row === 0 && col === 0 && gridState[0][1].showInner || row === 0 && col === 1 && gridState[0][0].showInner)) {\n                            setActiveConnector(3); // Activate top row horizontal connector\n                        }\n                    } else if (currentRow === 1) {\n                        // Bottom row connector - only activate if no top connector exists\n                        if (activeConnector !== 3 && (row === 1 && col === 0 && gridState[1][1].showInner || row === 1 && col === 1 && gridState[1][0].showInner)) {\n                            setActiveConnector(4); // Activate bottom row horizontal connector\n                        }\n                    }\n                }\n            }\n        } else if (distFromCenter <= scaledRadiusA) {\n            // Clicked outer circle\n            newOuter = !currentState.showOuter;\n            console.log(`Toggling outer circle: ${currentState.showOuter} -> ${newOuter}`);\n        }\n        if (newInner !== currentState.showInner || newOuter !== currentState.showOuter) {\n            setGridState((prevState)=>{\n                const newState = JSON.parse(JSON.stringify(prevState)); // Deep copy\n                newState[row][col] = {\n                    showInner: newInner,\n                    showOuter: newOuter\n                };\n                return newState;\n            });\n        }\n    };\n    // Helper function to determine if a point is in a diagonal connector area\n    const isPointInConnectorArea = (point, center1, center2, innerRadius, outerRadius)=>{\n        // Check that point is not inside either inner circle\n        const distToCenter1 = point.distanceTo(center1);\n        const distToCenter2 = point.distanceTo(center2);\n        if (distToCenter1 < innerRadius || distToCenter2 < innerRadius) {\n            return false; // Inside an inner circle\n        }\n        // Project point onto the line connecting the centers\n        const direction = new three__WEBPACK_IMPORTED_MODULE_4__.Vector2().subVectors(center2, center1).normalize();\n        const center1ToPoint = new three__WEBPACK_IMPORTED_MODULE_4__.Vector2().subVectors(point, center1);\n        const projectionLength = center1ToPoint.dot(direction);\n        // Check if projection falls between the two centers (with some buffer)\n        const distanceBetweenCenters = center1.distanceTo(center2);\n        // Define the active area along the diagonal line\n        if (projectionLength < innerRadius || projectionLength > distanceBetweenCenters - innerRadius) {\n            return false; // Outside the region between circles\n        }\n        // Calculate perpendicular distance from point to line\n        const projectedPoint = new three__WEBPACK_IMPORTED_MODULE_4__.Vector2().copy(center1).addScaledVector(direction, projectionLength);\n        const perpDistance = point.distanceTo(projectedPoint);\n        // Define a narrow corridor along the diagonal line\n        const connectorWidth = innerRadius * 0.8;\n        return perpDistance < connectorWidth;\n    };\n    // Helper function to determine if a point is in a horizontal connector area (Area A)\n    const isPointInHorizontalConnectorArea = (point, center1, center2, radius)=>{\n        // Check that point is not inside either inner circle\n        const distToCenter1 = point.distanceTo(center1);\n        const distToCenter2 = point.distanceTo(center2);\n        if (distToCenter1 < radius || distToCenter2 < radius) {\n            return false; // Inside an inner circle\n        }\n        // Calculate the rectangle bounds for the horizontal connector (Area A)\n        // Ensure it's wider and shorter than the diagonal area\n        const midY = (center1.y + center2.y) / 2;\n        const left = Math.min(center1.x, center2.x) + radius;\n        const right = Math.max(center1.x, center2.x) - radius;\n        const halfHeight = radius * 0.6; // Narrower height to distinguish from diagonal\n        // Check if point is within the horizontal connector rectangle\n        return point.x >= left && point.x <= right && point.y >= midY - halfHeight && point.y <= midY + halfHeight;\n    };\n    // Helper function to handle horizontal connector clicks (toggle on/off)\n    const handleHorizontalConnectorClick = (row1, col1, row2, col2)=>{\n        // Check if the circles in this row are already part of diagonal connectors\n        const hasCircle1InDiagonalConnector = activeConnector === 1 && (row1 === 0 && col1 === 0 || row1 === 1 && col1 === 1) || activeConnector === 2 && (row1 === 1 && col1 === 0 || row1 === 0 && col1 === 1);\n        const hasCircle2InDiagonalConnector = activeConnector === 1 && (row2 === 0 && col2 === 0 || row2 === 1 && col2 === 1) || activeConnector === 2 && (row2 === 1 && col2 === 0 || row2 === 0 && col2 === 1);\n        // Don't toggle if any circle is part of a diagonal connector\n        if (hasCircle1InDiagonalConnector || hasCircle2InDiagonalConnector) {\n            console.log(\"Can't toggle horizontal connector: circles already part of diagonal connector\");\n            return;\n        }\n        // Check if both circles are active\n        if (!gridState[row1][col1].showInner || !gridState[row2][col2].showInner) {\n            console.log(\"Can't toggle horizontal connector: one or both circles are inactive\");\n            return;\n        }\n        // Determine the horizontal connector's state (3 for top row, 4 for bottom row)\n        const horizontalConnectorState = row1 === 0 ? 3 : 4;\n        // Toggle the connector - always toggle regardless of current state\n        setActiveConnector((prevState)=>{\n            // If this connector is already active, turn it off\n            if (prevState === horizontalConnectorState) {\n                return 0;\n            } else if (prevState === 3 && row1 === 0 || prevState === 4 && row1 === 1) {\n                return 0; // Turn off existing connector in same row\n            } else {\n                return horizontalConnectorState;\n            }\n        });\n    };\n    // Helper function to handle diagonal connector clicks (cycle through none/red/blue)\n    const handleDiagonalConnectorCycle = ()=>{\n        // Check if any of these circles are part of horizontal connectors\n        const hasCircleInHorizontalConnector = activeConnector === 3 || activeConnector === 4;\n        if (hasCircleInHorizontalConnector) {\n            console.log(\"Can't toggle diagonal connector: circles already part of horizontal connector\");\n            return;\n        }\n        // Check if all four circles are active\n        if (!gridState[0][0].showInner || !gridState[0][1].showInner || !gridState[1][0].showInner || !gridState[1][1].showInner) {\n            console.log(\"Can't toggle diagonal connector: one or more circles are inactive\");\n            return;\n        }\n        // Cycle through diagonal states: None (0) -> Red (1) -> Blue (2) -> None (0)\n        setActiveConnector((prevState)=>{\n            if (prevState === 0) return 1; // None -> Red\n            else if (prevState === 1) return 2; // Red -> Blue\n            else return 0; // Blue -> None\n        });\n    };\n    // Calculate plane size based on the grid size and spacing\n    const connectorPlaneSize = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>GRID_SIZE * gridSpacing + Math.max(BASE_VALUES.radiusA, BASE_VALUES.radiusB) * 2, [\n        gridSpacing,\n        BASE_VALUES.radiusA,\n        BASE_VALUES.radiusB\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            debug && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"mesh\", {\n                ref: debugMeshRef,\n                position: [\n                    0,\n                    0,\n                    -0.2\n                ],\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"planeGeometry\", {\n                        args: [\n                            connectorPlaneSize,\n                            connectorPlaneSize\n                        ]\n                    }, void 0, false, {\n                        fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                        lineNumber: 533,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"meshBasicMaterial\", {\n                        color: \"blue\",\n                        opacity: 0.1,\n                        transparent: true\n                    }, void 0, false, {\n                        fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                        lineNumber: 534,\n                        columnNumber: 11\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                lineNumber: 532,\n                columnNumber: 9\n            }, this),\n            debug && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"mesh\", {\n                        position: [\n                            0,\n                            gridSpacing * 0.5,\n                            0.05\n                        ],\n                        visible: false,\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"planeGeometry\", {\n                                args: [\n                                    gridSpacing - 2 * scaledRadiusB,\n                                    scaledRadiusB * 0.6 * 2\n                                ]\n                            }, void 0, false, {\n                                fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                                lineNumber: 543,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"meshBasicMaterial\", {\n                                opacity: 0,\n                                transparent: true\n                            }, void 0, false, {\n                                fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                                lineNumber: 547,\n                                columnNumber: 13\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                        lineNumber: 542,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"mesh\", {\n                        position: [\n                            0,\n                            -gridSpacing * 0.5,\n                            0.05\n                        ],\n                        visible: false,\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"planeGeometry\", {\n                                args: [\n                                    gridSpacing - 2 * scaledRadiusB,\n                                    scaledRadiusB * 0.6 * 2\n                                ]\n                            }, void 0, false, {\n                                fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                                lineNumber: 551,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"meshBasicMaterial\", {\n                                opacity: 0,\n                                transparent: true\n                            }, void 0, false, {\n                                fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                                lineNumber: 555,\n                                columnNumber: 13\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                        lineNumber: 550,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"mesh\", {\n                        position: [\n                            0,\n                            0,\n                            0.05\n                        ],\n                        rotation: [\n                            0,\n                            0,\n                            -Math.PI / 4\n                        ],\n                        visible: false,\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"planeGeometry\", {\n                                args: [\n                                    Math.sqrt(2) * gridSpacing - 2 * scaledRadiusB,\n                                    scaledRadiusB * 0.8 * 2\n                                ]\n                            }, void 0, false, {\n                                fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                                lineNumber: 559,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"meshBasicMaterial\", {\n                                opacity: 0,\n                                transparent: true\n                            }, void 0, false, {\n                                fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                                lineNumber: 563,\n                                columnNumber: 13\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                        lineNumber: 558,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"mesh\", {\n                        position: [\n                            0,\n                            0,\n                            0.05\n                        ],\n                        rotation: [\n                            0,\n                            0,\n                            Math.PI / 4\n                        ],\n                        visible: false,\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"planeGeometry\", {\n                                args: [\n                                    Math.sqrt(2) * gridSpacing - 2 * scaledRadiusB,\n                                    scaledRadiusB * 0.8 * 2\n                                ]\n                            }, void 0, false, {\n                                fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                                lineNumber: 567,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"meshBasicMaterial\", {\n                                opacity: 0,\n                                transparent: true\n                            }, void 0, false, {\n                                fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                                lineNumber: 571,\n                                columnNumber: 13\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                        lineNumber: 566,\n                        columnNumber: 11\n                    }, this)\n                ]\n            }, void 0, true),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"mesh\", {\n                ref: simpleConnectorMeshRef,\n                position: [\n                    0,\n                    0,\n                    0.1\n                ],\n                visible: showSimple,\n                onClick: handleClick,\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"planeGeometry\", {\n                        args: [\n                            connectorPlaneSize,\n                            connectorPlaneSize\n                        ]\n                    }, void 0, false, {\n                        fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                        lineNumber: 583,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"simpleConnectorMaterial\", {\n                        ref: simpleConnectorMaterialRef,\n                        transparent: true,\n                        depthTest: false\n                    }, _SimpleConnectorMaterial__WEBPACK_IMPORTED_MODULE_8__.SimpleConnectorMaterial.key, false, {\n                        fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                        lineNumber: 584,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                lineNumber: 577,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"mesh\", {\n                ref: connectorMeshRef,\n                position: [\n                    0,\n                    0,\n                    -0.1\n                ],\n                visible: !showSimple,\n                onClick: handleClick,\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"planeGeometry\", {\n                        args: [\n                            connectorPlaneSize,\n                            connectorPlaneSize\n                        ]\n                    }, void 0, false, {\n                        fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                        lineNumber: 599,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"gridConnectorMaterial\", {\n                        ref: gridConnectorMaterialRef,\n                        transparent: true,\n                        depthTest: false\n                    }, _GridConnectorMaterial__WEBPACK_IMPORTED_MODULE_7__.GridConnectorMaterial.key, false, {\n                        fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                        lineNumber: 600,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                lineNumber: 593,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"mesh\", {\n                position: [\n                    0,\n                    0,\n                    -0.15\n                ],\n                onClick: handleClick,\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"planeGeometry\", {\n                        args: [\n                            connectorPlaneSize,\n                            connectorPlaneSize\n                        ]\n                    }, void 0, false, {\n                        fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                        lineNumber: 613,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"meshBasicMaterial\", {\n                        color: \"white\",\n                        opacity: 0.01,\n                        transparent: true\n                    }, void 0, false, {\n                        fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                        lineNumber: 614,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                lineNumber: 609,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"instancedMesh\", {\n                ref: instancedMeshRef,\n                args: [\n                    null,\n                    null,\n                    TOTAL_INSTANCES\n                ],\n                onClick: handleClick,\n                position: [\n                    0,\n                    0,\n                    0\n                ],\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"planeGeometry\", {\n                        args: [\n                            connectorPlaneSize,\n                            connectorPlaneSize\n                        ],\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"instancedBufferAttribute\", {\n                                attach: \"attributes-a_instanceShowInner\",\n                                args: [\n                                    instanceShowInner,\n                                    1\n                                ]\n                            }, void 0, false, {\n                                fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                                lineNumber: 625,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"instancedBufferAttribute\", {\n                                attach: \"attributes-a_instanceShowOuter\",\n                                args: [\n                                    instanceShowOuter,\n                                    1\n                                ]\n                            }, void 0, false, {\n                                fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                                lineNumber: 629,\n                                columnNumber: 11\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                        lineNumber: 624,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"connectorMaterial\", {\n                        ref: materialRef,\n                        transparent: true\n                    }, _ConnectorMaterial__WEBPACK_IMPORTED_MODULE_6__.ConnectorMaterial.key, false, {\n                        fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                        lineNumber: 634,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                lineNumber: 618,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"group\", {\n                ref: gridHelperRef,\n                position: [\n                    0,\n                    0,\n                    -0.2\n                ],\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"gridHelper\", {\n                    args: [\n                        10,\n                        10\n                    ],\n                    rotation: [\n                        Math.PI / 2,\n                        0,\n                        0\n                    ]\n                }, void 0, false, {\n                    fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                    lineNumber: 643,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                lineNumber: 642,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true);\n}\nfunction WebGLCanvas() {\n    return(// Set up the R3F Canvas\n    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.Canvas, {\n        style: {\n            background: \"#f0f0f0\"\n        },\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_react_three_drei__WEBPACK_IMPORTED_MODULE_3__.OrthographicCamera, {\n                makeDefault: true,\n                zoom: 100,\n                position: [\n                    0,\n                    0,\n                    5\n                ],\n                rotation: [\n                    0,\n                    0,\n                    0\n                ]\n            }, void 0, false, {\n                fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                lineNumber: 657,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ambientLight\", {\n                intensity: 0.8\n            }, void 0, false, {\n                fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                lineNumber: 663,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Scene, {}, void 0, false, {\n                fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n                lineNumber: 664,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/ian/cursor_projects/webGL_meta/components/WebGLCanvas.js\",\n        lineNumber: 655,\n        columnNumber: 5\n    }, this));\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDek0sc0RBQU1BO1FBQUMwTSxPQUFPO1lBQUVDLFlBQVk7UUFBVTs7MEJBRXJDLDhEQUFDdk0saUVBQWtCQTtnQkFDakJ3TSxXQUFXO2dCQUNYN0ssTUFBTTtnQkFDTnNFLFVBQVU7b0JBQUM7b0JBQUc7b0JBQUc7aUJBQUU7Z0JBQ25Cc0YsVUFBVTtvQkFBQztvQkFBRztvQkFBRztpQkFBRTs7Ozs7OzBCQUVyQiw4REFBQ2tCO2dCQUFhQyxXQUFXOzs7Ozs7MEJBQ3pCLDhEQUFDakw7Ozs7Ozs7Ozs7O0FBR1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWJnbC1kb3QtZ3JpZC1tdnAvLi9jb21wb25lbnRzL1dlYkdMQ2FudmFzLmpzPzIxZWUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZVJlZiwgdXNlTWVtbywgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IENhbnZhcywgdXNlRnJhbWUsIGV4dGVuZCwgdXNlVGhyZWUgfSBmcm9tICdAcmVhY3QtdGhyZWUvZmliZXInO1xuaW1wb3J0IHsgT3J0aG9ncmFwaGljQ2FtZXJhIH0gZnJvbSAnQHJlYWN0LXRocmVlL2RyZWknO1xuaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgdXNlQ29udHJvbHMsIGZvbGRlciwgYnV0dG9uIH0gZnJvbSAnbGV2YSc7IC8vIEltcG9ydCBsZXZhIHdpdGggYnV0dG9uIGluc3RlYWQgb2YgbW9uaXRvclxuaW1wb3J0IHsgQ29ubmVjdG9yTWF0ZXJpYWwgfSBmcm9tICcuL0Nvbm5lY3Rvck1hdGVyaWFsJzsgLy8gV2UnbGwgY3JlYXRlIHRoaXMgc2hhZGVyIG1hdGVyaWFsXG5pbXBvcnQgeyBHcmlkQ29ubmVjdG9yTWF0ZXJpYWwgfSBmcm9tICcuL0dyaWRDb25uZWN0b3JNYXRlcmlhbCc7IC8vIEltcG9ydCBvdXIgbmV3IGNvbm5lY3RvciBtYXRlcmlhbFxuaW1wb3J0IHsgU2ltcGxlQ29ubmVjdG9yTWF0ZXJpYWwgfSBmcm9tICcuL1NpbXBsZUNvbm5lY3Rvck1hdGVyaWFsJzsgLy8gSW1wb3J0IHNpbXBsZSBjb25uZWN0b3IgZm9yIGRlYnVnZ2luZ1xuaW1wb3J0IHsgSHRtbCB9IGZyb20gJ0ByZWFjdC10aHJlZS9kcmVpJztcblxuLy8gRXh0ZW5kIFRIUkVFIG5hbWVzcGFjZSB3aXRoIG91ciBjdXN0b20gc2hhZGVyIG1hdGVyaWFsc1xuZXh0ZW5kKHsgQ29ubmVjdG9yTWF0ZXJpYWwsIEdyaWRDb25uZWN0b3JNYXRlcmlhbCwgU2ltcGxlQ29ubmVjdG9yTWF0ZXJpYWwgfSk7XG5cbmNvbnN0IEdSSURfU0laRSA9IDI7XG5jb25zdCBUT1RBTF9JTlNUQU5DRVMgPSBHUklEX1NJWkUgKiBHUklEX1NJWkU7XG5cbi8vIEhlbHBlciB0byBjb252ZXJ0IGdyaWQgY29vcmRzIHRvIGluc3RhbmNlIElEXG5jb25zdCBnZXRJbnN0YW5jZUlkID0gKHJvdywgY29sKSA9PiByb3cgKiBHUklEX1NJWkUgKyBjb2w7XG4vLyBIZWxwZXIgdG8gY29udmVydCBpbnN0YW5jZSBJRCB0byBncmlkIGNvb3Jkc1xuY29uc3QgZ2V0R3JpZENvb3JkcyA9IChpZCkgPT4gKHsgcm93OiBNYXRoLmZsb29yKGlkIC8gR1JJRF9TSVpFKSwgY29sOiBpZCAlIEdSSURfU0laRSB9KTtcblxuLy8gQ3JlYXRlIGEgcmV1c2FibGUgZHVtbXkgb2JqZWN0IGZvciBtYXRyaXggY2FsY3VsYXRpb25cbmNvbnN0IGR1bW15ID0gbmV3IFRIUkVFLk9iamVjdDNEKCk7XG5cbi8vIEZpeGVkIGJhc2UgdmFsdWVzXG5jb25zdCBCQVNFX1ZBTFVFUyA9IHtcbiAgcmFkaXVzQjogMC40LCAgLy8gSW5uZXIgcmFkaXVzXG4gIHJhZGl1c0E6IDAuNSwgIC8vIE91dGVyIHJhZGl1c1xuICBib3hTaXplOiAwLjUsICAvLyBCb3VuZGluZyBib3ggc2l6ZVxuICBiYXNlU3BhY2luZzogMC44OSAvLyBSZWZlcmVuY2Ugc3BhY2luZyBmb3Igc2NhbGluZ1xufTtcblxuZnVuY3Rpb24gU2NlbmUoKSB7XG4gIC8vIENvbnRyb2xzIGZvciByYWRpdXMsIHNwYWNpbmcsIGFuZCBkZWJ1Z2dpbmdcbiAgY29uc3QgeyBncmlkU3BhY2luZywgem9vbSwgZGVidWcsIHNob3dTaW1wbGUgfSA9IHVzZUNvbnRyb2xzKHtcbiAgICBncmlkU3BhY2luZzogeyB2YWx1ZTogMC44OSwgbWluOiAwLjUsIG1heDogMi4wLCBzdGVwOiAwLjAxLCBsYWJlbDogJ0dyaWQgU3BhY2luZycgfSxcbiAgICB6b29tOiB7IHZhbHVlOiAxLjAsIG1pbjogMC41LCBtYXg6IDMuMCwgc3RlcDogMC4xLCBsYWJlbDogJ0NhbWVyYSBab29tJyB9LFxuICAgIGRlYnVnOiB7IHZhbHVlOiB0cnVlLCBsYWJlbDogJ0RlYnVnIE1vZGUnIH0sXG4gICAgc2hvd1NpbXBsZTogeyB2YWx1ZTogdHJ1ZSwgbGFiZWw6ICdVc2UgU2ltcGxlIENvbm5lY3RvcicgfSxcbiAgfSk7XG4gIFxuICAvLyBDYWxjdWxhdGUgc2NhbGVkIHZhbHVlcyBmb3IgZGlzcGxheVxuICBjb25zdCBzY2FsZUZhY3RvciA9IGdyaWRTcGFjaW5nIC8gQkFTRV9WQUxVRVMuYmFzZVNwYWNpbmc7XG4gIGNvbnN0IHNjYWxlZFJhZGl1c0IgPSAoQkFTRV9WQUxVRVMucmFkaXVzQiAqIHNjYWxlRmFjdG9yKS50b0ZpeGVkKDMpO1xuICBjb25zdCBzY2FsZWRSYWRpdXNBID0gKEJBU0VfVkFMVUVTLnJhZGl1c0EgKiBzY2FsZUZhY3RvcikudG9GaXhlZCgzKTtcbiAgY29uc3Qgc2NhbGVkQm94U2l6ZSA9IChCQVNFX1ZBTFVFUy5ib3hTaXplICogc2NhbGVGYWN0b3IpLnRvRml4ZWQoMyk7XG4gIFxuICAvLyBTdGF0ZSBmb3IgYWN0aXZlIGNvbm5lY3RvciAtIDA6IG5vbmUsIDE6IHJlZCAoQUIpLCAyOiBibHVlIChDRCksIDM6IG9yYW5nZSB0b3Agcm93LCA0OiBvcmFuZ2UgYm90dG9tIHJvd1xuICBjb25zdCBbYWN0aXZlQ29ubmVjdG9yLCBzZXRBY3RpdmVDb25uZWN0b3JdID0gdXNlU3RhdGUoMCk7XG4gIFxuICAvLyBEaXNwbGF5IGN1cnJlbnQgdmFsdWVzIGluIGEgc2VwYXJhdGUgY29udHJvbCBwYW5lbFxuICB1c2VDb250cm9scyhcbiAgICAnQ3VycmVudCBWYWx1ZXMnLFxuICAgIHtcbiAgICAgIGlubmVyUmFkaXVzOiB7IHZhbHVlOiBzY2FsZWRSYWRpdXNCLCBsYWJlbDogJ0lubmVyIFJhZGl1cyAoQiknLCBkaXNhYmxlZDogdHJ1ZSB9LFxuICAgICAgb3V0ZXJSYWRpdXM6IHsgdmFsdWU6IHNjYWxlZFJhZGl1c0EsIGxhYmVsOiAnT3V0ZXIgUmFkaXVzIChBKScsIGRpc2FibGVkOiB0cnVlIH0sXG4gICAgICBib3hTaXplOiB7IHZhbHVlOiBzY2FsZWRCb3hTaXplLCBsYWJlbDogJ0JCb3ggU2l6ZScsIGRpc2FibGVkOiB0cnVlIH0sXG4gICAgICBhY3RpdmVDb25uZWN0b3I6IHsgXG4gICAgICAgIHZhbHVlOiBhY3RpdmVDb25uZWN0b3IudG9TdHJpbmcoKSwgXG4gICAgICAgIGxhYmVsOiAnQWN0aXZlIENvbm5lY3RvcicsIFxuICAgICAgICBkaXNhYmxlZDogdHJ1ZSxcbiAgICAgICAgb25DaGFuZ2U6ICgpID0+IHt9LCAvLyBEdW1teSBmdW5jdGlvbiB0byBwcmV2ZW50IGVycm9yc1xuICAgICAgfSxcbiAgICB9XG4gICk7XG5cbiAgLy8gU3RhdGUgZm9yIHRoZSAyeDIgZ3JpZCB2aXNpYmlsaXR5XG4gIGNvbnN0IFtncmlkU3RhdGUsIHNldEdyaWRTdGF0ZV0gPSB1c2VTdGF0ZShbXG4gICAgLy8gSW5pdGlhbCBzdGF0ZSAtIGFsbCBjaXJjbGVzIHZpc2libGVcbiAgICBbeyBzaG93SW5uZXI6IHRydWUsIHNob3dPdXRlcjogdHJ1ZSB9LCB7IHNob3dJbm5lcjogdHJ1ZSwgc2hvd091dGVyOiB0cnVlIH1dLFxuICAgIFt7IHNob3dJbm5lcjogdHJ1ZSwgc2hvd091dGVyOiB0cnVlIH0sIHsgc2hvd0lubmVyOiB0cnVlLCBzaG93T3V0ZXI6IHRydWUgfV1cbiAgXSk7XG5cbiAgY29uc3QgbWF0ZXJpYWxSZWYgPSB1c2VSZWYoKTtcbiAgY29uc3QgaW5zdGFuY2VkTWVzaFJlZiA9IHVzZVJlZigpO1xuICBjb25zdCBncmlkSGVscGVyUmVmID0gdXNlUmVmKCk7XG4gIGNvbnN0IGNhbWVyYVJlZiA9IHVzZVJlZigpO1xuXG4gIC8vIFJlZmVyZW5jZSBmb3IgY29ubmVjdG9yIG1hdGVyaWFsXG4gIGNvbnN0IGdyaWRDb25uZWN0b3JNYXRlcmlhbFJlZiA9IHVzZVJlZigpO1xuICBjb25zdCBjb25uZWN0b3JNZXNoUmVmID0gdXNlUmVmKCk7XG4gIGNvbnN0IGRlYnVnTWVzaFJlZiA9IHVzZVJlZigpO1xuXG4gIC8vIFJlZmVyZW5jZSBmb3Igc2ltcGxlIGNvbm5lY3RvciBtYXRlcmlhbCAoZm9yIGRlYnVnZ2luZylcbiAgY29uc3Qgc2ltcGxlQ29ubmVjdG9yTWF0ZXJpYWxSZWYgPSB1c2VSZWYoKTtcbiAgY29uc3Qgc2ltcGxlQ29ubmVjdG9yTWVzaFJlZiA9IHVzZVJlZigpO1xuXG4gIC8vIEF0dHJpYnV0ZXMgZm9yIGluc3RhbmNlIHZpc2liaWxpdHkgZGF0YVxuICBjb25zdCBpbnN0YW5jZVNob3dJbm5lciA9IHVzZU1lbW8oKCkgPT4gbmV3IEZsb2F0MzJBcnJheShUT1RBTF9JTlNUQU5DRVMpLCBbXSk7XG4gIGNvbnN0IGluc3RhbmNlU2hvd091dGVyID0gdXNlTWVtbygoKSA9PiBuZXcgRmxvYXQzMkFycmF5KFRPVEFMX0lOU1RBTkNFUyksIFtdKTtcblxuICAvLyBTdG9yZSBwb3NpdGlvbnMgZm9yIGNsaWNrIGRldGVjdGlvblxuICBjb25zdCBpbnN0YW5jZVBvc2l0aW9ucyA9IHVzZVJlZihBcnJheShUT1RBTF9JTlNUQU5DRVMpLmZpbGwoKS5tYXAoKCkgPT4gbmV3IFRIUkVFLlZlY3RvcjMoKSkpO1xuXG4gIC8vIEFjY2VzcyB0aHJlZS5qcyBoZWxwZXJzXG4gIGNvbnN0IHsgY2FtZXJhLCByYXljYXN0ZXIsIG1vdXNlIH0gPSB1c2VUaHJlZSgpO1xuXG4gIC8vIExvZyB0aGUgZ3JpZCBzdGF0ZSBmb3IgZGVidWdnaW5nXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ0dyaWQgU3RhdGU6JywgZ3JpZFN0YXRlKTtcbiAgfSwgW2dyaWRTdGF0ZV0pO1xuXG4gIC8vIENyZWF0ZSBhIGRhdGEgdGV4dHVyZSB0byBzdG9yZSBncmlkIHN0YXRlIGZvciB0aGUgY29ubmVjdG9yIHNoYWRlclxuICBjb25zdCBncmlkU3RhdGVUZXh0dXJlID0gdXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoNCAqIDQpOyAvLyBSR0JBIGZvciBlYWNoIG9mIHRoZSA0IGNlbGxzXG4gICAgY29uc3QgdGV4dHVyZSA9IG5ldyBUSFJFRS5EYXRhVGV4dHVyZShcbiAgICAgIGRhdGEsXG4gICAgICAyLCAvLyB3aWR0aCBmb3IgMngyIGdyaWRcbiAgICAgIDIsIC8vIGhlaWdodFxuICAgICAgVEhSRUUuUkdCQUZvcm1hdCxcbiAgICAgIFRIUkVFLkZsb2F0VHlwZVxuICAgICk7XG4gICAgdGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgcmV0dXJuIHRleHR1cmU7XG4gIH0sIFtdKTtcblxuICAvLyBVcGRhdGUgdGhlIGdyaWQgc3RhdGUgdGV4dHVyZSBhbmQgdW5pZm9ybXMgd2hlbiBjb250cm9scyBjaGFuZ2VcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBkYXRhID0gZ3JpZFN0YXRlVGV4dHVyZS5pbWFnZS5kYXRhO1xuICAgIFxuICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IEdSSURfU0laRTsgcm93KyspIHtcbiAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IEdSSURfU0laRTsgY29sKyspIHtcbiAgICAgICAgY29uc3QgaWR4ID0gKHJvdyAqIEdSSURfU0laRSArIGNvbCkgKiA0O1xuICAgICAgICBkYXRhW2lkeF0gPSBncmlkU3RhdGVbcm93XVtjb2xdLnNob3dJbm5lciA/IDEuMCA6IDAuMDsgICAgIC8vIFIgLSBJbm5lciBjaXJjbGVcbiAgICAgICAgZGF0YVtpZHggKyAxXSA9IGdyaWRTdGF0ZVtyb3ddW2NvbF0uc2hvd091dGVyID8gMS4wIDogMC4wOyAvLyBHIC0gT3V0ZXIgY2lyY2xlXG4gICAgICAgIGRhdGFbaWR4ICsgMl0gPSAwLjA7IC8vIEIgLSB1bnVzZWRcbiAgICAgICAgZGF0YVtpZHggKyAzXSA9IDEuMDsgLy8gQSAtIG9wYWNpdHlcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgZ3JpZFN0YXRlVGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgY29uc29sZS5sb2coJ1VwZGF0ZWQgZ3JpZCBzdGF0ZSB0ZXh0dXJlJywgZGF0YSk7XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIHNjYWxlIGZhY3RvciBiYXNlZCBvbiByYXRpbyB0byBiYXNlIGdyaWQgc3BhY2luZ1xuICAgIGNvbnN0IHNjYWxlRmFjdG9yID0gZ3JpZFNwYWNpbmcgLyBCQVNFX1ZBTFVFUy5iYXNlU3BhY2luZztcbiAgICBcbiAgICAvLyBVcGRhdGUgY29ubmVjdG9yIG1hdGVyaWFsIHVuaWZvcm1zIChvcmlnaW5hbCBncmlkIG9uZSlcbiAgICBpZiAoZ3JpZENvbm5lY3Rvck1hdGVyaWFsUmVmLmN1cnJlbnQpIHtcbiAgICAgIGdyaWRDb25uZWN0b3JNYXRlcmlhbFJlZi5jdXJyZW50LnVuaWZvcm1zLnVfcmFkaXVzQi52YWx1ZSA9IEJBU0VfVkFMVUVTLnJhZGl1c0IgKiBzY2FsZUZhY3RvcjtcbiAgICAgIGdyaWRDb25uZWN0b3JNYXRlcmlhbFJlZi5jdXJyZW50LnVuaWZvcm1zLnVfcmFkaXVzQS52YWx1ZSA9IEJBU0VfVkFMVUVTLnJhZGl1c0EgKiBzY2FsZUZhY3RvcjtcbiAgICAgIGdyaWRDb25uZWN0b3JNYXRlcmlhbFJlZi5jdXJyZW50LnVuaWZvcm1zLnVfc3BhY2luZy52YWx1ZSA9IGdyaWRTcGFjaW5nO1xuICAgICAgZ3JpZENvbm5lY3Rvck1hdGVyaWFsUmVmLmN1cnJlbnQudW5pZm9ybXMudV9ncmlkU3RhdGUudmFsdWUgPSBncmlkU3RhdGVUZXh0dXJlO1xuICAgICAgZ3JpZENvbm5lY3Rvck1hdGVyaWFsUmVmLmN1cnJlbnQudW5pZm9ybXMudV9hY3RpdmVDb25uZWN0b3IgPSB7IHZhbHVlOiBhY3RpdmVDb25uZWN0b3IgfTtcbiAgICAgIC8vIFBhc3MgdGhlIGNvbm5lY3RvciB0aGlja25lc3MgdG8gdGhlIHNoYWRlciAoaWYgaXQgZXhpc3RzIC0gbWlnaHQgcmVtb3ZlIGxhdGVyKVxuICAgICAgaWYgKGdyaWRDb25uZWN0b3JNYXRlcmlhbFJlZi5jdXJyZW50LnVuaWZvcm1zLnVfdGhpY2tuZXNzKSB7XG4gICAgICAgIC8vIGdyaWRDb25uZWN0b3JNYXRlcmlhbFJlZi5jdXJyZW50LnVuaWZvcm1zLnVfdGhpY2tuZXNzLnZhbHVlID0gY29ubmVjdG9yVGhpY2tuZXNzOyAvLyBLZWVwIGNvbW1lbnRlZCBvdXQgZm9yIG5vd1xuICAgICAgfVxuICAgICAgLy8gUGFzcyB0aGUgY3VydmF0dXJlIHBhcmFtZXRlciAoaWYgaXQgZXhpc3RzIC0gbWlnaHQgcmVtb3ZlIGxhdGVyKVxuICAgICAgaWYgKGdyaWRDb25uZWN0b3JNYXRlcmlhbFJlZi5jdXJyZW50LnVuaWZvcm1zLnVfY3VydmF0dXJlKSB7XG4gICAgICAgIC8vIGdyaWRDb25uZWN0b3JNYXRlcmlhbFJlZi5jdXJyZW50LnVuaWZvcm1zLnVfY3VydmF0dXJlLnZhbHVlID0gY29ubmVjdG9yQ3VydmF0dXJlOyAvLyBLZWVwIGNvbW1lbnRlZCBvdXQgZm9yIG5vd1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBVcGRhdGUgc2ltcGxlIGNvbm5lY3RvciBtYXRlcmlhbCB1bmlmb3Jtc1xuICAgIGlmIChzaW1wbGVDb25uZWN0b3JNYXRlcmlhbFJlZi5jdXJyZW50KSB7XG4gICAgICAvLyBTY2FsZSB0aGUgcmFkaXVzIGFuZCBib3ggc2l6ZSB2YWx1ZXMgcHJvcG9ydGlvbmFsbHlcbiAgICAgIHNpbXBsZUNvbm5lY3Rvck1hdGVyaWFsUmVmLmN1cnJlbnQudW5pZm9ybXMudV9yYWRpdXNCLnZhbHVlID0gQkFTRV9WQUxVRVMucmFkaXVzQiAqIHNjYWxlRmFjdG9yO1xuICAgICAgc2ltcGxlQ29ubmVjdG9yTWF0ZXJpYWxSZWYuY3VycmVudC51bmlmb3Jtcy51X3JhZGl1c0EudmFsdWUgPSBCQVNFX1ZBTFVFUy5yYWRpdXNBICogc2NhbGVGYWN0b3I7XG4gICAgICBzaW1wbGVDb25uZWN0b3JNYXRlcmlhbFJlZi5jdXJyZW50LnVuaWZvcm1zLnVfYm94U2l6ZS52YWx1ZSA9IEJBU0VfVkFMVUVTLmJveFNpemUgKiBzY2FsZUZhY3RvcjtcbiAgICAgIHNpbXBsZUNvbm5lY3Rvck1hdGVyaWFsUmVmLmN1cnJlbnQudW5pZm9ybXMudV9zcGFjaW5nLnZhbHVlID0gZ3JpZFNwYWNpbmc7XG4gICAgICBzaW1wbGVDb25uZWN0b3JNYXRlcmlhbFJlZi5jdXJyZW50LnVuaWZvcm1zLnVfZ3JpZFN0YXRlLnZhbHVlID0gZ3JpZFN0YXRlVGV4dHVyZTtcbiAgICAgIHNpbXBsZUNvbm5lY3Rvck1hdGVyaWFsUmVmLmN1cnJlbnQudW5pZm9ybXMudV9hY3RpdmVDb25uZWN0b3IgPSB7IHZhbHVlOiBhY3RpdmVDb25uZWN0b3IgfTtcbiAgICB9XG4gIH0sIFtncmlkU3RhdGUsIGdyaWRTdGF0ZVRleHR1cmUsIGdyaWRTcGFjaW5nLCBkZWJ1Zywgc2hvd1NpbXBsZSwgYWN0aXZlQ29ubmVjdG9yXSk7XG5cbiAgLy8gVXBkYXRlIGNhbWVyYSB6b29tIGJhc2VkIG9uIGNvbnRyb2xcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoY2FtZXJhKSB7XG4gICAgICBjYW1lcmEuem9vbSA9IDEwMCAqICgxL3pvb20pOyAvLyBBZGp1c3QgYXMgbmVlZGVkIGZvciBzY2FsZVxuICAgICAgY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICB9XG4gIH0sIFtjYW1lcmEsIHpvb21dKTtcblxuICAvLyBVcGRhdGUgaW5zdGFuY2UgbWF0cmljZXMgYW5kIHZpc2liaWxpdHkgYXR0cmlidXRlcyBiYXNlZCBvbiBzdGF0ZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghaW5zdGFuY2VkTWVzaFJlZi5jdXJyZW50KSByZXR1cm47XG5cbiAgICBsZXQgaW5zdGFuY2VJZCA9IDA7XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIGdyaWQgc3RhcnRpbmcgcG9zaXRpb25cbiAgICBjb25zdCBzdGFydE9mZnNldCA9IChHUklEX1NJWkUgLSAxKSAqIDAuNSAqIGdyaWRTcGFjaW5nO1xuICAgIFxuICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IEdSSURfU0laRTsgcm93KyspIHtcbiAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IEdSSURfU0laRTsgY29sKyspIHtcbiAgICAgICAgLy8gUG9zaXRpb24gYXQgZ3JpZCBpbnRlcnNlY3Rpb25zXG4gICAgICAgIGNvbnN0IHggPSBjb2wgKiBncmlkU3BhY2luZyAtIHN0YXJ0T2Zmc2V0O1xuICAgICAgICBjb25zdCB5ID0gLShyb3cgKiBncmlkU3BhY2luZyAtIHN0YXJ0T2Zmc2V0KTsgLy8gWSBpcyBpbnZlcnRlZCBmb3Igc2NyZWVuIGNvb3JkaW5hdGVzXG4gICAgICAgIFxuICAgICAgICAvLyBVcGRhdGUgdGhlIGR1bW15IG9iamVjdCdzIHBvc2l0aW9uXG4gICAgICAgIGR1bW15LnBvc2l0aW9uLnNldCh4LCB5LCAwKTtcbiAgICAgICAgZHVtbXkudXBkYXRlTWF0cml4KCk7XG4gICAgICAgIFxuICAgICAgICAvLyBTZXQgdGhlIGluc3RhbmNlIG1hdHJpeFxuICAgICAgICBpbnN0YW5jZWRNZXNoUmVmLmN1cnJlbnQuc2V0TWF0cml4QXQoaW5zdGFuY2VJZCwgZHVtbXkubWF0cml4KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFN0b3JlIHBvc2l0aW9uIGZvciBjbGljayBkZXRlY3Rpb25cbiAgICAgICAgaW5zdGFuY2VQb3NpdGlvbnMuY3VycmVudFtpbnN0YW5jZUlkXS5zZXQoeCwgeSwgMCk7XG4gICAgICAgIFxuICAgICAgICAvLyBVcGRhdGUgdmlzaWJpbGl0eSBhdHRyaWJ1dGVzXG4gICAgICAgIGluc3RhbmNlU2hvd0lubmVyW2luc3RhbmNlSWRdID0gZ3JpZFN0YXRlW3Jvd11bY29sXS5zaG93SW5uZXIgPyAxLjAgOiAwLjA7XG4gICAgICAgIGluc3RhbmNlU2hvd091dGVyW2luc3RhbmNlSWRdID0gZ3JpZFN0YXRlW3Jvd11bY29sXS5zaG93T3V0ZXIgPyAxLjAgOiAwLjA7XG4gICAgICAgIFxuICAgICAgICBpbnN0YW5jZUlkKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTWFyayBhdHRyaWJ1dGVzIGFuZCBtYXRyaXggZm9yIHVwZGF0ZVxuICAgIGluc3RhbmNlZE1lc2hSZWYuY3VycmVudC5nZW9tZXRyeS5hdHRyaWJ1dGVzLmFfaW5zdGFuY2VTaG93SW5uZXIubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIGluc3RhbmNlZE1lc2hSZWYuY3VycmVudC5nZW9tZXRyeS5hdHRyaWJ1dGVzLmFfaW5zdGFuY2VTaG93T3V0ZXIubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIGluc3RhbmNlZE1lc2hSZWYuY3VycmVudC5pbnN0YW5jZU1hdHJpeC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICAvLyBVcGRhdGUgZ2xvYmFsIHVuaWZvcm1zIHdpdGggdGhlIHJhZGl1cyB2YWx1ZXNcbiAgICBpZiAobWF0ZXJpYWxSZWYuY3VycmVudCkge1xuICAgICAgLy8gQ2FsY3VsYXRlIHNjYWxlIGZhY3RvciBiYXNlZCBvbiByYXRpbyB0byBiYXNlIGdyaWQgc3BhY2luZ1xuICAgICAgY29uc3Qgc2NhbGVGYWN0b3IgPSBncmlkU3BhY2luZyAvIEJBU0VfVkFMVUVTLmJhc2VTcGFjaW5nO1xuICAgICAgXG4gICAgICBtYXRlcmlhbFJlZi5jdXJyZW50LnVuaWZvcm1zLnVfcmFkaXVzQi52YWx1ZSA9IEJBU0VfVkFMVUVTLnJhZGl1c0IgKiBzY2FsZUZhY3RvcjtcbiAgICAgIG1hdGVyaWFsUmVmLmN1cnJlbnQudW5pZm9ybXMudV9yYWRpdXNBLnZhbHVlID0gQkFTRV9WQUxVRVMucmFkaXVzQSAqIHNjYWxlRmFjdG9yO1xuICAgICAgbWF0ZXJpYWxSZWYuY3VycmVudC51bmlmb3Jtcy51X3NwYWNpbmcudmFsdWUgPSBncmlkU3BhY2luZztcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgZ3JpZCBoZWxwZXIgdG8gbWF0Y2ggc3BhY2luZ1xuICAgIGlmIChncmlkSGVscGVyUmVmLmN1cnJlbnQpIHtcbiAgICAgIGdyaWRIZWxwZXJSZWYuY3VycmVudC5zY2FsZS5zZXQoZ3JpZFNwYWNpbmcsIGdyaWRTcGFjaW5nLCAxKTtcbiAgICB9XG5cbiAgfSwgW2dyaWRTdGF0ZSwgZ3JpZFNwYWNpbmcsIGluc3RhbmNlU2hvd0lubmVyLCBpbnN0YW5jZVNob3dPdXRlcl0pO1xuXG4gIC8vIEhhbmRsZSBjbGljayBvbiB0aGUgY2FudmFzXG4gIGNvbnN0IGhhbmRsZUNsaWNrID0gKGV2ZW50KSA9PiB7XG4gICAgaWYgKCFpbnN0YW5jZWRNZXNoUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgc2NhbGUgZmFjdG9yIGJhc2VkIG9uIHJhdGlvIHRvIGJhc2UgZ3JpZCBzcGFjaW5nXG4gICAgY29uc3Qgc2NhbGVGYWN0b3IgPSBncmlkU3BhY2luZyAvIEJBU0VfVkFMVUVTLmJhc2VTcGFjaW5nO1xuICAgIFxuICAgIC8vIFNjYWxlIHRoZSByYWRpdXMgdmFsdWVzIGZvciBoaXQgZGV0ZWN0aW9uXG4gICAgY29uc3Qgc2NhbGVkUmFkaXVzQiA9IEJBU0VfVkFMVUVTLnJhZGl1c0IgKiBzY2FsZUZhY3RvcjtcbiAgICBjb25zdCBzY2FsZWRSYWRpdXNBID0gQkFTRV9WQUxVRVMucmFkaXVzQSAqIHNjYWxlRmFjdG9yO1xuICAgIFxuICAgIC8vIEdyaWQgcG9zaXRpb25zIGZvciBkZXRlY3RpbmcgY29ubmVjdG9yIGFyZWFzXG4gICAgY29uc3QgY2VudGVyQSA9IG5ldyBUSFJFRS5WZWN0b3IyKC1ncmlkU3BhY2luZyAqIDAuNSwgZ3JpZFNwYWNpbmcgKiAwLjUpOyAgIC8vIFRvcC1sZWZ0IChBKVxuICAgIGNvbnN0IGNlbnRlckIgPSBuZXcgVEhSRUUuVmVjdG9yMihncmlkU3BhY2luZyAqIDAuNSwgLWdyaWRTcGFjaW5nICogMC41KTsgICAvLyBCb3R0b20tcmlnaHQgKEIpXG4gICAgY29uc3QgY2VudGVyQyA9IG5ldyBUSFJFRS5WZWN0b3IyKC1ncmlkU3BhY2luZyAqIDAuNSwgLWdyaWRTcGFjaW5nICogMC41KTsgIC8vIEJvdHRvbS1sZWZ0IChDKVxuICAgIGNvbnN0IGNlbnRlckQgPSBuZXcgVEhSRUUuVmVjdG9yMihncmlkU3BhY2luZyAqIDAuNSwgZ3JpZFNwYWNpbmcgKiAwLjUpOyAgICAvLyBUb3AtcmlnaHQgKEQpXG4gICAgXG4gICAgLy8gQ3JlYXRlIGEgMkQgcG9pbnQgZnJvbSB0aGUgY2xpY2sgZXZlbnQgZm9yIGVhc2llciBjYWxjdWxhdGlvbnNcbiAgICBjb25zdCBjbGlja1BvaW50ID0gbmV3IFRIUkVFLlZlY3RvcjIoZXZlbnQucG9pbnQueCwgZXZlbnQucG9pbnQueSk7XG4gICAgXG4gICAgY29uc29sZS5sb2coXCJDbGljayBwb3NpdGlvbjpcIiwgY2xpY2tQb2ludCk7XG4gICAgY29uc29sZS5sb2coXCJHcmlkIGNlbnRlcnM6XCIsIHsgQTogY2VudGVyQSwgQjogY2VudGVyQiwgQzogY2VudGVyQywgRDogY2VudGVyRCB9KTtcbiAgICBcbiAgICAvLyBGaXJzdCBjaGVjayBpZiB3ZSBjbGlja2VkIGluIGFueSBvZiB0aGUgaG9yaXpvbnRhbCBjb25uZWN0b3IgYXJlYXNcbiAgICBjb25zdCBpc0luVG9wUm93Q29ubmVjdG9yQXJlYSA9IGlzUG9pbnRJbkhvcml6b250YWxDb25uZWN0b3JBcmVhKGNsaWNrUG9pbnQsIGNlbnRlckEsIGNlbnRlckQsIHNjYWxlZFJhZGl1c0IpO1xuICAgIGNvbnN0IGlzSW5Cb3R0b21Sb3dDb25uZWN0b3JBcmVhID0gaXNQb2ludEluSG9yaXpvbnRhbENvbm5lY3RvckFyZWEoY2xpY2tQb2ludCwgY2VudGVyQywgY2VudGVyQiwgc2NhbGVkUmFkaXVzQik7XG4gICAgXG4gICAgLy8gVGhlbiBjaGVjayBpZiB3ZSBjbGlja2VkIGluIGFueSBkaWFnb25hbCBjb25uZWN0b3IgYXJlYVxuICAgIGNvbnN0IGlzSW5BbnlEaWFnb25hbEFyZWEgPSBcbiAgICAgIGlzUG9pbnRJbkNvbm5lY3RvckFyZWEoY2xpY2tQb2ludCwgY2VudGVyQSwgY2VudGVyQiwgc2NhbGVkUmFkaXVzQiwgc2NhbGVkUmFkaXVzQSkgfHwgXG4gICAgICBpc1BvaW50SW5Db25uZWN0b3JBcmVhKGNsaWNrUG9pbnQsIGNlbnRlckMsIGNlbnRlckQsIHNjYWxlZFJhZGl1c0IsIHNjYWxlZFJhZGl1c0EpO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKFwiQ29ubmVjdG9yIGFyZWEgZGV0ZWN0aW9uOlwiLCB7XG4gICAgICBcIlRvcCByb3dcIjogaXNJblRvcFJvd0Nvbm5lY3RvckFyZWEsXG4gICAgICBcIkJvdHRvbSByb3dcIjogaXNJbkJvdHRvbVJvd0Nvbm5lY3RvckFyZWEsXG4gICAgICBcIkRpYWdvbmFsXCI6IGlzSW5BbnlEaWFnb25hbEFyZWFcbiAgICB9KTtcbiAgICBcbiAgICAvLyBIYW5kbGUgY2xpY2tzIG9uIGNvbm5lY3RvciBhcmVhc1xuICAgIGlmIChpc0luVG9wUm93Q29ubmVjdG9yQXJlYSB8fCBpc0luQm90dG9tUm93Q29ubmVjdG9yQXJlYSkge1xuICAgICAgY29uc29sZS5sb2coXCJIYW5kbGluZyBob3Jpem9udGFsIGNvbm5lY3RvciBjbGlja1wiKTtcbiAgICAgIFxuICAgICAgaWYgKGlzSW5Ub3BSb3dDb25uZWN0b3JBcmVhKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiQ2xpY2tlZCB0b3Agcm93IGNvbm5lY3RvclwiKTtcbiAgICAgICAgaGFuZGxlSG9yaXpvbnRhbENvbm5lY3RvckNsaWNrKDAsIDAsIDAsIDEpOyAvLyBUb3Agcm93OiAoMCwwKSB0byAoMCwxKVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChpc0luQm90dG9tUm93Q29ubmVjdG9yQXJlYSkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkNsaWNrZWQgYm90dG9tIHJvdyBjb25uZWN0b3JcIik7XG4gICAgICAgIGhhbmRsZUhvcml6b250YWxDb25uZWN0b3JDbGljaygxLCAwLCAxLCAxKTsgLy8gQm90dG9tIHJvdzogKDEsMCkgdG8gKDEsMSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBDaGVjayBmb3IgZGlhZ29uYWwgYXJlYSBjbGlja3NcbiAgICBlbHNlIGlmIChpc0luQW55RGlhZ29uYWxBcmVhKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkhhbmRsaW5nIGRpYWdvbmFsIGNvbm5lY3RvciBjbGlja1wiKTtcbiAgICAgIGhhbmRsZURpYWdvbmFsQ29ubmVjdG9yQ3ljbGUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gSWYgbm8gY29ubmVjdG9yIGFyZWEgd2FzIGhpdCwgY2hlY2sgZm9yIGNpcmNsZSBjbGlja3NcbiAgICBpZiAoZXZlbnQuaW5zdGFuY2VJZCA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gICAgXG4gICAgY29uc3QgaW5zdGFuY2VJZCA9IGV2ZW50Lmluc3RhbmNlSWQ7XG4gICAgY29uc3QgeyByb3csIGNvbCB9ID0gZ2V0R3JpZENvb3JkcyhpbnN0YW5jZUlkKTtcbiAgICBjb25zb2xlLmxvZyhgQ2xpY2tlZCBpbnN0YW5jZTogcm93PSR7cm93fSwgY29sPSR7Y29sfWApO1xuICAgIFxuICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IGdyaWRTdGF0ZVtyb3ddW2NvbF07XG4gICAgXG4gICAgLy8gR2V0IGluc3RhbmNlIHBvc2l0aW9uIGZyb20gb3VyIHN0b3JlZCByZWZlcmVuY2VcbiAgICBjb25zdCBpbnN0YW5jZVBvc2l0aW9uID0gaW5zdGFuY2VQb3NpdGlvbnMuY3VycmVudFtpbnN0YW5jZUlkXTtcbiAgICBcbiAgICAvLyBDcmVhdGUgYSBjb3B5IG9mIHRoZSBjbGljayBwb2ludFxuICAgIGNvbnN0IHBvaW50Q29weSA9IGV2ZW50LnBvaW50LmNsb25lKCk7XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIGRpc3RhbmNlIGZyb20gY2xpY2sgdG8gaW5zdGFuY2UgY2VudGVyXG4gICAgY29uc3QgZGlzdEZyb21DZW50ZXIgPSBwb2ludENvcHkuZGlzdGFuY2VUbyhpbnN0YW5jZVBvc2l0aW9uKTtcbiAgICBcbiAgICBsZXQgbmV3SW5uZXIgPSBjdXJyZW50U3RhdGUuc2hvd0lubmVyO1xuICAgIGxldCBuZXdPdXRlciA9IGN1cnJlbnRTdGF0ZS5zaG93T3V0ZXI7XG5cbiAgICBpZiAoZGlzdEZyb21DZW50ZXIgPD0gc2NhbGVkUmFkaXVzQikge1xuICAgICAgLy8gQ2xpY2tlZCBpbm5lciBjaXJjbGVcbiAgICAgIG5ld0lubmVyID0gIWN1cnJlbnRTdGF0ZS5zaG93SW5uZXI7XG4gICAgICBjb25zb2xlLmxvZyhgVG9nZ2xpbmcgaW5uZXIgY2lyY2xlOiAke2N1cnJlbnRTdGF0ZS5zaG93SW5uZXJ9IC0+ICR7bmV3SW5uZXJ9YCk7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIHRvZ2dsaW5nIG9mZiBhbiBpbm5lciBjaXJjbGUgdGhhdCB3YXMgcGFydCBvZiBhbiBhY3RpdmUgY29ubmVjdG9yXG4gICAgICBpZiAoIW5ld0lubmVyKSB7XG4gICAgICAgIC8vIFRvcC1sZWZ0IGNpcmNsZSBpcyBwYXJ0IG9mIHJlZCBjb25uZWN0b3Igb3IgdG9wIGhvcml6b250YWwgY29ubmVjdG9yXG4gICAgICAgIGlmIChyb3cgPT09IDAgJiYgY29sID09PSAwICYmIChhY3RpdmVDb25uZWN0b3IgPT09IDEgfHwgYWN0aXZlQ29ubmVjdG9yID09PSAzKSkge1xuICAgICAgICAgIHNldEFjdGl2ZUNvbm5lY3RvcigwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCb3R0b20tcmlnaHQgY2lyY2xlIGlzIHBhcnQgb2YgcmVkIGNvbm5lY3RvciBvciBib3R0b20gaG9yaXpvbnRhbCBjb25uZWN0b3JcbiAgICAgICAgZWxzZSBpZiAocm93ID09PSAxICYmIGNvbCA9PT0gMSAmJiAoYWN0aXZlQ29ubmVjdG9yID09PSAxIHx8IGFjdGl2ZUNvbm5lY3RvciA9PT0gNCkpIHtcbiAgICAgICAgICBzZXRBY3RpdmVDb25uZWN0b3IoMCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQm90dG9tLWxlZnQgY2lyY2xlIGlzIHBhcnQgb2YgYmx1ZSBjb25uZWN0b3Igb3IgYm90dG9tIGhvcml6b250YWwgY29ubmVjdG9yXG4gICAgICAgIGVsc2UgaWYgKHJvdyA9PT0gMSAmJiBjb2wgPT09IDAgJiYgKGFjdGl2ZUNvbm5lY3RvciA9PT0gMiB8fCBhY3RpdmVDb25uZWN0b3IgPT09IDQpKSB7XG4gICAgICAgICAgc2V0QWN0aXZlQ29ubmVjdG9yKDApO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRvcC1yaWdodCBjaXJjbGUgaXMgcGFydCBvZiBibHVlIGNvbm5lY3RvciBvciB0b3AgaG9yaXpvbnRhbCBjb25uZWN0b3JcbiAgICAgICAgZWxzZSBpZiAocm93ID09PSAwICYmIGNvbCA9PT0gMSAmJiAoYWN0aXZlQ29ubmVjdG9yID09PSAyIHx8IGFjdGl2ZUNvbm5lY3RvciA9PT0gMykpIHtcbiAgICAgICAgICBzZXRBY3RpdmVDb25uZWN0b3IoMCk7XG4gICAgICAgIH1cbiAgICAgIH0gXG4gICAgICAvLyBJZiB0b2dnbGluZyBPTiBhbiBpbm5lciBjaXJjbGUsIGNoZWNrIGlmIGl0IGNvbXBsZXRlcyBhIHBhaXJcbiAgICAgIGVsc2UgaWYgKG5ld0lubmVyKSB7XG4gICAgICAgIC8vIE9ubHkgYWN0aXZhdGUgY29ubmVjdG9yIGlmIG5vIGNvbm5lY3RvciBpcyBjdXJyZW50bHkgYWN0aXZlLFxuICAgICAgICAvLyBvciBpZiBhIGNvbm5lY3RvciBpcyBhY3RpdmUgaW4gYSBkaWZmZXJlbnQgcm93XG4gICAgICAgIGNvbnN0IGN1cnJlbnRSb3cgPSByb3c7XG4gICAgICAgIGNvbnN0IGlzQ29ubmVjdG9ySW5PdGhlclJvdyA9IFxuICAgICAgICAgIChhY3RpdmVDb25uZWN0b3IgPT09IDMgJiYgY3VycmVudFJvdyA9PT0gMSkgfHwgLy8gVG9wIHJvdyBjb25uZWN0b3IgYWN0aXZlIGJ1dCB3ZSdyZSBpbiBib3R0b20gcm93IFxuICAgICAgICAgIChhY3RpdmVDb25uZWN0b3IgPT09IDQgJiYgY3VycmVudFJvdyA9PT0gMCk7ICAgLy8gQm90dG9tIHJvdyBjb25uZWN0b3IgYWN0aXZlIGJ1dCB3ZSdyZSBpbiB0b3Agcm93XG4gICAgICAgICAgXG4gICAgICAgIGlmIChhY3RpdmVDb25uZWN0b3IgPT09IDAgfHwgaXNDb25uZWN0b3JJbk90aGVyUm93KSB7XG4gICAgICAgICAgLy8gQ2hlY2sgZm9yIGRpYWdvbmFsIHBhaXJzIC0gb25seSBpZiBubyBjb25uZWN0b3JzIGFyZSBhY3RpdmVcbiAgICAgICAgICBpZiAoYWN0aXZlQ29ubmVjdG9yID09PSAwKSB7XG4gICAgICAgICAgICAvLyBSZWQgY29ubmVjdG9yICh0b3AtbGVmdCB0byBib3R0b20tcmlnaHQpXG4gICAgICAgICAgICBpZiAoKHJvdyA9PT0gMCAmJiBjb2wgPT09IDAgJiYgZ3JpZFN0YXRlWzFdWzFdLnNob3dJbm5lcikgfHwgXG4gICAgICAgICAgICAgICAgKHJvdyA9PT0gMSAmJiBjb2wgPT09IDEgJiYgZ3JpZFN0YXRlWzBdWzBdLnNob3dJbm5lcikpIHtcbiAgICAgICAgICAgICAgc2V0QWN0aXZlQ29ubmVjdG9yKDEpOyAvLyBBY3RpdmF0ZSByZWQgY29ubmVjdG9yXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEJsdWUgY29ubmVjdG9yIChib3R0b20tbGVmdCB0byB0b3AtcmlnaHQpXG4gICAgICAgICAgICBlbHNlIGlmICgocm93ID09PSAxICYmIGNvbCA9PT0gMCAmJiBncmlkU3RhdGVbMF1bMV0uc2hvd0lubmVyKSB8fCBcbiAgICAgICAgICAgICAgICAgICAgKHJvdyA9PT0gMCAmJiBjb2wgPT09IDEgJiYgZ3JpZFN0YXRlWzFdWzBdLnNob3dJbm5lcikpIHtcbiAgICAgICAgICAgICAgc2V0QWN0aXZlQ29ubmVjdG9yKDIpOyAvLyBBY3RpdmF0ZSBibHVlIGNvbm5lY3RvclxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIENoZWNrIGZvciBob3Jpem9udGFsIHBhaXJzIGluIHRoZSBjdXJyZW50IHJvd1xuICAgICAgICAgIGlmIChjdXJyZW50Um93ID09PSAwKSB7XG4gICAgICAgICAgICAvLyBUb3Agcm93IGNvbm5lY3RvciAtIG9ubHkgYWN0aXZhdGUgaWYgbm8gYm90dG9tIGNvbm5lY3RvciBleGlzdHNcbiAgICAgICAgICAgIGlmIChhY3RpdmVDb25uZWN0b3IgIT09IDQgJiYgXG4gICAgICAgICAgICAgICAgKChyb3cgPT09IDAgJiYgY29sID09PSAwICYmIGdyaWRTdGF0ZVswXVsxXS5zaG93SW5uZXIpIHx8IFxuICAgICAgICAgICAgICAgIChyb3cgPT09IDAgJiYgY29sID09PSAxICYmIGdyaWRTdGF0ZVswXVswXS5zaG93SW5uZXIpKSkge1xuICAgICAgICAgICAgICBzZXRBY3RpdmVDb25uZWN0b3IoMyk7IC8vIEFjdGl2YXRlIHRvcCByb3cgaG9yaXpvbnRhbCBjb25uZWN0b3JcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRSb3cgPT09IDEpIHtcbiAgICAgICAgICAgIC8vIEJvdHRvbSByb3cgY29ubmVjdG9yIC0gb25seSBhY3RpdmF0ZSBpZiBubyB0b3AgY29ubmVjdG9yIGV4aXN0c1xuICAgICAgICAgICAgaWYgKGFjdGl2ZUNvbm5lY3RvciAhPT0gMyAmJiBcbiAgICAgICAgICAgICAgICAoKHJvdyA9PT0gMSAmJiBjb2wgPT09IDAgJiYgZ3JpZFN0YXRlWzFdWzFdLnNob3dJbm5lcikgfHwgXG4gICAgICAgICAgICAgICAgKHJvdyA9PT0gMSAmJiBjb2wgPT09IDEgJiYgZ3JpZFN0YXRlWzFdWzBdLnNob3dJbm5lcikpKSB7XG4gICAgICAgICAgICAgIHNldEFjdGl2ZUNvbm5lY3Rvcig0KTsgLy8gQWN0aXZhdGUgYm90dG9tIHJvdyBob3Jpem9udGFsIGNvbm5lY3RvclxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZGlzdEZyb21DZW50ZXIgPD0gc2NhbGVkUmFkaXVzQSkge1xuICAgICAgLy8gQ2xpY2tlZCBvdXRlciBjaXJjbGVcbiAgICAgIG5ld091dGVyID0gIWN1cnJlbnRTdGF0ZS5zaG93T3V0ZXI7XG4gICAgICBjb25zb2xlLmxvZyhgVG9nZ2xpbmcgb3V0ZXIgY2lyY2xlOiAke2N1cnJlbnRTdGF0ZS5zaG93T3V0ZXJ9IC0+ICR7bmV3T3V0ZXJ9YCk7XG4gICAgfVxuICAgIFxuICAgIGlmIChuZXdJbm5lciAhPT0gY3VycmVudFN0YXRlLnNob3dJbm5lciB8fCBuZXdPdXRlciAhPT0gY3VycmVudFN0YXRlLnNob3dPdXRlcikge1xuICAgICAgc2V0R3JpZFN0YXRlKHByZXZTdGF0ZSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld1N0YXRlID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShwcmV2U3RhdGUpKTsgLy8gRGVlcCBjb3B5XG4gICAgICAgIG5ld1N0YXRlW3Jvd11bY29sXSA9IHsgc2hvd0lubmVyOiBuZXdJbm5lciwgc2hvd091dGVyOiBuZXdPdXRlciB9O1xuICAgICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIFxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGlmIGEgcG9pbnQgaXMgaW4gYSBkaWFnb25hbCBjb25uZWN0b3IgYXJlYVxuICBjb25zdCBpc1BvaW50SW5Db25uZWN0b3JBcmVhID0gKHBvaW50LCBjZW50ZXIxLCBjZW50ZXIyLCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMpID0+IHtcbiAgICAvLyBDaGVjayB0aGF0IHBvaW50IGlzIG5vdCBpbnNpZGUgZWl0aGVyIGlubmVyIGNpcmNsZVxuICAgIGNvbnN0IGRpc3RUb0NlbnRlcjEgPSBwb2ludC5kaXN0YW5jZVRvKGNlbnRlcjEpO1xuICAgIGNvbnN0IGRpc3RUb0NlbnRlcjIgPSBwb2ludC5kaXN0YW5jZVRvKGNlbnRlcjIpO1xuICAgIFxuICAgIGlmIChkaXN0VG9DZW50ZXIxIDwgaW5uZXJSYWRpdXMgfHwgZGlzdFRvQ2VudGVyMiA8IGlubmVyUmFkaXVzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7IC8vIEluc2lkZSBhbiBpbm5lciBjaXJjbGVcbiAgICB9XG4gICAgXG4gICAgLy8gUHJvamVjdCBwb2ludCBvbnRvIHRoZSBsaW5lIGNvbm5lY3RpbmcgdGhlIGNlbnRlcnNcbiAgICBjb25zdCBkaXJlY3Rpb24gPSBuZXcgVEhSRUUuVmVjdG9yMigpLnN1YlZlY3RvcnMoY2VudGVyMiwgY2VudGVyMSkubm9ybWFsaXplKCk7XG4gICAgY29uc3QgY2VudGVyMVRvUG9pbnQgPSBuZXcgVEhSRUUuVmVjdG9yMigpLnN1YlZlY3RvcnMocG9pbnQsIGNlbnRlcjEpO1xuICAgIGNvbnN0IHByb2plY3Rpb25MZW5ndGggPSBjZW50ZXIxVG9Qb2ludC5kb3QoZGlyZWN0aW9uKTtcbiAgICBcbiAgICAvLyBDaGVjayBpZiBwcm9qZWN0aW9uIGZhbGxzIGJldHdlZW4gdGhlIHR3byBjZW50ZXJzICh3aXRoIHNvbWUgYnVmZmVyKVxuICAgIGNvbnN0IGRpc3RhbmNlQmV0d2VlbkNlbnRlcnMgPSBjZW50ZXIxLmRpc3RhbmNlVG8oY2VudGVyMik7XG4gICAgXG4gICAgLy8gRGVmaW5lIHRoZSBhY3RpdmUgYXJlYSBhbG9uZyB0aGUgZGlhZ29uYWwgbGluZVxuICAgIGlmIChwcm9qZWN0aW9uTGVuZ3RoIDwgaW5uZXJSYWRpdXMgfHwgcHJvamVjdGlvbkxlbmd0aCA+IGRpc3RhbmNlQmV0d2VlbkNlbnRlcnMgLSBpbm5lclJhZGl1cykge1xuICAgICAgcmV0dXJuIGZhbHNlOyAvLyBPdXRzaWRlIHRoZSByZWdpb24gYmV0d2VlbiBjaXJjbGVzXG4gICAgfVxuICAgIFxuICAgIC8vIENhbGN1bGF0ZSBwZXJwZW5kaWN1bGFyIGRpc3RhbmNlIGZyb20gcG9pbnQgdG8gbGluZVxuICAgIGNvbnN0IHByb2plY3RlZFBvaW50ID0gbmV3IFRIUkVFLlZlY3RvcjIoKS5jb3B5KGNlbnRlcjEpLmFkZFNjYWxlZFZlY3RvcihkaXJlY3Rpb24sIHByb2plY3Rpb25MZW5ndGgpO1xuICAgIGNvbnN0IHBlcnBEaXN0YW5jZSA9IHBvaW50LmRpc3RhbmNlVG8ocHJvamVjdGVkUG9pbnQpO1xuICAgIFxuICAgIC8vIERlZmluZSBhIG5hcnJvdyBjb3JyaWRvciBhbG9uZyB0aGUgZGlhZ29uYWwgbGluZVxuICAgIGNvbnN0IGNvbm5lY3RvcldpZHRoID0gaW5uZXJSYWRpdXMgKiAwLjg7XG4gICAgXG4gICAgcmV0dXJuIHBlcnBEaXN0YW5jZSA8IGNvbm5lY3RvcldpZHRoO1xuICB9O1xuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBkZXRlcm1pbmUgaWYgYSBwb2ludCBpcyBpbiBhIGhvcml6b250YWwgY29ubmVjdG9yIGFyZWEgKEFyZWEgQSlcbiAgY29uc3QgaXNQb2ludEluSG9yaXpvbnRhbENvbm5lY3RvckFyZWEgPSAocG9pbnQsIGNlbnRlcjEsIGNlbnRlcjIsIHJhZGl1cykgPT4ge1xuICAgIC8vIENoZWNrIHRoYXQgcG9pbnQgaXMgbm90IGluc2lkZSBlaXRoZXIgaW5uZXIgY2lyY2xlXG4gICAgY29uc3QgZGlzdFRvQ2VudGVyMSA9IHBvaW50LmRpc3RhbmNlVG8oY2VudGVyMSk7XG4gICAgY29uc3QgZGlzdFRvQ2VudGVyMiA9IHBvaW50LmRpc3RhbmNlVG8oY2VudGVyMik7XG4gICAgXG4gICAgaWYgKGRpc3RUb0NlbnRlcjEgPCByYWRpdXMgfHwgZGlzdFRvQ2VudGVyMiA8IHJhZGl1cykge1xuICAgICAgcmV0dXJuIGZhbHNlOyAvLyBJbnNpZGUgYW4gaW5uZXIgY2lyY2xlXG4gICAgfVxuICAgIFxuICAgIC8vIENhbGN1bGF0ZSB0aGUgcmVjdGFuZ2xlIGJvdW5kcyBmb3IgdGhlIGhvcml6b250YWwgY29ubmVjdG9yIChBcmVhIEEpXG4gICAgLy8gRW5zdXJlIGl0J3Mgd2lkZXIgYW5kIHNob3J0ZXIgdGhhbiB0aGUgZGlhZ29uYWwgYXJlYVxuICAgIGNvbnN0IG1pZFkgPSAoY2VudGVyMS55ICsgY2VudGVyMi55KSAvIDI7XG4gICAgY29uc3QgbGVmdCA9IE1hdGgubWluKGNlbnRlcjEueCwgY2VudGVyMi54KSArIHJhZGl1cztcbiAgICBjb25zdCByaWdodCA9IE1hdGgubWF4KGNlbnRlcjEueCwgY2VudGVyMi54KSAtIHJhZGl1cztcbiAgICBjb25zdCBoYWxmSGVpZ2h0ID0gcmFkaXVzICogMC42OyAvLyBOYXJyb3dlciBoZWlnaHQgdG8gZGlzdGluZ3Vpc2ggZnJvbSBkaWFnb25hbFxuICAgIFxuICAgIC8vIENoZWNrIGlmIHBvaW50IGlzIHdpdGhpbiB0aGUgaG9yaXpvbnRhbCBjb25uZWN0b3IgcmVjdGFuZ2xlXG4gICAgcmV0dXJuIChcbiAgICAgIHBvaW50LnggPj0gbGVmdCAmJiBcbiAgICAgIHBvaW50LnggPD0gcmlnaHQgJiYgXG4gICAgICBwb2ludC55ID49IG1pZFkgLSBoYWxmSGVpZ2h0ICYmIFxuICAgICAgcG9pbnQueSA8PSBtaWRZICsgaGFsZkhlaWdodFxuICAgICk7XG4gIH07XG4gIFxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gaGFuZGxlIGhvcml6b250YWwgY29ubmVjdG9yIGNsaWNrcyAodG9nZ2xlIG9uL29mZilcbiAgY29uc3QgaGFuZGxlSG9yaXpvbnRhbENvbm5lY3RvckNsaWNrID0gKHJvdzEsIGNvbDEsIHJvdzIsIGNvbDIpID0+IHtcbiAgICAvLyBDaGVjayBpZiB0aGUgY2lyY2xlcyBpbiB0aGlzIHJvdyBhcmUgYWxyZWFkeSBwYXJ0IG9mIGRpYWdvbmFsIGNvbm5lY3RvcnNcbiAgICBjb25zdCBoYXNDaXJjbGUxSW5EaWFnb25hbENvbm5lY3RvciA9IFxuICAgICAgKGFjdGl2ZUNvbm5lY3RvciA9PT0gMSAmJiAoKHJvdzEgPT09IDAgJiYgY29sMSA9PT0gMCkgfHwgKHJvdzEgPT09IDEgJiYgY29sMSA9PT0gMSkpKSB8fCBcbiAgICAgIChhY3RpdmVDb25uZWN0b3IgPT09IDIgJiYgKChyb3cxID09PSAxICYmIGNvbDEgPT09IDApIHx8IChyb3cxID09PSAwICYmIGNvbDEgPT09IDEpKSk7XG4gICAgICBcbiAgICBjb25zdCBoYXNDaXJjbGUySW5EaWFnb25hbENvbm5lY3RvciA9IFxuICAgICAgKGFjdGl2ZUNvbm5lY3RvciA9PT0gMSAmJiAoKHJvdzIgPT09IDAgJiYgY29sMiA9PT0gMCkgfHwgKHJvdzIgPT09IDEgJiYgY29sMiA9PT0gMSkpKSB8fCBcbiAgICAgIChhY3RpdmVDb25uZWN0b3IgPT09IDIgJiYgKChyb3cyID09PSAxICYmIGNvbDIgPT09IDApIHx8IChyb3cyID09PSAwICYmIGNvbDIgPT09IDEpKSk7XG4gICAgICBcbiAgICAvLyBEb24ndCB0b2dnbGUgaWYgYW55IGNpcmNsZSBpcyBwYXJ0IG9mIGEgZGlhZ29uYWwgY29ubmVjdG9yXG4gICAgaWYgKGhhc0NpcmNsZTFJbkRpYWdvbmFsQ29ubmVjdG9yIHx8IGhhc0NpcmNsZTJJbkRpYWdvbmFsQ29ubmVjdG9yKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkNhbid0IHRvZ2dsZSBob3Jpem9udGFsIGNvbm5lY3RvcjogY2lyY2xlcyBhbHJlYWR5IHBhcnQgb2YgZGlhZ29uYWwgY29ubmVjdG9yXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICAvLyBDaGVjayBpZiBib3RoIGNpcmNsZXMgYXJlIGFjdGl2ZVxuICAgIGlmICghZ3JpZFN0YXRlW3JvdzFdW2NvbDFdLnNob3dJbm5lciB8fCAhZ3JpZFN0YXRlW3JvdzJdW2NvbDJdLnNob3dJbm5lcikge1xuICAgICAgY29uc29sZS5sb2coXCJDYW4ndCB0b2dnbGUgaG9yaXpvbnRhbCBjb25uZWN0b3I6IG9uZSBvciBib3RoIGNpcmNsZXMgYXJlIGluYWN0aXZlXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICAvLyBEZXRlcm1pbmUgdGhlIGhvcml6b250YWwgY29ubmVjdG9yJ3Mgc3RhdGUgKDMgZm9yIHRvcCByb3csIDQgZm9yIGJvdHRvbSByb3cpXG4gICAgY29uc3QgaG9yaXpvbnRhbENvbm5lY3RvclN0YXRlID0gcm93MSA9PT0gMCA/IDMgOiA0O1xuICAgIFxuICAgIC8vIFRvZ2dsZSB0aGUgY29ubmVjdG9yIC0gYWx3YXlzIHRvZ2dsZSByZWdhcmRsZXNzIG9mIGN1cnJlbnQgc3RhdGVcbiAgICBzZXRBY3RpdmVDb25uZWN0b3IocHJldlN0YXRlID0+IHtcbiAgICAgIC8vIElmIHRoaXMgY29ubmVjdG9yIGlzIGFscmVhZHkgYWN0aXZlLCB0dXJuIGl0IG9mZlxuICAgICAgaWYgKHByZXZTdGF0ZSA9PT0gaG9yaXpvbnRhbENvbm5lY3RvclN0YXRlKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgLy8gSWYgYW5vdGhlciBjb25uZWN0b3IgaW4gdGhpcyByb3cgaXMgYWN0aXZlLCBsZWF2ZSBpdCBhbG9uZVxuICAgICAgZWxzZSBpZiAoKHByZXZTdGF0ZSA9PT0gMyAmJiByb3cxID09PSAwKSB8fCAocHJldlN0YXRlID09PSA0ICYmIHJvdzEgPT09IDEpKSB7XG4gICAgICAgIHJldHVybiAwOyAvLyBUdXJuIG9mZiBleGlzdGluZyBjb25uZWN0b3IgaW4gc2FtZSByb3dcbiAgICAgIH1cbiAgICAgIC8vIElmIG5vIGNvbm5lY3RvciBvciBhIGNvbm5lY3RvciBpbiBkaWZmZXJlbnQgcm93LCBhY3RpdmF0ZSB0aGlzIG9uZVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBob3Jpem9udGFsQ29ubmVjdG9yU3RhdGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIFxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gaGFuZGxlIGRpYWdvbmFsIGNvbm5lY3RvciBjbGlja3MgKGN5Y2xlIHRocm91Z2ggbm9uZS9yZWQvYmx1ZSlcbiAgY29uc3QgaGFuZGxlRGlhZ29uYWxDb25uZWN0b3JDeWNsZSA9ICgpID0+IHtcbiAgICAvLyBDaGVjayBpZiBhbnkgb2YgdGhlc2UgY2lyY2xlcyBhcmUgcGFydCBvZiBob3Jpem9udGFsIGNvbm5lY3RvcnNcbiAgICBjb25zdCBoYXNDaXJjbGVJbkhvcml6b250YWxDb25uZWN0b3IgPSBcbiAgICAgIGFjdGl2ZUNvbm5lY3RvciA9PT0gMyB8fCBhY3RpdmVDb25uZWN0b3IgPT09IDQ7XG4gICAgICBcbiAgICBpZiAoaGFzQ2lyY2xlSW5Ib3Jpem9udGFsQ29ubmVjdG9yKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkNhbid0IHRvZ2dsZSBkaWFnb25hbCBjb25uZWN0b3I6IGNpcmNsZXMgYWxyZWFkeSBwYXJ0IG9mIGhvcml6b250YWwgY29ubmVjdG9yXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICAvLyBDaGVjayBpZiBhbGwgZm91ciBjaXJjbGVzIGFyZSBhY3RpdmVcbiAgICBpZiAoIWdyaWRTdGF0ZVswXVswXS5zaG93SW5uZXIgfHwgIWdyaWRTdGF0ZVswXVsxXS5zaG93SW5uZXIgfHwgXG4gICAgICAgICFncmlkU3RhdGVbMV1bMF0uc2hvd0lubmVyIHx8ICFncmlkU3RhdGVbMV1bMV0uc2hvd0lubmVyKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkNhbid0IHRvZ2dsZSBkaWFnb25hbCBjb25uZWN0b3I6IG9uZSBvciBtb3JlIGNpcmNsZXMgYXJlIGluYWN0aXZlXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICAvLyBDeWNsZSB0aHJvdWdoIGRpYWdvbmFsIHN0YXRlczogTm9uZSAoMCkgLT4gUmVkICgxKSAtPiBCbHVlICgyKSAtPiBOb25lICgwKVxuICAgIHNldEFjdGl2ZUNvbm5lY3RvcihwcmV2U3RhdGUgPT4ge1xuICAgICAgaWYgKHByZXZTdGF0ZSA9PT0gMCkgcmV0dXJuIDE7ICAgICAgLy8gTm9uZSAtPiBSZWRcbiAgICAgIGVsc2UgaWYgKHByZXZTdGF0ZSA9PT0gMSkgcmV0dXJuIDI7IC8vIFJlZCAtPiBCbHVlXG4gICAgICBlbHNlIHJldHVybiAwOyAgICAgICAgICAgICAgICAgICAgICAvLyBCbHVlIC0+IE5vbmVcbiAgICB9KTtcbiAgfTtcblxuICAvLyBDYWxjdWxhdGUgcGxhbmUgc2l6ZSBiYXNlZCBvbiB0aGUgZ3JpZCBzaXplIGFuZCBzcGFjaW5nXG4gIGNvbnN0IGNvbm5lY3RvclBsYW5lU2l6ZSA9IHVzZU1lbW8oKCkgPT4gXG4gICAgR1JJRF9TSVpFICogZ3JpZFNwYWNpbmcgKyBNYXRoLm1heChCQVNFX1ZBTFVFUy5yYWRpdXNBLCBCQVNFX1ZBTFVFUy5yYWRpdXNCKSAqIDIsXG4gICAgW2dyaWRTcGFjaW5nLCBCQVNFX1ZBTFVFUy5yYWRpdXNBLCBCQVNFX1ZBTFVFUy5yYWRpdXNCXVxuICApO1xuXG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIHsvKiBEZWJ1ZyBjb2xvcmVkIHBsYW5lIHRvIHZlcmlmeSByZW5kZXJpbmcgKi99XG4gICAgICB7ZGVidWcgJiYgKFxuICAgICAgICA8bWVzaCByZWY9e2RlYnVnTWVzaFJlZn0gcG9zaXRpb249e1swLCAwLCAtMC4yXX0+XG4gICAgICAgICAgPHBsYW5lR2VvbWV0cnkgYXJncz17W2Nvbm5lY3RvclBsYW5lU2l6ZSwgY29ubmVjdG9yUGxhbmVTaXplXX0gLz5cbiAgICAgICAgICA8bWVzaEJhc2ljTWF0ZXJpYWwgY29sb3I9XCJibHVlXCIgb3BhY2l0eT17MC4xfSB0cmFuc3BhcmVudCAvPlxuICAgICAgICA8L21lc2g+XG4gICAgICApfVxuXG4gICAgICB7LyogRGVidWcgY29ubmVjdG9yIGFyZWFzIGlmIGRlYnVnIG1vZGUgaXMgb24gLSBpbnZpc2libGUgYnV0IHN0aWxsIHVzZWZ1bCBmb3IgZGVidWdnaW5nICovfVxuICAgICAge2RlYnVnICYmIChcbiAgICAgICAgPD5cbiAgICAgICAgICB7LyogVGhlc2UgbWVzaGVzIGFyZSBub3cgaW52aXNpYmxlIGJ1dCBrZXB0IGZvciBjb2xsaXNpb24gZGV0ZWN0aW9uIHJlZmVyZW5jZSAqL31cbiAgICAgICAgICA8bWVzaCBwb3NpdGlvbj17WzAsIGdyaWRTcGFjaW5nICogMC41LCAwLjA1XX0gdmlzaWJsZT17ZmFsc2V9PlxuICAgICAgICAgICAgPHBsYW5lR2VvbWV0cnkgYXJncz17W1xuICAgICAgICAgICAgICBncmlkU3BhY2luZyAtIDIgKiBzY2FsZWRSYWRpdXNCLCBcbiAgICAgICAgICAgICAgc2NhbGVkUmFkaXVzQiAqIDAuNiAqIDJcbiAgICAgICAgICAgIF19IC8+XG4gICAgICAgICAgICA8bWVzaEJhc2ljTWF0ZXJpYWwgb3BhY2l0eT17MH0gdHJhbnNwYXJlbnQgLz5cbiAgICAgICAgICA8L21lc2g+XG4gICAgICAgICAgXG4gICAgICAgICAgPG1lc2ggcG9zaXRpb249e1swLCAtZ3JpZFNwYWNpbmcgKiAwLjUsIDAuMDVdfSB2aXNpYmxlPXtmYWxzZX0+XG4gICAgICAgICAgICA8cGxhbmVHZW9tZXRyeSBhcmdzPXtbXG4gICAgICAgICAgICAgIGdyaWRTcGFjaW5nIC0gMiAqIHNjYWxlZFJhZGl1c0IsIFxuICAgICAgICAgICAgICBzY2FsZWRSYWRpdXNCICogMC42ICogMlxuICAgICAgICAgICAgXX0gLz5cbiAgICAgICAgICAgIDxtZXNoQmFzaWNNYXRlcmlhbCBvcGFjaXR5PXswfSB0cmFuc3BhcmVudCAvPlxuICAgICAgICAgIDwvbWVzaD5cbiAgICAgICAgICBcbiAgICAgICAgICA8bWVzaCBwb3NpdGlvbj17WzAsIDAsIDAuMDVdfSByb3RhdGlvbj17WzAsIDAsIC1NYXRoLlBJIC8gNF19IHZpc2libGU9e2ZhbHNlfT5cbiAgICAgICAgICAgIDxwbGFuZUdlb21ldHJ5IGFyZ3M9e1tcbiAgICAgICAgICAgICAgTWF0aC5zcXJ0KDIpICogZ3JpZFNwYWNpbmcgLSAyICogc2NhbGVkUmFkaXVzQiwgXG4gICAgICAgICAgICAgIHNjYWxlZFJhZGl1c0IgKiAwLjggKiAyXG4gICAgICAgICAgICBdfSAvPlxuICAgICAgICAgICAgPG1lc2hCYXNpY01hdGVyaWFsIG9wYWNpdHk9ezB9IHRyYW5zcGFyZW50IC8+XG4gICAgICAgICAgPC9tZXNoPlxuICAgICAgICAgIFxuICAgICAgICAgIDxtZXNoIHBvc2l0aW9uPXtbMCwgMCwgMC4wNV19IHJvdGF0aW9uPXtbMCwgMCwgTWF0aC5QSSAvIDRdfSB2aXNpYmxlPXtmYWxzZX0+XG4gICAgICAgICAgICA8cGxhbmVHZW9tZXRyeSBhcmdzPXtbXG4gICAgICAgICAgICAgIE1hdGguc3FydCgyKSAqIGdyaWRTcGFjaW5nIC0gMiAqIHNjYWxlZFJhZGl1c0IsIFxuICAgICAgICAgICAgICBzY2FsZWRSYWRpdXNCICogMC44ICogMlxuICAgICAgICAgICAgXX0gLz5cbiAgICAgICAgICAgIDxtZXNoQmFzaWNNYXRlcmlhbCBvcGFjaXR5PXswfSB0cmFuc3BhcmVudCAvPlxuICAgICAgICAgIDwvbWVzaD5cbiAgICAgICAgPC8+XG4gICAgICApfVxuXG4gICAgICB7LyogU2ltcGxlIGNvbm5lY3RvciBmb3IgZGVidWdnaW5nIChoaWdoZXIgei1pbmRleCBzbyBpdCdzIHZpc2libGUpICovfVxuICAgICAgPG1lc2ggXG4gICAgICAgIHJlZj17c2ltcGxlQ29ubmVjdG9yTWVzaFJlZn0gXG4gICAgICAgIHBvc2l0aW9uPXtbMCwgMCwgMC4xXX0gXG4gICAgICAgIHZpc2libGU9e3Nob3dTaW1wbGV9XG4gICAgICAgIG9uQ2xpY2s9e2hhbmRsZUNsaWNrfVxuICAgICAgPlxuICAgICAgICA8cGxhbmVHZW9tZXRyeSBhcmdzPXtbY29ubmVjdG9yUGxhbmVTaXplLCBjb25uZWN0b3JQbGFuZVNpemVdfSAvPlxuICAgICAgICA8c2ltcGxlQ29ubmVjdG9yTWF0ZXJpYWxcbiAgICAgICAgICByZWY9e3NpbXBsZUNvbm5lY3Rvck1hdGVyaWFsUmVmfVxuICAgICAgICAgIGtleT17U2ltcGxlQ29ubmVjdG9yTWF0ZXJpYWwua2V5fVxuICAgICAgICAgIHRyYW5zcGFyZW50PXt0cnVlfVxuICAgICAgICAgIGRlcHRoVGVzdD17ZmFsc2V9XG4gICAgICAgIC8+XG4gICAgICA8L21lc2g+XG5cbiAgICAgIHsvKiBBZGQgb3JpZ2luYWwgY29ubmVjdG9yIG1lc2ggZm9yIHRoZSBzaGFwZXMgYmV0d2VlbiBjaXJjbGVzICovfVxuICAgICAgPG1lc2ggXG4gICAgICAgIHJlZj17Y29ubmVjdG9yTWVzaFJlZn0gXG4gICAgICAgIHBvc2l0aW9uPXtbMCwgMCwgLTAuMV19IFxuICAgICAgICB2aXNpYmxlPXshc2hvd1NpbXBsZX1cbiAgICAgICAgb25DbGljaz17aGFuZGxlQ2xpY2t9XG4gICAgICA+XG4gICAgICAgIDxwbGFuZUdlb21ldHJ5IGFyZ3M9e1tjb25uZWN0b3JQbGFuZVNpemUsIGNvbm5lY3RvclBsYW5lU2l6ZV19IC8+XG4gICAgICAgIDxncmlkQ29ubmVjdG9yTWF0ZXJpYWxcbiAgICAgICAgICByZWY9e2dyaWRDb25uZWN0b3JNYXRlcmlhbFJlZn1cbiAgICAgICAgICBrZXk9e0dyaWRDb25uZWN0b3JNYXRlcmlhbC5rZXl9XG4gICAgICAgICAgdHJhbnNwYXJlbnQ9e3RydWV9XG4gICAgICAgICAgZGVwdGhUZXN0PXtmYWxzZX1cbiAgICAgICAgLz5cbiAgICAgIDwvbWVzaD5cblxuICAgICAgey8qIFRyYW5zcGFyZW50IGJhY2tncm91bmQgcGxhbmUgdG8gY2F0Y2ggYWxsIGNsaWNrcyAqL31cbiAgICAgIDxtZXNoIFxuICAgICAgICBwb3NpdGlvbj17WzAsIDAsIC0wLjE1XX0gXG4gICAgICAgIG9uQ2xpY2s9e2hhbmRsZUNsaWNrfVxuICAgICAgPlxuICAgICAgICA8cGxhbmVHZW9tZXRyeSBhcmdzPXtbY29ubmVjdG9yUGxhbmVTaXplLCBjb25uZWN0b3JQbGFuZVNpemVdfSAvPlxuICAgICAgICA8bWVzaEJhc2ljTWF0ZXJpYWwgY29sb3I9XCJ3aGl0ZVwiIG9wYWNpdHk9ezAuMDF9IHRyYW5zcGFyZW50IC8+XG4gICAgICA8L21lc2g+XG5cbiAgICAgIHsvKiBDaXJjbGVzICovfVxuICAgICAgPGluc3RhbmNlZE1lc2hcbiAgICAgICAgcmVmPXtpbnN0YW5jZWRNZXNoUmVmfVxuICAgICAgICBhcmdzPXtbbnVsbCwgbnVsbCwgVE9UQUxfSU5TVEFOQ0VTXX1cbiAgICAgICAgb25DbGljaz17aGFuZGxlQ2xpY2t9XG4gICAgICAgIHBvc2l0aW9uPXtbMCwgMCwgMF19XG4gICAgICA+XG4gICAgICAgIDxwbGFuZUdlb21ldHJ5IGFyZ3M9e1tjb25uZWN0b3JQbGFuZVNpemUsIGNvbm5lY3RvclBsYW5lU2l6ZV19PlxuICAgICAgICAgIDxpbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgXG4gICAgICAgICAgICBhdHRhY2g9XCJhdHRyaWJ1dGVzLWFfaW5zdGFuY2VTaG93SW5uZXJcIiBcbiAgICAgICAgICAgIGFyZ3M9e1tpbnN0YW5jZVNob3dJbm5lciwgMV19IFxuICAgICAgICAgIC8+XG4gICAgICAgICAgPGluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSBcbiAgICAgICAgICAgIGF0dGFjaD1cImF0dHJpYnV0ZXMtYV9pbnN0YW5jZVNob3dPdXRlclwiIFxuICAgICAgICAgICAgYXJncz17W2luc3RhbmNlU2hvd091dGVyLCAxXX0gXG4gICAgICAgICAgLz5cbiAgICAgICAgPC9wbGFuZUdlb21ldHJ5PlxuICAgICAgICA8Y29ubmVjdG9yTWF0ZXJpYWxcbiAgICAgICAgICByZWY9e21hdGVyaWFsUmVmfVxuICAgICAgICAgIGtleT17Q29ubmVjdG9yTWF0ZXJpYWwua2V5fVxuICAgICAgICAgIHRyYW5zcGFyZW50PXt0cnVlfVxuICAgICAgICAvPlxuICAgICAgPC9pbnN0YW5jZWRNZXNoPlxuXG4gICAgICB7LyogR3JpZCBsaW5lcyB0aGF0IG1hdGNoIHRoZSBncmlkIHNwYWNpbmcgKi99XG4gICAgICA8Z3JvdXAgcmVmPXtncmlkSGVscGVyUmVmfSBwb3NpdGlvbj17WzAsIDAsIC0wLjJdfT5cbiAgICAgICAgPGdyaWRIZWxwZXIgXG4gICAgICAgICAgYXJncz17WzEwLCAxMF19IFxuICAgICAgICAgIHJvdGF0aW9uPXtbTWF0aC5QSSAvIDIsIDAsIDBdfVxuICAgICAgICAvPlxuICAgICAgPC9ncm91cD5cbiAgICA8Lz5cbiAgKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gV2ViR0xDYW52YXMoKSB7XG4gIHJldHVybiAoXG4gICAgLy8gU2V0IHVwIHRoZSBSM0YgQ2FudmFzXG4gICAgPENhbnZhcyBzdHlsZT17eyBiYWNrZ3JvdW5kOiAnI2YwZjBmMCcgfX0+XG4gICAgICB7LyogT3J0aG9ncmFwaGljIGNhbWVyYSBmb3IgdHJ1ZSAyRCB2aWV3ICovfVxuICAgICAgPE9ydGhvZ3JhcGhpY0NhbWVyYSBcbiAgICAgICAgbWFrZURlZmF1bHQgXG4gICAgICAgIHpvb209ezEwMH0gXG4gICAgICAgIHBvc2l0aW9uPXtbMCwgMCwgNV19IFxuICAgICAgICByb3RhdGlvbj17WzAsIDAsIDBdfVxuICAgICAgLz5cbiAgICAgIDxhbWJpZW50TGlnaHQgaW50ZW5zaXR5PXswLjh9IC8+XG4gICAgICA8U2NlbmUgLz5cbiAgICA8L0NhbnZhcz5cbiAgKTtcbn0gIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlUmVmIiwidXNlTWVtbyIsInVzZUVmZmVjdCIsInVzZVN0YXRlIiwiQ2FudmFzIiwidXNlRnJhbWUiLCJleHRlbmQiLCJ1c2VUaHJlZSIsIk9ydGhvZ3JhcGhpY0NhbWVyYSIsIlRIUkVFIiwidXNlQ29udHJvbHMiLCJmb2xkZXIiLCJidXR0b24iLCJDb25uZWN0b3JNYXRlcmlhbCIsIkdyaWRDb25uZWN0b3JNYXRlcmlhbCIsIlNpbXBsZUNvbm5lY3Rvck1hdGVyaWFsIiwiSHRtbCIsIkdSSURfU0laRSIsIlRPVEFMX0lOU1RBTkNFUyIsImdldEluc3RhbmNlSWQiLCJyb3ciLCJjb2wiLCJnZXRHcmlkQ29vcmRzIiwiaWQiLCJNYXRoIiwiZmxvb3IiLCJkdW1teSIsIk9iamVjdDNEIiwiQkFTRV9WQUxVRVMiLCJyYWRpdXNCIiwicmFkaXVzQSIsImJveFNpemUiLCJiYXNlU3BhY2luZyIsIlNjZW5lIiwiZ3JpZFNwYWNpbmciLCJ6b29tIiwiZGVidWciLCJzaG93U2ltcGxlIiwidmFsdWUiLCJtaW4iLCJtYXgiLCJzdGVwIiwibGFiZWwiLCJzY2FsZUZhY3RvciIsInNjYWxlZFJhZGl1c0IiLCJ0b0ZpeGVkIiwic2NhbGVkUmFkaXVzQSIsInNjYWxlZEJveFNpemUiLCJhY3RpdmVDb25uZWN0b3IiLCJzZXRBY3RpdmVDb25uZWN0b3IiLCJpbm5lclJhZGl1cyIsImRpc2FibGVkIiwib3V0ZXJSYWRpdXMiLCJ0b1N0cmluZyIsIm9uQ2hhbmdlIiwiZ3JpZFN0YXRlIiwic2V0R3JpZFN0YXRlIiwic2hvd0lubmVyIiwic2hvd091dGVyIiwibWF0ZXJpYWxSZWYiLCJpbnN0YW5jZWRNZXNoUmVmIiwiZ3JpZEhlbHBlclJlZiIsImNhbWVyYVJlZiIsImdyaWRDb25uZWN0b3JNYXRlcmlhbFJlZiIsImNvbm5lY3Rvck1lc2hSZWYiLCJkZWJ1Z01lc2hSZWYiLCJzaW1wbGVDb25uZWN0b3JNYXRlcmlhbFJlZiIsInNpbXBsZUNvbm5lY3Rvck1lc2hSZWYiLCJpbnN0YW5jZVNob3dJbm5lciIsIkZsb2F0MzJBcnJheSIsImluc3RhbmNlU2hvd091dGVyIiwiaW5zdGFuY2VQb3NpdGlvbnMiLCJBcnJheSIsImZpbGwiLCJtYXAiLCJWZWN0b3IzIiwiY2FtZXJhIiwicmF5Y2FzdGVyIiwibW91c2UiLCJjb25zb2xlIiwibG9nIiwiZ3JpZFN0YXRlVGV4dHVyZSIsImRhdGEiLCJ0ZXh0dXJlIiwiRGF0YVRleHR1cmUiLCJSR0JBRm9ybWF0IiwiRmxvYXRUeXBlIiwibmVlZHNVcGRhdGUiLCJpbWFnZSIsImlkeCIsImN1cnJlbnQiLCJ1bmlmb3JtcyIsInVfcmFkaXVzQiIsInVfcmFkaXVzQSIsInVfc3BhY2luZyIsInVfZ3JpZFN0YXRlIiwidV9hY3RpdmVDb25uZWN0b3IiLCJ1X3RoaWNrbmVzcyIsInVfY3VydmF0dXJlIiwidV9ib3hTaXplIiwidXBkYXRlUHJvamVjdGlvbk1hdHJpeCIsImluc3RhbmNlSWQiLCJzdGFydE9mZnNldCIsIngiLCJ5IiwicG9zaXRpb24iLCJzZXQiLCJ1cGRhdGVNYXRyaXgiLCJzZXRNYXRyaXhBdCIsIm1hdHJpeCIsImdlb21ldHJ5IiwiYXR0cmlidXRlcyIsImFfaW5zdGFuY2VTaG93SW5uZXIiLCJhX2luc3RhbmNlU2hvd091dGVyIiwiaW5zdGFuY2VNYXRyaXgiLCJzY2FsZSIsImhhbmRsZUNsaWNrIiwiZXZlbnQiLCJjZW50ZXJBIiwiVmVjdG9yMiIsImNlbnRlckIiLCJjZW50ZXJDIiwiY2VudGVyRCIsImNsaWNrUG9pbnQiLCJwb2ludCIsIkEiLCJCIiwiQyIsIkQiLCJpc0luVG9wUm93Q29ubmVjdG9yQXJlYSIsImlzUG9pbnRJbkhvcml6b250YWxDb25uZWN0b3JBcmVhIiwiaXNJbkJvdHRvbVJvd0Nvbm5lY3RvckFyZWEiLCJpc0luQW55RGlhZ29uYWxBcmVhIiwiaXNQb2ludEluQ29ubmVjdG9yQXJlYSIsImhhbmRsZUhvcml6b250YWxDb25uZWN0b3JDbGljayIsImhhbmRsZURpYWdvbmFsQ29ubmVjdG9yQ3ljbGUiLCJ1bmRlZmluZWQiLCJjdXJyZW50U3RhdGUiLCJpbnN0YW5jZVBvc2l0aW9uIiwicG9pbnRDb3B5IiwiY2xvbmUiLCJkaXN0RnJvbUNlbnRlciIsImRpc3RhbmNlVG8iLCJuZXdJbm5lciIsIm5ld091dGVyIiwiY3VycmVudFJvdyIsImlzQ29ubmVjdG9ySW5PdGhlclJvdyIsInByZXZTdGF0ZSIsIm5ld1N0YXRlIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5IiwiY2VudGVyMSIsImNlbnRlcjIiLCJkaXN0VG9DZW50ZXIxIiwiZGlzdFRvQ2VudGVyMiIsImRpcmVjdGlvbiIsInN1YlZlY3RvcnMiLCJub3JtYWxpemUiLCJjZW50ZXIxVG9Qb2ludCIsInByb2plY3Rpb25MZW5ndGgiLCJkb3QiLCJkaXN0YW5jZUJldHdlZW5DZW50ZXJzIiwicHJvamVjdGVkUG9pbnQiLCJjb3B5IiwiYWRkU2NhbGVkVmVjdG9yIiwicGVycERpc3RhbmNlIiwiY29ubmVjdG9yV2lkdGgiLCJyYWRpdXMiLCJtaWRZIiwibGVmdCIsInJpZ2h0IiwiaGFsZkhlaWdodCIsInJvdzEiLCJjb2wxIiwicm93MiIsImNvbDIiLCJoYXNDaXJjbGUxSW5EaWFnb25hbENvbm5lY3RvciIsImhhc0NpcmNsZTJJbkRpYWdvbmFsQ29ubmVjdG9yIiwiaG9yaXpvbnRhbENvbm5lY3RvclN0YXRlIiwiaGFzQ2lyY2xlSW5Ib3Jpem9udGFsQ29ubmVjdG9yIiwiY29ubmVjdG9yUGxhbmVTaXplIiwibWVzaCIsInJlZiIsInBsYW5lR2VvbWV0cnkiLCJhcmdzIiwibWVzaEJhc2ljTWF0ZXJpYWwiLCJjb2xvciIsIm9wYWNpdHkiLCJ0cmFuc3BhcmVudCIsInZpc2libGUiLCJyb3RhdGlvbiIsIlBJIiwic3FydCIsIm9uQ2xpY2siLCJzaW1wbGVDb25uZWN0b3JNYXRlcmlhbCIsImRlcHRoVGVzdCIsImtleSIsImdyaWRDb25uZWN0b3JNYXRlcmlhbCIsImluc3RhbmNlZE1lc2giLCJpbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUiLCJhdHRhY2giLCJjb25uZWN0b3JNYXRlcmlhbCIsImdyb3VwIiwiZ3JpZEhlbHBlciIsIldlYkdMQ2FudmFzIiwic3R5bGUiLCJiYWNrZ3JvdW5kIiwibWFrZURlZmF1bHQiLCJhbWJpZW50TGlnaHQiLCJpbnRlbnNpdHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/WebGLCanvas.js\n");

/***/ })

};
;