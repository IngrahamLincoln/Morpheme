/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/index";
exports.ids = ["pages/index"];
exports.modules = {

/***/ "./styles/Home.module.css":
/*!********************************!*\
  !*** ./styles/Home.module.css ***!
  \********************************/
/***/ ((module) => {

eval("// Exports\nmodule.exports = {\n\t\"container\": \"Home_container__d256j\",\n\t\"main\": \"Home_main__VkIEL\",\n\t\"title\": \"Home_title__hYX6j\"\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zdHlsZXMvSG9tZS5tb2R1bGUuY3NzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYmdsLWRvdC1ncmlkLW12cC8uL3N0eWxlcy9Ib21lLm1vZHVsZS5jc3M/YmMyMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBFeHBvcnRzXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0XCJjb250YWluZXJcIjogXCJIb21lX2NvbnRhaW5lcl9fZDI1NmpcIixcblx0XCJtYWluXCI6IFwiSG9tZV9tYWluX19Wa0lFTFwiLFxuXHRcInRpdGxlXCI6IFwiSG9tZV90aXRsZV9faFlYNmpcIlxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./styles/Home.module.css\n");

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES&page=%2F&preferredRegion=&absolutePagePath=.%2Fpages%2Findex.js&absoluteAppPath=private-next-pages%2F_app&absoluteDocumentPath=private-next-pages%2F_document&middlewareConfigBase64=e30%3D!":
/*!*****************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES&page=%2F&preferredRegion=&absolutePagePath=.%2Fpages%2Findex.js&absoluteAppPath=private-next-pages%2F_app&absoluteDocumentPath=private-next-pages%2F_document&middlewareConfigBase64=e30%3D! ***!
  \*****************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   getServerSideProps: () => (/* binding */ getServerSideProps),\n/* harmony export */   getStaticPaths: () => (/* binding */ getStaticPaths),\n/* harmony export */   getStaticProps: () => (/* binding */ getStaticProps),\n/* harmony export */   reportWebVitals: () => (/* binding */ reportWebVitals),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   unstable_getServerProps: () => (/* binding */ unstable_getServerProps),\n/* harmony export */   unstable_getServerSideProps: () => (/* binding */ unstable_getServerSideProps),\n/* harmony export */   unstable_getStaticParams: () => (/* binding */ unstable_getStaticParams),\n/* harmony export */   unstable_getStaticPaths: () => (/* binding */ unstable_getStaticPaths),\n/* harmony export */   unstable_getStaticProps: () => (/* binding */ unstable_getStaticProps)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_pages_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/pages/module.compiled */ \"./node_modules/next/dist/server/future/route-modules/pages/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_pages_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_pages_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/build/templates/helpers */ \"./node_modules/next/dist/build/templates/helpers.js\");\n/* harmony import */ var private_next_pages_document__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! private-next-pages/_document */ \"./node_modules/next/dist/pages/_document.js\");\n/* harmony import */ var private_next_pages_document__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(private_next_pages_document__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var private_next_pages_app__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! private-next-pages/_app */ \"./node_modules/next/dist/pages/_app.js\");\n/* harmony import */ var private_next_pages_app__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(private_next_pages_app__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _pages_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./pages/index.js */ \"./pages/index.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_pages_index_js__WEBPACK_IMPORTED_MODULE_5__]);\n_pages_index_js__WEBPACK_IMPORTED_MODULE_5__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n// Import the app and document modules.\n\n\n// Import the userland code.\n\n// Re-export the component (should be the default export).\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_index_js__WEBPACK_IMPORTED_MODULE_5__, \"default\"));\n// Re-export methods.\nconst getStaticProps = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_index_js__WEBPACK_IMPORTED_MODULE_5__, \"getStaticProps\");\nconst getStaticPaths = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_index_js__WEBPACK_IMPORTED_MODULE_5__, \"getStaticPaths\");\nconst getServerSideProps = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_index_js__WEBPACK_IMPORTED_MODULE_5__, \"getServerSideProps\");\nconst config = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_index_js__WEBPACK_IMPORTED_MODULE_5__, \"config\");\nconst reportWebVitals = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_index_js__WEBPACK_IMPORTED_MODULE_5__, \"reportWebVitals\");\n// Re-export legacy methods.\nconst unstable_getStaticProps = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_index_js__WEBPACK_IMPORTED_MODULE_5__, \"unstable_getStaticProps\");\nconst unstable_getStaticPaths = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_index_js__WEBPACK_IMPORTED_MODULE_5__, \"unstable_getStaticPaths\");\nconst unstable_getStaticParams = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_index_js__WEBPACK_IMPORTED_MODULE_5__, \"unstable_getStaticParams\");\nconst unstable_getServerProps = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_index_js__WEBPACK_IMPORTED_MODULE_5__, \"unstable_getServerProps\");\nconst unstable_getServerSideProps = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_index_js__WEBPACK_IMPORTED_MODULE_5__, \"unstable_getServerSideProps\");\n// Create and export the route module that will be consumed.\nconst routeModule = new next_dist_server_future_route_modules_pages_module_compiled__WEBPACK_IMPORTED_MODULE_0__.PagesRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.PAGES,\n        page: \"/index\",\n        pathname: \"/\",\n        // The following aren't used in production.\n        bundlePath: \"\",\n        filename: \"\"\n    },\n    components: {\n        App: (private_next_pages_app__WEBPACK_IMPORTED_MODULE_4___default()),\n        Document: (private_next_pages_document__WEBPACK_IMPORTED_MODULE_3___default())\n    },\n    userland: _pages_index_js__WEBPACK_IMPORTED_MODULE_5__\n});\n\n//# sourceMappingURL=pages.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXJvdXRlLWxvYWRlci9pbmRleC5qcz9raW5kPVBBR0VTJnBhZ2U9JTJGJnByZWZlcnJlZFJlZ2lvbj0mYWJzb2x1dGVQYWdlUGF0aD0uJTJGcGFnZXMlMkZpbmRleC5qcyZhYnNvbHV0ZUFwcFBhdGg9cHJpdmF0ZS1uZXh0LXBhZ2VzJTJGX2FwcCZhYnNvbHV0ZURvY3VtZW50UGF0aD1wcml2YXRlLW5leHQtcGFnZXMlMkZfZG9jdW1lbnQmbWlkZGxld2FyZUNvbmZpZ0Jhc2U2ND1lMzAlM0QhIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUErRjtBQUNoQztBQUNMO0FBQzFEO0FBQ29EO0FBQ1Y7QUFDMUM7QUFDNkM7QUFDN0M7QUFDQSxpRUFBZSx3RUFBSyxDQUFDLDRDQUFRLFlBQVksRUFBQztBQUMxQztBQUNPLHVCQUF1Qix3RUFBSyxDQUFDLDRDQUFRO0FBQ3JDLHVCQUF1Qix3RUFBSyxDQUFDLDRDQUFRO0FBQ3JDLDJCQUEyQix3RUFBSyxDQUFDLDRDQUFRO0FBQ3pDLGVBQWUsd0VBQUssQ0FBQyw0Q0FBUTtBQUM3Qix3QkFBd0Isd0VBQUssQ0FBQyw0Q0FBUTtBQUM3QztBQUNPLGdDQUFnQyx3RUFBSyxDQUFDLDRDQUFRO0FBQzlDLGdDQUFnQyx3RUFBSyxDQUFDLDRDQUFRO0FBQzlDLGlDQUFpQyx3RUFBSyxDQUFDLDRDQUFRO0FBQy9DLGdDQUFnQyx3RUFBSyxDQUFDLDRDQUFRO0FBQzlDLG9DQUFvQyx3RUFBSyxDQUFDLDRDQUFRO0FBQ3pEO0FBQ08sd0JBQXdCLHlHQUFnQjtBQUMvQztBQUNBLGNBQWMseUVBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLFdBQVc7QUFDWCxnQkFBZ0I7QUFDaEIsS0FBSztBQUNMLFlBQVk7QUFDWixDQUFDOztBQUVELGlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViZ2wtZG90LWdyaWQtbXZwLz8xNDNkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBhZ2VzUm91dGVNb2R1bGUgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9mdXR1cmUvcm91dGUtbW9kdWxlcy9wYWdlcy9tb2R1bGUuY29tcGlsZWRcIjtcbmltcG9ydCB7IFJvdXRlS2luZCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1raW5kXCI7XG5pbXBvcnQgeyBob2lzdCB9IGZyb20gXCJuZXh0L2Rpc3QvYnVpbGQvdGVtcGxhdGVzL2hlbHBlcnNcIjtcbi8vIEltcG9ydCB0aGUgYXBwIGFuZCBkb2N1bWVudCBtb2R1bGVzLlxuaW1wb3J0IERvY3VtZW50IGZyb20gXCJwcml2YXRlLW5leHQtcGFnZXMvX2RvY3VtZW50XCI7XG5pbXBvcnQgQXBwIGZyb20gXCJwcml2YXRlLW5leHQtcGFnZXMvX2FwcFwiO1xuLy8gSW1wb3J0IHRoZSB1c2VybGFuZCBjb2RlLlxuaW1wb3J0ICogYXMgdXNlcmxhbmQgZnJvbSBcIi4vcGFnZXMvaW5kZXguanNcIjtcbi8vIFJlLWV4cG9ydCB0aGUgY29tcG9uZW50IChzaG91bGQgYmUgdGhlIGRlZmF1bHQgZXhwb3J0KS5cbmV4cG9ydCBkZWZhdWx0IGhvaXN0KHVzZXJsYW5kLCBcImRlZmF1bHRcIik7XG4vLyBSZS1leHBvcnQgbWV0aG9kcy5cbmV4cG9ydCBjb25zdCBnZXRTdGF0aWNQcm9wcyA9IGhvaXN0KHVzZXJsYW5kLCBcImdldFN0YXRpY1Byb3BzXCIpO1xuZXhwb3J0IGNvbnN0IGdldFN0YXRpY1BhdGhzID0gaG9pc3QodXNlcmxhbmQsIFwiZ2V0U3RhdGljUGF0aHNcIik7XG5leHBvcnQgY29uc3QgZ2V0U2VydmVyU2lkZVByb3BzID0gaG9pc3QodXNlcmxhbmQsIFwiZ2V0U2VydmVyU2lkZVByb3BzXCIpO1xuZXhwb3J0IGNvbnN0IGNvbmZpZyA9IGhvaXN0KHVzZXJsYW5kLCBcImNvbmZpZ1wiKTtcbmV4cG9ydCBjb25zdCByZXBvcnRXZWJWaXRhbHMgPSBob2lzdCh1c2VybGFuZCwgXCJyZXBvcnRXZWJWaXRhbHNcIik7XG4vLyBSZS1leHBvcnQgbGVnYWN5IG1ldGhvZHMuXG5leHBvcnQgY29uc3QgdW5zdGFibGVfZ2V0U3RhdGljUHJvcHMgPSBob2lzdCh1c2VybGFuZCwgXCJ1bnN0YWJsZV9nZXRTdGF0aWNQcm9wc1wiKTtcbmV4cG9ydCBjb25zdCB1bnN0YWJsZV9nZXRTdGF0aWNQYXRocyA9IGhvaXN0KHVzZXJsYW5kLCBcInVuc3RhYmxlX2dldFN0YXRpY1BhdGhzXCIpO1xuZXhwb3J0IGNvbnN0IHVuc3RhYmxlX2dldFN0YXRpY1BhcmFtcyA9IGhvaXN0KHVzZXJsYW5kLCBcInVuc3RhYmxlX2dldFN0YXRpY1BhcmFtc1wiKTtcbmV4cG9ydCBjb25zdCB1bnN0YWJsZV9nZXRTZXJ2ZXJQcm9wcyA9IGhvaXN0KHVzZXJsYW5kLCBcInVuc3RhYmxlX2dldFNlcnZlclByb3BzXCIpO1xuZXhwb3J0IGNvbnN0IHVuc3RhYmxlX2dldFNlcnZlclNpZGVQcm9wcyA9IGhvaXN0KHVzZXJsYW5kLCBcInVuc3RhYmxlX2dldFNlcnZlclNpZGVQcm9wc1wiKTtcbi8vIENyZWF0ZSBhbmQgZXhwb3J0IHRoZSByb3V0ZSBtb2R1bGUgdGhhdCB3aWxsIGJlIGNvbnN1bWVkLlxuZXhwb3J0IGNvbnN0IHJvdXRlTW9kdWxlID0gbmV3IFBhZ2VzUm91dGVNb2R1bGUoe1xuICAgIGRlZmluaXRpb246IHtcbiAgICAgICAga2luZDogUm91dGVLaW5kLlBBR0VTLFxuICAgICAgICBwYWdlOiBcIi9pbmRleFwiLFxuICAgICAgICBwYXRobmFtZTogXCIvXCIsXG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgYXJlbid0IHVzZWQgaW4gcHJvZHVjdGlvbi5cbiAgICAgICAgYnVuZGxlUGF0aDogXCJcIixcbiAgICAgICAgZmlsZW5hbWU6IFwiXCJcbiAgICB9LFxuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgQXBwLFxuICAgICAgICBEb2N1bWVudFxuICAgIH0sXG4gICAgdXNlcmxhbmRcbn0pO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYWdlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES&page=%2F&preferredRegion=&absolutePagePath=.%2Fpages%2Findex.js&absoluteAppPath=private-next-pages%2F_app&absoluteDocumentPath=private-next-pages%2F_document&middlewareConfigBase64=e30%3D!\n");

/***/ }),

/***/ "./components/CircleMaterial.tsx":
/*!***************************************!*\
  !*** ./components/CircleMaterial.tsx ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-three/drei */ \"@react-three/drei\");\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_react_three_drei__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-three/fiber */ \"@react-three/fiber\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__);\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([three__WEBPACK_IMPORTED_MODULE_0__]);\nthree__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n// Simple vertex shader\nconst vertexShader = /*glsl*/ `\n  varying vec2 vUv;\n  attribute float a_activated; // Will be used in Feature 4\n  varying float v_activated;   // Will be used in Feature 4\n  void main() {\n    vUv = uv;\n    v_activated = a_activated; // Pass activation state\n    gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0);\n  }\n`;\n// Fragment shader to draw two concentric circles\nconst fragmentShader = /*glsl*/ `\n  uniform float u_radiusA;      // Outer radius (scaled relative to instance size)\n  uniform float u_radiusB;      // Inner radius (scaled relative to instance size)\n  uniform vec3 u_bgColor;       // Background color (or transparent)\n  uniform vec3 u_outerColor;    // Color of the outer ring\n  uniform vec3 u_innerColorEmpty; // Color of the inner circle when inactive\n  uniform vec3 u_innerColorActive;// Color of the inner circle when active\n\n  varying vec2 vUv;\n  varying float v_activated; // Read from vertex shader (comes from a_activated attribute)\n\n  void main() {\n    float dist = distance(vUv, vec2(0.5));\n\n    // Discard if outside the outer circle\n    if (dist > u_radiusA) {\n        discard;\n    }\n\n    // Check activation state first\n    if (v_activated == 1.0) {\n        // If activated, only draw the inner circle (black)\n        if (dist <= u_radiusB) {\n            gl_FragColor = vec4(u_innerColorActive, 1.0); // Solid black inner circle\n        } else {\n            discard; // Make outer ring transparent when activated\n        }\n    } else {\n        // Not activated - draw both inner and outer circles\n        if (dist > u_radiusB) {\n            // In the outer ring\n            gl_FragColor = vec4(u_outerColor, 1.0);\n        } else {\n            // In the inner circle - empty/inactive\n            gl_FragColor = vec4(u_innerColorEmpty, 1.0);\n        }\n    }\n  }\n`;\n// Create the shader material using drei/shaderMaterial\nconst CircleMaterial = (0,_react_three_drei__WEBPACK_IMPORTED_MODULE_1__.shaderMaterial)({\n    u_radiusA: 0.5,\n    u_radiusB: 0.4,\n    u_bgColor: new three__WEBPACK_IMPORTED_MODULE_0__.Color(\"#ffffff\"),\n    u_outerColor: new three__WEBPACK_IMPORTED_MODULE_0__.Color(\"#cccccc\"),\n    u_innerColorEmpty: new three__WEBPACK_IMPORTED_MODULE_0__.Color(\"#ffffff\"),\n    u_innerColorActive: new three__WEBPACK_IMPORTED_MODULE_0__.Color(\"#000000\")\n}, vertexShader, fragmentShader);\n// Extend R3F to recognize the material\n(0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.extend)({\n    CircleMaterial\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CircleMaterial);\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL0NpcmNsZU1hdGVyaWFsLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBK0I7QUFDb0I7QUFDUDtBQUU1Qyx1QkFBdUI7QUFDdkIsTUFBTUcsZUFBZSxNQUFNLEdBQUcsQ0FBQzs7Ozs7Ozs7O0FBUy9CLENBQUM7QUFFRCxpREFBaUQ7QUFDakQsTUFBTUMsaUJBQWlCLE1BQU0sR0FBRyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNDakMsQ0FBQztBQUVELHVEQUF1RDtBQUN2RCxNQUFNQyxpQkFBaUJKLGlFQUFjQSxDQUNuQztJQUNFSyxXQUFXO0lBQ1hDLFdBQVc7SUFDWEMsV0FBVyxJQUFJUix3Q0FBVyxDQUFDO0lBQzNCVSxjQUFjLElBQUlWLHdDQUFXLENBQUM7SUFDOUJXLG1CQUFtQixJQUFJWCx3Q0FBVyxDQUFDO0lBQ25DWSxvQkFBb0IsSUFBSVosd0NBQVcsQ0FBQztBQUN0QyxHQUNBRyxjQUNBQztBQUdGLHVDQUF1QztBQUN2Q0YsMERBQU1BLENBQUM7SUFBRUc7QUFBZTtBQVd4QixpRUFBZUEsY0FBY0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYmdsLWRvdC1ncmlkLW12cC8uL2NvbXBvbmVudHMvQ2lyY2xlTWF0ZXJpYWwudHN4PzQyNTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgc2hhZGVyTWF0ZXJpYWwgfSBmcm9tICdAcmVhY3QtdGhyZWUvZHJlaSc7XG5pbXBvcnQgeyBleHRlbmQgfSBmcm9tICdAcmVhY3QtdGhyZWUvZmliZXInO1xuXG4vLyBTaW1wbGUgdmVydGV4IHNoYWRlclxuY29uc3QgdmVydGV4U2hhZGVyID0gLypnbHNsKi8gYFxuICB2YXJ5aW5nIHZlYzIgdlV2O1xuICBhdHRyaWJ1dGUgZmxvYXQgYV9hY3RpdmF0ZWQ7IC8vIFdpbGwgYmUgdXNlZCBpbiBGZWF0dXJlIDRcbiAgdmFyeWluZyBmbG9hdCB2X2FjdGl2YXRlZDsgICAvLyBXaWxsIGJlIHVzZWQgaW4gRmVhdHVyZSA0XG4gIHZvaWQgbWFpbigpIHtcbiAgICB2VXYgPSB1djtcbiAgICB2X2FjdGl2YXRlZCA9IGFfYWN0aXZhdGVkOyAvLyBQYXNzIGFjdGl2YXRpb24gc3RhdGVcbiAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiBpbnN0YW5jZU1hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XG4gIH1cbmA7XG5cbi8vIEZyYWdtZW50IHNoYWRlciB0byBkcmF3IHR3byBjb25jZW50cmljIGNpcmNsZXNcbmNvbnN0IGZyYWdtZW50U2hhZGVyID0gLypnbHNsKi8gYFxuICB1bmlmb3JtIGZsb2F0IHVfcmFkaXVzQTsgICAgICAvLyBPdXRlciByYWRpdXMgKHNjYWxlZCByZWxhdGl2ZSB0byBpbnN0YW5jZSBzaXplKVxuICB1bmlmb3JtIGZsb2F0IHVfcmFkaXVzQjsgICAgICAvLyBJbm5lciByYWRpdXMgKHNjYWxlZCByZWxhdGl2ZSB0byBpbnN0YW5jZSBzaXplKVxuICB1bmlmb3JtIHZlYzMgdV9iZ0NvbG9yOyAgICAgICAvLyBCYWNrZ3JvdW5kIGNvbG9yIChvciB0cmFuc3BhcmVudClcbiAgdW5pZm9ybSB2ZWMzIHVfb3V0ZXJDb2xvcjsgICAgLy8gQ29sb3Igb2YgdGhlIG91dGVyIHJpbmdcbiAgdW5pZm9ybSB2ZWMzIHVfaW5uZXJDb2xvckVtcHR5OyAvLyBDb2xvciBvZiB0aGUgaW5uZXIgY2lyY2xlIHdoZW4gaW5hY3RpdmVcbiAgdW5pZm9ybSB2ZWMzIHVfaW5uZXJDb2xvckFjdGl2ZTsvLyBDb2xvciBvZiB0aGUgaW5uZXIgY2lyY2xlIHdoZW4gYWN0aXZlXG5cbiAgdmFyeWluZyB2ZWMyIHZVdjtcbiAgdmFyeWluZyBmbG9hdCB2X2FjdGl2YXRlZDsgLy8gUmVhZCBmcm9tIHZlcnRleCBzaGFkZXIgKGNvbWVzIGZyb20gYV9hY3RpdmF0ZWQgYXR0cmlidXRlKVxuXG4gIHZvaWQgbWFpbigpIHtcbiAgICBmbG9hdCBkaXN0ID0gZGlzdGFuY2UodlV2LCB2ZWMyKDAuNSkpO1xuXG4gICAgLy8gRGlzY2FyZCBpZiBvdXRzaWRlIHRoZSBvdXRlciBjaXJjbGVcbiAgICBpZiAoZGlzdCA+IHVfcmFkaXVzQSkge1xuICAgICAgICBkaXNjYXJkO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGFjdGl2YXRpb24gc3RhdGUgZmlyc3RcbiAgICBpZiAodl9hY3RpdmF0ZWQgPT0gMS4wKSB7XG4gICAgICAgIC8vIElmIGFjdGl2YXRlZCwgb25seSBkcmF3IHRoZSBpbm5lciBjaXJjbGUgKGJsYWNrKVxuICAgICAgICBpZiAoZGlzdCA8PSB1X3JhZGl1c0IpIHtcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQodV9pbm5lckNvbG9yQWN0aXZlLCAxLjApOyAvLyBTb2xpZCBibGFjayBpbm5lciBjaXJjbGVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpc2NhcmQ7IC8vIE1ha2Ugb3V0ZXIgcmluZyB0cmFuc3BhcmVudCB3aGVuIGFjdGl2YXRlZFxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm90IGFjdGl2YXRlZCAtIGRyYXcgYm90aCBpbm5lciBhbmQgb3V0ZXIgY2lyY2xlc1xuICAgICAgICBpZiAoZGlzdCA+IHVfcmFkaXVzQikge1xuICAgICAgICAgICAgLy8gSW4gdGhlIG91dGVyIHJpbmdcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQodV9vdXRlckNvbG9yLCAxLjApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSW4gdGhlIGlubmVyIGNpcmNsZSAtIGVtcHR5L2luYWN0aXZlXG4gICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHVfaW5uZXJDb2xvckVtcHR5LCAxLjApO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5gO1xuXG4vLyBDcmVhdGUgdGhlIHNoYWRlciBtYXRlcmlhbCB1c2luZyBkcmVpL3NoYWRlck1hdGVyaWFsXG5jb25zdCBDaXJjbGVNYXRlcmlhbCA9IHNoYWRlck1hdGVyaWFsKFxuICB7XG4gICAgdV9yYWRpdXNBOiAwLjUsIC8vIERlZmF1bHQgdmFsdWUsIHdpbGwgYmUgdXBkYXRlZFxuICAgIHVfcmFkaXVzQjogMC40LCAvLyBEZWZhdWx0IHZhbHVlLCB3aWxsIGJlIHVwZGF0ZWRcbiAgICB1X2JnQ29sb3I6IG5ldyBUSFJFRS5Db2xvcignI2ZmZmZmZicpLCAvLyBEZWZhdWx0IGJnXG4gICAgdV9vdXRlckNvbG9yOiBuZXcgVEhSRUUuQ29sb3IoJyNjY2NjY2MnKSwgLy8gTGlnaHQgZ3JleSBvdXRlciByaW5nXG4gICAgdV9pbm5lckNvbG9yRW1wdHk6IG5ldyBUSFJFRS5Db2xvcignI2ZmZmZmZicpLCAvLyBXaGl0ZS90cmFuc3BhcmVudCBpbm5lciBlbXB0eVxuICAgIHVfaW5uZXJDb2xvckFjdGl2ZTogbmV3IFRIUkVFLkNvbG9yKCcjMDAwMDAwJyksIC8vIEJsYWNrIGlubmVyIGFjdGl2ZVxuICB9LFxuICB2ZXJ0ZXhTaGFkZXIsXG4gIGZyYWdtZW50U2hhZGVyXG4pO1xuXG4vLyBFeHRlbmQgUjNGIHRvIHJlY29nbml6ZSB0aGUgbWF0ZXJpYWxcbmV4dGVuZCh7IENpcmNsZU1hdGVyaWFsIH0pO1xuXG4vLyBEZWZpbmUgVHlwZVNjcmlwdCB0eXBlIGZvciBKU1ggdXNhZ2VcbmRlY2xhcmUgZ2xvYmFsIHtcbiAgbmFtZXNwYWNlIEpTWCB7XG4gICAgaW50ZXJmYWNlIEludHJpbnNpY0VsZW1lbnRzIHtcbiAgICAgIGNpcmNsZU1hdGVyaWFsOiBhbnk7IC8vIFVzZSBcXCdhbnlcXCcgb3IgZGVmaW5lIG1vcmUgc3BlY2lmaWMgdHlwZXNcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2lyY2xlTWF0ZXJpYWw7ICJdLCJuYW1lcyI6WyJUSFJFRSIsInNoYWRlck1hdGVyaWFsIiwiZXh0ZW5kIiwidmVydGV4U2hhZGVyIiwiZnJhZ21lbnRTaGFkZXIiLCJDaXJjbGVNYXRlcmlhbCIsInVfcmFkaXVzQSIsInVfcmFkaXVzQiIsInVfYmdDb2xvciIsIkNvbG9yIiwidV9vdXRlckNvbG9yIiwidV9pbm5lckNvbG9yRW1wdHkiLCJ1X2lubmVyQ29sb3JBY3RpdmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/CircleMaterial.tsx\n");

/***/ }),

/***/ "./components/CmdHorizConnectorMaterial.tsx":
/*!**************************************************!*\
  !*** ./components/CmdHorizConnectorMaterial.tsx ***!
  \**************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-three/drei */ \"@react-three/drei\");\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_react_three_drei__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-three/fiber */ \"@react-three/fiber\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__);\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([three__WEBPACK_IMPORTED_MODULE_0__]);\nthree__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n// Constants from GridScene/ConnectorMaterial needed for calculations\nconst BASE_RADIUS_A = 0.5; // Outer radius relative to spacing=1\nconst BASE_RADIUS_B = 0.4; // Inner radius relative to spacing=1\nconst FIXED_SPACING = BASE_RADIUS_A + BASE_RADIUS_B; // 0.9\n// Vertex shader: Pass UVs (same as ConnectorMaterial)\nconst vertexShader = /*glsl*/ `\n  varying vec2 vUv;\n  void main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  }\n`;\n// Fragment shader: Only for Cmd-Click Horizontal Connectors\nconst fragmentShader = /*glsl*/ `\n  uniform sampler2D u_stateTexture;             // Need state to confirm circles are active\n  uniform sampler2D u_cmdHorizConnectorTexture; // Texture for cmd-click horizontal connectors\n  uniform vec2 u_gridDimensions;            // Grid size (width, height) in cells\n  uniform vec2 u_textureResolution;         // State Texture size (width, height) in pixels\n  uniform float u_radiusA;                  // Outer radius (base value)\n  uniform float u_radiusB;                  // Inner radius (base value)\n  uniform float u_gridSpacing;              // Visual scale factor (from Leva)\n  // World space uniforms\n  uniform vec2 u_centerOffset;              // World offset for centering grid\n  uniform vec2 u_planeSize;                 // World size of connector plane\n\n  varying vec2 vUv;\n\n  // --- SDF Helper Functions ---\n  float sdCircle(vec2 p, float r) {\n    return length(p) - r;\n  }\n\n  // SDF function for rectangle with sharp corners\n  float sdBox2D(vec2 p, vec2 halfSize) {\n    vec2 d = abs(p) - halfSize;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n  }\n\n  // --- State Sampling Helper ---\n  float getState(ivec2 cellCoord) {\n    // Use u_textureResolution (size of stateTexture) for clamping\n    ivec2 clampedCoord = clamp(cellCoord, ivec2(0), ivec2(u_textureResolution) - ivec2(1));\n    if (cellCoord != clampedCoord) return 0.0;\n    return texelFetch(u_stateTexture, clampedCoord, 0).r;\n  }\n\n  // --- Cmd-Click Horizontal Connector Sampling ---\n  float getCmdHorizConnector(ivec2 cellCoord) {\n    // The cmd-horiz texture is (gridWidth-1) x gridHeight\n    ivec2 horizTextureSize = ivec2(u_gridDimensions.x - 1.0, u_gridDimensions.y);\n     // Check bounds against the actual size of the cmdHorizConnectorTexture\n    if (cellCoord.x < 0 || cellCoord.x >= horizTextureSize.x ||\n        cellCoord.y < 0 || cellCoord.y >= horizTextureSize.y) {\n      return 0.0;\n    }\n    // Fetch from the dedicated texture\n    return texelFetch(u_cmdHorizConnectorTexture, cellCoord, 0).r;\n  }\n\n  // --- Get Cell Center in World Space ---\n  vec2 getCellWorldCenter(ivec2 cell) {\n    // Using the fixed spacing value directly. Ensure this matches TS definition.\n    float fixedSpacingValue = 0.9; // Direct value of BASE_RADIUS_A + BASE_RADIUS_B\n    float worldX = float(cell.x) * fixedSpacingValue + u_centerOffset.x;\n    float worldY = float(cell.y) * fixedSpacingValue + u_centerOffset.y;\n    return vec2(worldX, worldY);\n  }\n\n  // --- Function to calculate SDF for a given row ---\n  float calculateConnectorSDF(ivec2 baseCell, vec2 fragPos, float worldRadA, float worldRadB) {\n    float sdf = 1e6; // Default to outside\n\n    float cmdConn = getCmdHorizConnector(baseCell);\n    if (cmdConn > 0.0) {\n        ivec2 rightCell = baseCell + ivec2(1, 0);\n        float stateL = getState(baseCell);\n        float stateR = getState(rightCell);\n\n        if (stateL == 1.0 && stateR == 1.0) {\n            vec2 centerL = getCellWorldCenter(baseCell);\n            vec2 centerR = getCellWorldCenter(rightCell);\n\n            vec2 connCenter = (centerL + centerR) * 0.5;\n            // REMOVED vertical shift: connCenter.y -= worldRadB * 0.15;\n\n            float connWidth = distance(centerL, centerR);\n            // Use inner radius (RadiusB) for thinner connector matching circle thickness\n            float connHeight = worldRadB * 2.0; // Changed from worldRadA to worldRadB\n\n            vec2 p = fragPos - connCenter;\n            // No rotation needed for axis-aligned horizontal box\n            // float angle = atan(centerR.y - centerL.y, centerR.x - centerL.x);\n            // float c = cos(-angle);\n            // float s = sin(-angle);\n            // p = vec2(c * p.x - s * p.y, s * p.x + c * p.y);\n\n            sdf = sdBox2D(p, vec2(connWidth * 0.5, connHeight * 0.5));\n        }\n    }\n    return sdf;\n  }\n\n\n  void main() {\n    // Calculate fragment's world position\n    vec2 planeOrigin = -u_planeSize * 0.5;\n    vec2 fragWorldPos = planeOrigin + vUv * u_planeSize;\n\n    // Determine the potential bottom-left cell based on floor\n    float fixedSpacingValue = 0.9;\n    vec2 gridCoord = (fragWorldPos - u_centerOffset) / fixedSpacingValue;\n    ivec2 cell_bl_current = ivec2(floor(gridCoord)); // Cell for the current row floor\n\n    // Define the cell for the row above\n    ivec2 cell_bl_above = cell_bl_current + ivec2(0, 1);\n\n    // Calculate world-space radii\n    float worldRadiusA = u_radiusA * u_gridSpacing;\n    float worldRadiusB = u_radiusB * u_gridSpacing;\n\n    // Calculate SDF for the connector potentially in the current row\n    float sdf_current = calculateConnectorSDF(cell_bl_current, fragWorldPos, worldRadiusA, worldRadiusB);\n\n    // Calculate SDF for the connector potentially in the row above\n    float sdf_above = calculateConnectorSDF(cell_bl_above, fragWorldPos, worldRadiusA, worldRadiusB);\n\n    // The final SDF is the minimum of the two (closest connector wins)\n    float finalSdf = min(sdf_current, sdf_above);\n\n    // Final Output: Draw if inside the combined SDF\n    if (finalSdf < 0.0) {\n      float smoothFactor = fwidth(finalSdf) * 0.8; // Anti-aliasing\n      float alpha = smoothstep(smoothFactor, -smoothFactor, finalSdf);\n\n      if (alpha > 0.01) {\n        gl_FragColor = vec4(0.0, 0.0, 0.0, alpha); // Black connector\n      } else {\n        discard; // Discard transparent fragments\n      }\n    } else {\n      discard; // Discard fragments outside the shape\n    }\n  }\n`;\n// Create the shader material\nconst CmdHorizConnectorMaterial = (0,_react_three_drei__WEBPACK_IMPORTED_MODULE_1__.shaderMaterial)({\n    u_stateTexture: null,\n    u_cmdHorizConnectorTexture: null,\n    u_gridDimensions: new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(10, 10),\n    u_textureResolution: new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(10, 10),\n    u_radiusA: BASE_RADIUS_A,\n    u_radiusB: BASE_RADIUS_B,\n    u_gridSpacing: 1.0,\n    u_centerOffset: new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(0, 0),\n    u_planeSize: new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(10, 10)\n}, vertexShader, fragmentShader);\n// Extend R3F\n(0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.extend)({\n    CmdHorizConnectorMaterial\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CmdHorizConnectorMaterial);\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL0NtZEhvcml6Q29ubmVjdG9yTWF0ZXJpYWwudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUErQjtBQUNvQjtBQUNQO0FBRTVDLHFFQUFxRTtBQUNyRSxNQUFNRyxnQkFBZ0IsS0FBSyxxQ0FBcUM7QUFDaEUsTUFBTUMsZ0JBQWdCLEtBQUsscUNBQXFDO0FBQ2hFLE1BQU1DLGdCQUFnQkYsZ0JBQWdCQyxlQUFlLE1BQU07QUFFM0Qsc0RBQXNEO0FBQ3RELE1BQU1FLGVBQWUsTUFBTSxHQUFHLENBQUM7Ozs7OztBQU0vQixDQUFDO0FBRUQsNERBQTREO0FBQzVELE1BQU1DLGlCQUFpQixNQUFNLEdBQUcsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtJakMsQ0FBQztBQUVELDZCQUE2QjtBQUM3QixNQUFNQyw0QkFBNEJQLGlFQUFjQSxDQUM5QztJQUNFUSxnQkFBZ0I7SUFDaEJDLDRCQUE0QjtJQUM1QkMsa0JBQWtCLElBQUlYLDBDQUFhLENBQUMsSUFBSTtJQUN4Q2EscUJBQXFCLElBQUliLDBDQUFhLENBQUMsSUFBSTtJQUMzQ2MsV0FBV1g7SUFDWFksV0FBV1g7SUFDWFksZUFBZTtJQUNmQyxnQkFBZ0IsSUFBSWpCLDBDQUFhLENBQUMsR0FBRztJQUNyQ2tCLGFBQWEsSUFBSWxCLDBDQUFhLENBQUMsSUFBSTtBQUNyQyxHQUNBTSxjQUNBQztBQUdGLGFBQWE7QUFDYkwsMERBQU1BLENBQUM7SUFBRU07QUFBMEI7QUFXbkMsaUVBQWVBLHlCQUF5QkEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYmdsLWRvdC1ncmlkLW12cC8uL2NvbXBvbmVudHMvQ21kSG9yaXpDb25uZWN0b3JNYXRlcmlhbC50c3g/MTM2ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyBzaGFkZXJNYXRlcmlhbCB9IGZyb20gJ0ByZWFjdC10aHJlZS9kcmVpJztcbmltcG9ydCB7IGV4dGVuZCB9IGZyb20gJ0ByZWFjdC10aHJlZS9maWJlcic7XG5cbi8vIENvbnN0YW50cyBmcm9tIEdyaWRTY2VuZS9Db25uZWN0b3JNYXRlcmlhbCBuZWVkZWQgZm9yIGNhbGN1bGF0aW9uc1xuY29uc3QgQkFTRV9SQURJVVNfQSA9IDAuNTsgLy8gT3V0ZXIgcmFkaXVzIHJlbGF0aXZlIHRvIHNwYWNpbmc9MVxuY29uc3QgQkFTRV9SQURJVVNfQiA9IDAuNDsgLy8gSW5uZXIgcmFkaXVzIHJlbGF0aXZlIHRvIHNwYWNpbmc9MVxuY29uc3QgRklYRURfU1BBQ0lORyA9IEJBU0VfUkFESVVTX0EgKyBCQVNFX1JBRElVU19COyAvLyAwLjlcblxuLy8gVmVydGV4IHNoYWRlcjogUGFzcyBVVnMgKHNhbWUgYXMgQ29ubmVjdG9yTWF0ZXJpYWwpXG5jb25zdCB2ZXJ0ZXhTaGFkZXIgPSAvKmdsc2wqLyBgXG4gIHZhcnlpbmcgdmVjMiB2VXY7XG4gIHZvaWQgbWFpbigpIHtcbiAgICB2VXYgPSB1djtcbiAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjApO1xuICB9XG5gO1xuXG4vLyBGcmFnbWVudCBzaGFkZXI6IE9ubHkgZm9yIENtZC1DbGljayBIb3Jpem9udGFsIENvbm5lY3RvcnNcbmNvbnN0IGZyYWdtZW50U2hhZGVyID0gLypnbHNsKi8gYFxuICB1bmlmb3JtIHNhbXBsZXIyRCB1X3N0YXRlVGV4dHVyZTsgICAgICAgICAgICAgLy8gTmVlZCBzdGF0ZSB0byBjb25maXJtIGNpcmNsZXMgYXJlIGFjdGl2ZVxuICB1bmlmb3JtIHNhbXBsZXIyRCB1X2NtZEhvcml6Q29ubmVjdG9yVGV4dHVyZTsgLy8gVGV4dHVyZSBmb3IgY21kLWNsaWNrIGhvcml6b250YWwgY29ubmVjdG9yc1xuICB1bmlmb3JtIHZlYzIgdV9ncmlkRGltZW5zaW9uczsgICAgICAgICAgICAvLyBHcmlkIHNpemUgKHdpZHRoLCBoZWlnaHQpIGluIGNlbGxzXG4gIHVuaWZvcm0gdmVjMiB1X3RleHR1cmVSZXNvbHV0aW9uOyAgICAgICAgIC8vIFN0YXRlIFRleHR1cmUgc2l6ZSAod2lkdGgsIGhlaWdodCkgaW4gcGl4ZWxzXG4gIHVuaWZvcm0gZmxvYXQgdV9yYWRpdXNBOyAgICAgICAgICAgICAgICAgIC8vIE91dGVyIHJhZGl1cyAoYmFzZSB2YWx1ZSlcbiAgdW5pZm9ybSBmbG9hdCB1X3JhZGl1c0I7ICAgICAgICAgICAgICAgICAgLy8gSW5uZXIgcmFkaXVzIChiYXNlIHZhbHVlKVxuICB1bmlmb3JtIGZsb2F0IHVfZ3JpZFNwYWNpbmc7ICAgICAgICAgICAgICAvLyBWaXN1YWwgc2NhbGUgZmFjdG9yIChmcm9tIExldmEpXG4gIC8vIFdvcmxkIHNwYWNlIHVuaWZvcm1zXG4gIHVuaWZvcm0gdmVjMiB1X2NlbnRlck9mZnNldDsgICAgICAgICAgICAgIC8vIFdvcmxkIG9mZnNldCBmb3IgY2VudGVyaW5nIGdyaWRcbiAgdW5pZm9ybSB2ZWMyIHVfcGxhbmVTaXplOyAgICAgICAgICAgICAgICAgLy8gV29ybGQgc2l6ZSBvZiBjb25uZWN0b3IgcGxhbmVcblxuICB2YXJ5aW5nIHZlYzIgdlV2O1xuXG4gIC8vIC0tLSBTREYgSGVscGVyIEZ1bmN0aW9ucyAtLS1cbiAgZmxvYXQgc2RDaXJjbGUodmVjMiBwLCBmbG9hdCByKSB7XG4gICAgcmV0dXJuIGxlbmd0aChwKSAtIHI7XG4gIH1cblxuICAvLyBTREYgZnVuY3Rpb24gZm9yIHJlY3RhbmdsZSB3aXRoIHNoYXJwIGNvcm5lcnNcbiAgZmxvYXQgc2RCb3gyRCh2ZWMyIHAsIHZlYzIgaGFsZlNpemUpIHtcbiAgICB2ZWMyIGQgPSBhYnMocCkgLSBoYWxmU2l6ZTtcbiAgICByZXR1cm4gbGVuZ3RoKG1heChkLCAwLjApKSArIG1pbihtYXgoZC54LCBkLnkpLCAwLjApO1xuICB9XG5cbiAgLy8gLS0tIFN0YXRlIFNhbXBsaW5nIEhlbHBlciAtLS1cbiAgZmxvYXQgZ2V0U3RhdGUoaXZlYzIgY2VsbENvb3JkKSB7XG4gICAgLy8gVXNlIHVfdGV4dHVyZVJlc29sdXRpb24gKHNpemUgb2Ygc3RhdGVUZXh0dXJlKSBmb3IgY2xhbXBpbmdcbiAgICBpdmVjMiBjbGFtcGVkQ29vcmQgPSBjbGFtcChjZWxsQ29vcmQsIGl2ZWMyKDApLCBpdmVjMih1X3RleHR1cmVSZXNvbHV0aW9uKSAtIGl2ZWMyKDEpKTtcbiAgICBpZiAoY2VsbENvb3JkICE9IGNsYW1wZWRDb29yZCkgcmV0dXJuIDAuMDtcbiAgICByZXR1cm4gdGV4ZWxGZXRjaCh1X3N0YXRlVGV4dHVyZSwgY2xhbXBlZENvb3JkLCAwKS5yO1xuICB9XG5cbiAgLy8gLS0tIENtZC1DbGljayBIb3Jpem9udGFsIENvbm5lY3RvciBTYW1wbGluZyAtLS1cbiAgZmxvYXQgZ2V0Q21kSG9yaXpDb25uZWN0b3IoaXZlYzIgY2VsbENvb3JkKSB7XG4gICAgLy8gVGhlIGNtZC1ob3JpeiB0ZXh0dXJlIGlzIChncmlkV2lkdGgtMSkgeCBncmlkSGVpZ2h0XG4gICAgaXZlYzIgaG9yaXpUZXh0dXJlU2l6ZSA9IGl2ZWMyKHVfZ3JpZERpbWVuc2lvbnMueCAtIDEuMCwgdV9ncmlkRGltZW5zaW9ucy55KTtcbiAgICAgLy8gQ2hlY2sgYm91bmRzIGFnYWluc3QgdGhlIGFjdHVhbCBzaXplIG9mIHRoZSBjbWRIb3JpekNvbm5lY3RvclRleHR1cmVcbiAgICBpZiAoY2VsbENvb3JkLnggPCAwIHx8IGNlbGxDb29yZC54ID49IGhvcml6VGV4dHVyZVNpemUueCB8fFxuICAgICAgICBjZWxsQ29vcmQueSA8IDAgfHwgY2VsbENvb3JkLnkgPj0gaG9yaXpUZXh0dXJlU2l6ZS55KSB7XG4gICAgICByZXR1cm4gMC4wO1xuICAgIH1cbiAgICAvLyBGZXRjaCBmcm9tIHRoZSBkZWRpY2F0ZWQgdGV4dHVyZVxuICAgIHJldHVybiB0ZXhlbEZldGNoKHVfY21kSG9yaXpDb25uZWN0b3JUZXh0dXJlLCBjZWxsQ29vcmQsIDApLnI7XG4gIH1cblxuICAvLyAtLS0gR2V0IENlbGwgQ2VudGVyIGluIFdvcmxkIFNwYWNlIC0tLVxuICB2ZWMyIGdldENlbGxXb3JsZENlbnRlcihpdmVjMiBjZWxsKSB7XG4gICAgLy8gVXNpbmcgdGhlIGZpeGVkIHNwYWNpbmcgdmFsdWUgZGlyZWN0bHkuIEVuc3VyZSB0aGlzIG1hdGNoZXMgVFMgZGVmaW5pdGlvbi5cbiAgICBmbG9hdCBmaXhlZFNwYWNpbmdWYWx1ZSA9IDAuOTsgLy8gRGlyZWN0IHZhbHVlIG9mIEJBU0VfUkFESVVTX0EgKyBCQVNFX1JBRElVU19CXG4gICAgZmxvYXQgd29ybGRYID0gZmxvYXQoY2VsbC54KSAqIGZpeGVkU3BhY2luZ1ZhbHVlICsgdV9jZW50ZXJPZmZzZXQueDtcbiAgICBmbG9hdCB3b3JsZFkgPSBmbG9hdChjZWxsLnkpICogZml4ZWRTcGFjaW5nVmFsdWUgKyB1X2NlbnRlck9mZnNldC55O1xuICAgIHJldHVybiB2ZWMyKHdvcmxkWCwgd29ybGRZKTtcbiAgfVxuXG4gIC8vIC0tLSBGdW5jdGlvbiB0byBjYWxjdWxhdGUgU0RGIGZvciBhIGdpdmVuIHJvdyAtLS1cbiAgZmxvYXQgY2FsY3VsYXRlQ29ubmVjdG9yU0RGKGl2ZWMyIGJhc2VDZWxsLCB2ZWMyIGZyYWdQb3MsIGZsb2F0IHdvcmxkUmFkQSwgZmxvYXQgd29ybGRSYWRCKSB7XG4gICAgZmxvYXQgc2RmID0gMWU2OyAvLyBEZWZhdWx0IHRvIG91dHNpZGVcblxuICAgIGZsb2F0IGNtZENvbm4gPSBnZXRDbWRIb3JpekNvbm5lY3RvcihiYXNlQ2VsbCk7XG4gICAgaWYgKGNtZENvbm4gPiAwLjApIHtcbiAgICAgICAgaXZlYzIgcmlnaHRDZWxsID0gYmFzZUNlbGwgKyBpdmVjMigxLCAwKTtcbiAgICAgICAgZmxvYXQgc3RhdGVMID0gZ2V0U3RhdGUoYmFzZUNlbGwpO1xuICAgICAgICBmbG9hdCBzdGF0ZVIgPSBnZXRTdGF0ZShyaWdodENlbGwpO1xuXG4gICAgICAgIGlmIChzdGF0ZUwgPT0gMS4wICYmIHN0YXRlUiA9PSAxLjApIHtcbiAgICAgICAgICAgIHZlYzIgY2VudGVyTCA9IGdldENlbGxXb3JsZENlbnRlcihiYXNlQ2VsbCk7XG4gICAgICAgICAgICB2ZWMyIGNlbnRlclIgPSBnZXRDZWxsV29ybGRDZW50ZXIocmlnaHRDZWxsKTtcblxuICAgICAgICAgICAgdmVjMiBjb25uQ2VudGVyID0gKGNlbnRlckwgKyBjZW50ZXJSKSAqIDAuNTtcbiAgICAgICAgICAgIC8vIFJFTU9WRUQgdmVydGljYWwgc2hpZnQ6IGNvbm5DZW50ZXIueSAtPSB3b3JsZFJhZEIgKiAwLjE1O1xuXG4gICAgICAgICAgICBmbG9hdCBjb25uV2lkdGggPSBkaXN0YW5jZShjZW50ZXJMLCBjZW50ZXJSKTtcbiAgICAgICAgICAgIC8vIFVzZSBpbm5lciByYWRpdXMgKFJhZGl1c0IpIGZvciB0aGlubmVyIGNvbm5lY3RvciBtYXRjaGluZyBjaXJjbGUgdGhpY2tuZXNzXG4gICAgICAgICAgICBmbG9hdCBjb25uSGVpZ2h0ID0gd29ybGRSYWRCICogMi4wOyAvLyBDaGFuZ2VkIGZyb20gd29ybGRSYWRBIHRvIHdvcmxkUmFkQlxuXG4gICAgICAgICAgICB2ZWMyIHAgPSBmcmFnUG9zIC0gY29ubkNlbnRlcjtcbiAgICAgICAgICAgIC8vIE5vIHJvdGF0aW9uIG5lZWRlZCBmb3IgYXhpcy1hbGlnbmVkIGhvcml6b250YWwgYm94XG4gICAgICAgICAgICAvLyBmbG9hdCBhbmdsZSA9IGF0YW4oY2VudGVyUi55IC0gY2VudGVyTC55LCBjZW50ZXJSLnggLSBjZW50ZXJMLngpO1xuICAgICAgICAgICAgLy8gZmxvYXQgYyA9IGNvcygtYW5nbGUpO1xuICAgICAgICAgICAgLy8gZmxvYXQgcyA9IHNpbigtYW5nbGUpO1xuICAgICAgICAgICAgLy8gcCA9IHZlYzIoYyAqIHAueCAtIHMgKiBwLnksIHMgKiBwLnggKyBjICogcC55KTtcblxuICAgICAgICAgICAgc2RmID0gc2RCb3gyRChwLCB2ZWMyKGNvbm5XaWR0aCAqIDAuNSwgY29ubkhlaWdodCAqIDAuNSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZGY7XG4gIH1cblxuXG4gIHZvaWQgbWFpbigpIHtcbiAgICAvLyBDYWxjdWxhdGUgZnJhZ21lbnQncyB3b3JsZCBwb3NpdGlvblxuICAgIHZlYzIgcGxhbmVPcmlnaW4gPSAtdV9wbGFuZVNpemUgKiAwLjU7XG4gICAgdmVjMiBmcmFnV29ybGRQb3MgPSBwbGFuZU9yaWdpbiArIHZVdiAqIHVfcGxhbmVTaXplO1xuXG4gICAgLy8gRGV0ZXJtaW5lIHRoZSBwb3RlbnRpYWwgYm90dG9tLWxlZnQgY2VsbCBiYXNlZCBvbiBmbG9vclxuICAgIGZsb2F0IGZpeGVkU3BhY2luZ1ZhbHVlID0gMC45O1xuICAgIHZlYzIgZ3JpZENvb3JkID0gKGZyYWdXb3JsZFBvcyAtIHVfY2VudGVyT2Zmc2V0KSAvIGZpeGVkU3BhY2luZ1ZhbHVlO1xuICAgIGl2ZWMyIGNlbGxfYmxfY3VycmVudCA9IGl2ZWMyKGZsb29yKGdyaWRDb29yZCkpOyAvLyBDZWxsIGZvciB0aGUgY3VycmVudCByb3cgZmxvb3JcblxuICAgIC8vIERlZmluZSB0aGUgY2VsbCBmb3IgdGhlIHJvdyBhYm92ZVxuICAgIGl2ZWMyIGNlbGxfYmxfYWJvdmUgPSBjZWxsX2JsX2N1cnJlbnQgKyBpdmVjMigwLCAxKTtcblxuICAgIC8vIENhbGN1bGF0ZSB3b3JsZC1zcGFjZSByYWRpaVxuICAgIGZsb2F0IHdvcmxkUmFkaXVzQSA9IHVfcmFkaXVzQSAqIHVfZ3JpZFNwYWNpbmc7XG4gICAgZmxvYXQgd29ybGRSYWRpdXNCID0gdV9yYWRpdXNCICogdV9ncmlkU3BhY2luZztcblxuICAgIC8vIENhbGN1bGF0ZSBTREYgZm9yIHRoZSBjb25uZWN0b3IgcG90ZW50aWFsbHkgaW4gdGhlIGN1cnJlbnQgcm93XG4gICAgZmxvYXQgc2RmX2N1cnJlbnQgPSBjYWxjdWxhdGVDb25uZWN0b3JTREYoY2VsbF9ibF9jdXJyZW50LCBmcmFnV29ybGRQb3MsIHdvcmxkUmFkaXVzQSwgd29ybGRSYWRpdXNCKTtcblxuICAgIC8vIENhbGN1bGF0ZSBTREYgZm9yIHRoZSBjb25uZWN0b3IgcG90ZW50aWFsbHkgaW4gdGhlIHJvdyBhYm92ZVxuICAgIGZsb2F0IHNkZl9hYm92ZSA9IGNhbGN1bGF0ZUNvbm5lY3RvclNERihjZWxsX2JsX2Fib3ZlLCBmcmFnV29ybGRQb3MsIHdvcmxkUmFkaXVzQSwgd29ybGRSYWRpdXNCKTtcblxuICAgIC8vIFRoZSBmaW5hbCBTREYgaXMgdGhlIG1pbmltdW0gb2YgdGhlIHR3byAoY2xvc2VzdCBjb25uZWN0b3Igd2lucylcbiAgICBmbG9hdCBmaW5hbFNkZiA9IG1pbihzZGZfY3VycmVudCwgc2RmX2Fib3ZlKTtcblxuICAgIC8vIEZpbmFsIE91dHB1dDogRHJhdyBpZiBpbnNpZGUgdGhlIGNvbWJpbmVkIFNERlxuICAgIGlmIChmaW5hbFNkZiA8IDAuMCkge1xuICAgICAgZmxvYXQgc21vb3RoRmFjdG9yID0gZndpZHRoKGZpbmFsU2RmKSAqIDAuODsgLy8gQW50aS1hbGlhc2luZ1xuICAgICAgZmxvYXQgYWxwaGEgPSBzbW9vdGhzdGVwKHNtb290aEZhY3RvciwgLXNtb290aEZhY3RvciwgZmluYWxTZGYpO1xuXG4gICAgICBpZiAoYWxwaGEgPiAwLjAxKSB7XG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgYWxwaGEpOyAvLyBCbGFjayBjb25uZWN0b3JcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpc2NhcmQ7IC8vIERpc2NhcmQgdHJhbnNwYXJlbnQgZnJhZ21lbnRzXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpc2NhcmQ7IC8vIERpc2NhcmQgZnJhZ21lbnRzIG91dHNpZGUgdGhlIHNoYXBlXG4gICAgfVxuICB9XG5gO1xuXG4vLyBDcmVhdGUgdGhlIHNoYWRlciBtYXRlcmlhbFxuY29uc3QgQ21kSG9yaXpDb25uZWN0b3JNYXRlcmlhbCA9IHNoYWRlck1hdGVyaWFsKFxuICB7XG4gICAgdV9zdGF0ZVRleHR1cmU6IG51bGwsICAgICAgICAgICAgIC8vIFdpbGwgYmUgcGFzc2VkIGZyb20gR3JpZFNjZW5lXG4gICAgdV9jbWRIb3JpekNvbm5lY3RvclRleHR1cmU6IG51bGwsIC8vIFdpbGwgYmUgcGFzc2VkIGZyb20gR3JpZFNjZW5lXG4gICAgdV9ncmlkRGltZW5zaW9uczogbmV3IFRIUkVFLlZlY3RvcjIoMTAsIDEwKSxcbiAgICB1X3RleHR1cmVSZXNvbHV0aW9uOiBuZXcgVEhSRUUuVmVjdG9yMigxMCwgMTApLCAvLyBTaG91bGQgbWF0Y2ggc3RhdGVUZXh0dXJlIHNpemVcbiAgICB1X3JhZGl1c0E6IEJBU0VfUkFESVVTX0EsXG4gICAgdV9yYWRpdXNCOiBCQVNFX1JBRElVU19CLFxuICAgIHVfZ3JpZFNwYWNpbmc6IDEuMCwgLy8gRGVmYXVsdCBzY2FsZVxuICAgIHVfY2VudGVyT2Zmc2V0OiBuZXcgVEhSRUUuVmVjdG9yMigwLCAwKSxcbiAgICB1X3BsYW5lU2l6ZTogbmV3IFRIUkVFLlZlY3RvcjIoMTAsIDEwKSxcbiAgfSxcbiAgdmVydGV4U2hhZGVyLFxuICBmcmFnbWVudFNoYWRlclxuKTtcblxuLy8gRXh0ZW5kIFIzRlxuZXh0ZW5kKHsgQ21kSG9yaXpDb25uZWN0b3JNYXRlcmlhbCB9KTtcblxuLy8gRGVmaW5lIFR5cGVTY3JpcHQgdHlwZSBmb3IgSlNYIHVzYWdlXG5kZWNsYXJlIGdsb2JhbCB7XG4gIG5hbWVzcGFjZSBKU1gge1xuICAgIGludGVyZmFjZSBJbnRyaW5zaWNFbGVtZW50cyB7XG4gICAgICBjbWRIb3JpekNvbm5lY3Rvck1hdGVyaWFsOiBhbnk7IC8vIFVzZSAnYW55JyBvciBkZWZpbmUgc3BlY2lmaWMgdHlwZXNcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ21kSG9yaXpDb25uZWN0b3JNYXRlcmlhbDsgIl0sIm5hbWVzIjpbIlRIUkVFIiwic2hhZGVyTWF0ZXJpYWwiLCJleHRlbmQiLCJCQVNFX1JBRElVU19BIiwiQkFTRV9SQURJVVNfQiIsIkZJWEVEX1NQQUNJTkciLCJ2ZXJ0ZXhTaGFkZXIiLCJmcmFnbWVudFNoYWRlciIsIkNtZEhvcml6Q29ubmVjdG9yTWF0ZXJpYWwiLCJ1X3N0YXRlVGV4dHVyZSIsInVfY21kSG9yaXpDb25uZWN0b3JUZXh0dXJlIiwidV9ncmlkRGltZW5zaW9ucyIsIlZlY3RvcjIiLCJ1X3RleHR1cmVSZXNvbHV0aW9uIiwidV9yYWRpdXNBIiwidV9yYWRpdXNCIiwidV9ncmlkU3BhY2luZyIsInVfY2VudGVyT2Zmc2V0IiwidV9wbGFuZVNpemUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/CmdHorizConnectorMaterial.tsx\n");

/***/ }),

/***/ "./components/ConnectorMaterial.tsx":
/*!******************************************!*\
  !*** ./components/ConnectorMaterial.tsx ***!
  \******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-three/drei */ \"@react-three/drei\");\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_react_three_drei__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-three/fiber */ \"@react-three/fiber\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__);\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([three__WEBPACK_IMPORTED_MODULE_0__]);\nthree__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n// Define constants matching GridScene for defaults\n// Moved to top to fix linter errors\nconst BASE_GRID_SPACING = 1.0;\nconst BASE_RADIUS_A = 0.5; // Outer radius relative to spacing=1\nconst BASE_RADIUS_B = 0.4; // Inner radius relative to spacing=1\n// Fixed spacing is BASE_RADIUS_A + BASE_RADIUS_B = 0.9\nconst FIXED_SPACING = BASE_RADIUS_A + BASE_RADIUS_B;\n// Define connector types as constants - must match GridScene.tsx\nconst CONNECTOR_NONE = 0;\nconst CONNECTOR_DIAG_TL_BR = 1; // Diagonal \\\nconst CONNECTOR_DIAG_BL_TR = 2; // Diagonal /\nconst CONNECTOR_HORIZ_T = 3; // Horizontal Top\nconst CONNECTOR_HORIZ_B = 4; // Horizontal Bottom\nconst CONNECTOR_HORIZ_CMD = 5; // New: Cmd-click horizontal connector\n// Vertex shader: Pass UVs\nconst vertexShader = /*glsl*/ `\n  varying vec2 vUv;\n  void main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  }\n`;\n// Fragment shader: Updated to use world space coordinates\nconst fragmentShader = /*glsl*/ `\n  uniform sampler2D u_stateTexture;\n  uniform sampler2D u_intendedConnectorTexture;\n  uniform vec2 u_gridDimensions;    // Grid size (width, height) in cells\n  uniform vec2 u_textureResolution; // Texture size (width, height) in pixels\n  uniform float u_radiusA;          // Outer radius (base value)\n  uniform float u_radiusB;          // Inner radius (base value)\n  uniform float u_gridSpacing;      // Visual scale factor\n  // World space uniforms\n  uniform vec2 u_centerOffset;      // World offset for centering grid\n  uniform vec2 u_planeSize;         // World size of connector plane\n\n  varying vec2 vUv;\n\n  // --- SDF Helper Functions ---\n  float sdCircle(vec2 p, float r) {\n    return length(p) - r;\n  }\n\n  float sdBox(vec2 p, vec2 b) {\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n  }\n\n  float sdSegment(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n  }\n\n  float sdCapsule(vec2 p, vec2 a, vec2 b, float r) {\n    return sdSegment(p, a, b) - r;\n  }\n\n  float opUnion(float d1, float d2) { return min(d1, d2); }\n  float opIntersection(float d1, float d2) { return max(d1, d2); }\n  float opSubtraction(float d1, float d2) { return max(d1, -d2); }\n\n  // --- State Sampling Helper ---\n  float getState(ivec2 cellCoord) {\n    ivec2 clampedCoord = clamp(cellCoord, ivec2(0), ivec2(u_textureResolution) - ivec2(1));\n    if (cellCoord != clampedCoord) return 0.0;\n    return texelFetch(u_stateTexture, clampedCoord, 0).r;\n  }\n\n  // --- Intended Connector Sampling ---\n  float getIntendedConnector(ivec2 cellCoord) {\n    ivec2 maxCoord = ivec2(u_textureResolution) - ivec2(1);\n    if (cellCoord.x < 0 || cellCoord.x >= maxCoord.x || \n        cellCoord.y < 0 || cellCoord.y >= maxCoord.y) {\n      return 0.0;\n    }\n    return texelFetch(u_intendedConnectorTexture, cellCoord, 0).r;\n  }\n\n  // --- Get Cell Center in World Space ---\n  vec2 getCellWorldCenter(ivec2 cell) {\n    float worldX = float(cell.x) * ${FIXED_SPACING} + u_centerOffset.x;\n    float worldY = float(cell.y) * ${FIXED_SPACING} + u_centerOffset.y;\n    return vec2(worldX, worldY);\n  }\n\n  void main() {\n    // Calculate fragment's world position\n    vec2 planeOrigin = -u_planeSize * 0.5; // Assuming plane is centered at (0,0)\n    vec2 fragWorldPos = planeOrigin + vUv * u_planeSize;\n    \n    // Determine which cell this fragment is in (find nearest cell)\n    vec2 gridCoord = (fragWorldPos - u_centerOffset) / ${FIXED_SPACING};\n    ivec2 cell_bl = ivec2(floor(gridCoord));\n    \n    // Define neighbor cells\n    ivec2 cell_br = cell_bl + ivec2(1, 0);\n    ivec2 cell_tl = cell_bl + ivec2(0, 1);\n    ivec2 cell_tr = cell_bl + ivec2(1, 1);\n\n    // Get states for all 4 cells around this fragment\n    float state_bl = getState(cell_bl);\n    float state_br = getState(cell_br);\n    float state_tl = getState(cell_tl);\n    float state_tr = getState(cell_tr);\n\n    // Get intended connector for this cell group\n    float intendedConnector = getIntendedConnector(cell_bl);\n\n    // Get cell centers in world space\n    vec2 center_bl = getCellWorldCenter(cell_bl);\n    vec2 center_br = getCellWorldCenter(cell_br);\n    vec2 center_tl = getCellWorldCenter(cell_tl);\n    vec2 center_tr = getCellWorldCenter(cell_tr);\n\n    // Calculate bounding box in world space\n    vec2 bboxCenter = (center_bl + center_br + center_tl + center_tr) * 0.25;\n    vec2 bboxHalfSize = vec2(${FIXED_SPACING} * 0.5);\n\n    // Calculate world-space radii\n    float worldRadiusA = u_radiusA * u_gridSpacing;\n    float worldRadiusB = u_radiusB * u_gridSpacing;\n\n    float finalSdf = 1e6;\n\n    // --- Diagonal \\\\ (TL to BR) Connector ---\n    if (state_tl == 1.0 && state_br == 1.0 && intendedConnector == 1.0) {\n      // Create connector path\n      float sdf_capsule_tl_br = sdCapsule(fragWorldPos, center_tl, center_br, worldRadiusB);\n      \n      // Must be outside the outer circles of TR and BL\n      float sdf_outside_tr_outer = sdCircle(fragWorldPos - center_tr, worldRadiusA);\n      float sdf_outside_bl_outer = sdCircle(fragWorldPos - center_bl, worldRadiusA);\n      \n      // Combine all constraints\n      float sdf_diag1 = sdf_capsule_tl_br;\n      sdf_diag1 = max(sdf_diag1, -sdf_outside_tr_outer);\n      sdf_diag1 = max(sdf_diag1, -sdf_outside_bl_outer);\n\n      finalSdf = min(finalSdf, sdf_diag1);\n    }\n\n    // --- Diagonal / (BL to TR) Connector ---\n    if (state_bl == 1.0 && state_tr == 1.0 && intendedConnector == 2.0) {\n      // Create connector path\n      float sdf_capsule_bl_tr = sdCapsule(fragWorldPos, center_bl, center_tr, worldRadiusB);\n      \n      // Must be outside the outer circles of TL and BR\n      float sdf_outside_tl_outer = sdCircle(fragWorldPos - center_tl, worldRadiusA);\n      float sdf_outside_br_outer = sdCircle(fragWorldPos - center_br, worldRadiusA);\n      \n      // Combine all constraints\n      float sdf_diag2 = sdf_capsule_bl_tr;\n      sdf_diag2 = max(sdf_diag2, -sdf_outside_tl_outer);\n      sdf_diag2 = max(sdf_diag2, -sdf_outside_br_outer);\n\n      finalSdf = min(finalSdf, sdf_diag2);\n    }\n\n    // --- Horizontal (BL to BR) Connector ---\n    if (state_bl == 1.0 && state_br == 1.0 && intendedConnector == 4.0) {\n      float sdf_h_bottom = sdCapsule(fragWorldPos, center_bl, center_br, worldRadiusB);\n      finalSdf = min(finalSdf, sdf_h_bottom);\n    }\n\n    // --- Horizontal (TL to TR) Connector ---\n    if (state_tl == 1.0 && state_tr == 1.0 && intendedConnector == 3.0) {\n      float sdf_h_top = sdCapsule(fragWorldPos, center_tl, center_tr, worldRadiusB);\n      finalSdf = min(finalSdf, sdf_h_top);\n    }\n\n    // --- Final Output with Anti-aliasing ---\n    if (finalSdf < 0.0) {\n      float smoothFactor = fwidth(finalSdf) * 0.8;\n      float alpha = smoothstep(smoothFactor, -smoothFactor, finalSdf);\n      \n      if (alpha > 0.01) {\n        gl_FragColor = vec4(0.0, 0.0, 0.0, alpha);\n      } else {\n        discard;\n      }\n    } else {\n      discard;\n    }\n  }\n`;\n// Create the shader material\nconst ConnectorMaterial = (0,_react_three_drei__WEBPACK_IMPORTED_MODULE_1__.shaderMaterial)({\n    u_stateTexture: null,\n    u_intendedConnectorTexture: null,\n    u_gridDimensions: new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(10, 10),\n    u_textureResolution: new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(10, 10),\n    u_radiusA: BASE_RADIUS_A,\n    u_radiusB: BASE_RADIUS_B,\n    u_gridSpacing: BASE_GRID_SPACING,\n    // World space uniforms\n    u_centerOffset: new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(0, 0),\n    u_planeSize: new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(10, 10)\n}, vertexShader, fragmentShader);\n// Extend R3F\n(0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.extend)({\n    ConnectorMaterial\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ConnectorMaterial); // Define constants matching GridScene for defaults (optional, but helps IDE)\n // Moved to top - Removing these commented out versions\n // const BASE_GRID_SPACING = 1.0;\n // const BASE_RADIUS_A = 0.5;\n // const BASE_RADIUS_B = 0.4; \n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL0Nvbm5lY3Rvck1hdGVyaWFsLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBK0I7QUFDb0I7QUFDUDtBQUU1QyxtREFBbUQ7QUFDbkQsb0NBQW9DO0FBQ3BDLE1BQU1HLG9CQUFvQjtBQUMxQixNQUFNQyxnQkFBZ0IsS0FBSyxxQ0FBcUM7QUFDaEUsTUFBTUMsZ0JBQWdCLEtBQUsscUNBQXFDO0FBQ2hFLHVEQUF1RDtBQUN2RCxNQUFNQyxnQkFBZ0JGLGdCQUFnQkM7QUFFdEMsaUVBQWlFO0FBQ2pFLE1BQU1FLGlCQUFpQjtBQUN2QixNQUFNQyx1QkFBdUIsR0FBRyxhQUFhO0FBQzdDLE1BQU1DLHVCQUF1QixHQUFHLGFBQWE7QUFDN0MsTUFBTUMsb0JBQW9CLEdBQU0saUJBQWlCO0FBQ2pELE1BQU1DLG9CQUFvQixHQUFNLG9CQUFvQjtBQUNwRCxNQUFNQyxzQkFBc0IsR0FBSSxzQ0FBc0M7QUFFdEUsMEJBQTBCO0FBQzFCLE1BQU1DLGVBQWUsTUFBTSxHQUFHLENBQUM7Ozs7OztBQU0vQixDQUFDO0FBRUQsMERBQTBEO0FBQzFELE1BQU1DLGlCQUFpQixNQUFNLEdBQUcsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O21DQXlERSxFQUFFUixjQUFjO21DQUNoQixFQUFFQSxjQUFjOzs7Ozs7Ozs7O3VEQVVJLEVBQUVBLGNBQWM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7NkJBeUIxQyxFQUFFQSxjQUFjOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9FN0MsQ0FBQztBQUVELDZCQUE2QjtBQUM3QixNQUFNUyxvQkFBb0JkLGlFQUFjQSxDQUN0QztJQUNFZSxnQkFBZ0I7SUFDaEJDLDRCQUE0QjtJQUM1QkMsa0JBQWtCLElBQUlsQiwwQ0FBYSxDQUFDLElBQUk7SUFDeENvQixxQkFBcUIsSUFBSXBCLDBDQUFhLENBQUMsSUFBSTtJQUMzQ3FCLFdBQVdqQjtJQUNYa0IsV0FBV2pCO0lBQ1hrQixlQUFlcEI7SUFDZix1QkFBdUI7SUFDdkJxQixnQkFBZ0IsSUFBSXhCLDBDQUFhLENBQUMsR0FBRztJQUNyQ3lCLGFBQWEsSUFBSXpCLDBDQUFhLENBQUMsSUFBSTtBQUNyQyxHQUNBYSxjQUNBQztBQUdGLGFBQWE7QUFDYlosMERBQU1BLENBQUM7SUFBRWE7QUFBa0I7QUFXM0IsaUVBQWVBLGlCQUFpQkEsRUFBQyxDQUNqQyw2RUFBNkU7Q0FDN0UsdURBQXVEO0NBQ3ZELGlDQUFpQztDQUNqQyw2QkFBNkI7Q0FDN0IsOEJBQThCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViZ2wtZG90LWdyaWQtbXZwLy4vY29tcG9uZW50cy9Db25uZWN0b3JNYXRlcmlhbC50c3g/NjI1MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyBzaGFkZXJNYXRlcmlhbCB9IGZyb20gJ0ByZWFjdC10aHJlZS9kcmVpJztcbmltcG9ydCB7IGV4dGVuZCB9IGZyb20gJ0ByZWFjdC10aHJlZS9maWJlcic7XG5cbi8vIERlZmluZSBjb25zdGFudHMgbWF0Y2hpbmcgR3JpZFNjZW5lIGZvciBkZWZhdWx0c1xuLy8gTW92ZWQgdG8gdG9wIHRvIGZpeCBsaW50ZXIgZXJyb3JzXG5jb25zdCBCQVNFX0dSSURfU1BBQ0lORyA9IDEuMDtcbmNvbnN0IEJBU0VfUkFESVVTX0EgPSAwLjU7IC8vIE91dGVyIHJhZGl1cyByZWxhdGl2ZSB0byBzcGFjaW5nPTFcbmNvbnN0IEJBU0VfUkFESVVTX0IgPSAwLjQ7IC8vIElubmVyIHJhZGl1cyByZWxhdGl2ZSB0byBzcGFjaW5nPTFcbi8vIEZpeGVkIHNwYWNpbmcgaXMgQkFTRV9SQURJVVNfQSArIEJBU0VfUkFESVVTX0IgPSAwLjlcbmNvbnN0IEZJWEVEX1NQQUNJTkcgPSBCQVNFX1JBRElVU19BICsgQkFTRV9SQURJVVNfQjtcblxuLy8gRGVmaW5lIGNvbm5lY3RvciB0eXBlcyBhcyBjb25zdGFudHMgLSBtdXN0IG1hdGNoIEdyaWRTY2VuZS50c3hcbmNvbnN0IENPTk5FQ1RPUl9OT05FID0gMDtcbmNvbnN0IENPTk5FQ1RPUl9ESUFHX1RMX0JSID0gMTsgLy8gRGlhZ29uYWwgXFxcbmNvbnN0IENPTk5FQ1RPUl9ESUFHX0JMX1RSID0gMjsgLy8gRGlhZ29uYWwgL1xuY29uc3QgQ09OTkVDVE9SX0hPUklaX1QgPSAzOyAgICAvLyBIb3Jpem9udGFsIFRvcFxuY29uc3QgQ09OTkVDVE9SX0hPUklaX0IgPSA0OyAgICAvLyBIb3Jpem9udGFsIEJvdHRvbVxuY29uc3QgQ09OTkVDVE9SX0hPUklaX0NNRCA9IDU7ICAvLyBOZXc6IENtZC1jbGljayBob3Jpem9udGFsIGNvbm5lY3RvclxuXG4vLyBWZXJ0ZXggc2hhZGVyOiBQYXNzIFVWc1xuY29uc3QgdmVydGV4U2hhZGVyID0gLypnbHNsKi8gYFxuICB2YXJ5aW5nIHZlYzIgdlV2O1xuICB2b2lkIG1haW4oKSB7XG4gICAgdlV2ID0gdXY7XG4gICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTtcbiAgfVxuYDtcblxuLy8gRnJhZ21lbnQgc2hhZGVyOiBVcGRhdGVkIHRvIHVzZSB3b3JsZCBzcGFjZSBjb29yZGluYXRlc1xuY29uc3QgZnJhZ21lbnRTaGFkZXIgPSAvKmdsc2wqLyBgXG4gIHVuaWZvcm0gc2FtcGxlcjJEIHVfc3RhdGVUZXh0dXJlO1xuICB1bmlmb3JtIHNhbXBsZXIyRCB1X2ludGVuZGVkQ29ubmVjdG9yVGV4dHVyZTtcbiAgdW5pZm9ybSB2ZWMyIHVfZ3JpZERpbWVuc2lvbnM7ICAgIC8vIEdyaWQgc2l6ZSAod2lkdGgsIGhlaWdodCkgaW4gY2VsbHNcbiAgdW5pZm9ybSB2ZWMyIHVfdGV4dHVyZVJlc29sdXRpb247IC8vIFRleHR1cmUgc2l6ZSAod2lkdGgsIGhlaWdodCkgaW4gcGl4ZWxzXG4gIHVuaWZvcm0gZmxvYXQgdV9yYWRpdXNBOyAgICAgICAgICAvLyBPdXRlciByYWRpdXMgKGJhc2UgdmFsdWUpXG4gIHVuaWZvcm0gZmxvYXQgdV9yYWRpdXNCOyAgICAgICAgICAvLyBJbm5lciByYWRpdXMgKGJhc2UgdmFsdWUpXG4gIHVuaWZvcm0gZmxvYXQgdV9ncmlkU3BhY2luZzsgICAgICAvLyBWaXN1YWwgc2NhbGUgZmFjdG9yXG4gIC8vIFdvcmxkIHNwYWNlIHVuaWZvcm1zXG4gIHVuaWZvcm0gdmVjMiB1X2NlbnRlck9mZnNldDsgICAgICAvLyBXb3JsZCBvZmZzZXQgZm9yIGNlbnRlcmluZyBncmlkXG4gIHVuaWZvcm0gdmVjMiB1X3BsYW5lU2l6ZTsgICAgICAgICAvLyBXb3JsZCBzaXplIG9mIGNvbm5lY3RvciBwbGFuZVxuXG4gIHZhcnlpbmcgdmVjMiB2VXY7XG5cbiAgLy8gLS0tIFNERiBIZWxwZXIgRnVuY3Rpb25zIC0tLVxuICBmbG9hdCBzZENpcmNsZSh2ZWMyIHAsIGZsb2F0IHIpIHtcbiAgICByZXR1cm4gbGVuZ3RoKHApIC0gcjtcbiAgfVxuXG4gIGZsb2F0IHNkQm94KHZlYzIgcCwgdmVjMiBiKSB7XG4gICAgdmVjMiBkID0gYWJzKHApIC0gYjtcbiAgICByZXR1cm4gbGVuZ3RoKG1heChkLCAwLjApKSArIG1pbihtYXgoZC54LCBkLnkpLCAwLjApO1xuICB9XG5cbiAgZmxvYXQgc2RTZWdtZW50KHZlYzIgcCwgdmVjMiBhLCB2ZWMyIGIpIHtcbiAgICB2ZWMyIHBhID0gcCAtIGEsIGJhID0gYiAtIGE7XG4gICAgZmxvYXQgaCA9IGNsYW1wKGRvdChwYSwgYmEpIC8gZG90KGJhLCBiYSksIDAuMCwgMS4wKTtcbiAgICByZXR1cm4gbGVuZ3RoKHBhIC0gYmEgKiBoKTtcbiAgfVxuXG4gIGZsb2F0IHNkQ2Fwc3VsZSh2ZWMyIHAsIHZlYzIgYSwgdmVjMiBiLCBmbG9hdCByKSB7XG4gICAgcmV0dXJuIHNkU2VnbWVudChwLCBhLCBiKSAtIHI7XG4gIH1cblxuICBmbG9hdCBvcFVuaW9uKGZsb2F0IGQxLCBmbG9hdCBkMikgeyByZXR1cm4gbWluKGQxLCBkMik7IH1cbiAgZmxvYXQgb3BJbnRlcnNlY3Rpb24oZmxvYXQgZDEsIGZsb2F0IGQyKSB7IHJldHVybiBtYXgoZDEsIGQyKTsgfVxuICBmbG9hdCBvcFN1YnRyYWN0aW9uKGZsb2F0IGQxLCBmbG9hdCBkMikgeyByZXR1cm4gbWF4KGQxLCAtZDIpOyB9XG5cbiAgLy8gLS0tIFN0YXRlIFNhbXBsaW5nIEhlbHBlciAtLS1cbiAgZmxvYXQgZ2V0U3RhdGUoaXZlYzIgY2VsbENvb3JkKSB7XG4gICAgaXZlYzIgY2xhbXBlZENvb3JkID0gY2xhbXAoY2VsbENvb3JkLCBpdmVjMigwKSwgaXZlYzIodV90ZXh0dXJlUmVzb2x1dGlvbikgLSBpdmVjMigxKSk7XG4gICAgaWYgKGNlbGxDb29yZCAhPSBjbGFtcGVkQ29vcmQpIHJldHVybiAwLjA7XG4gICAgcmV0dXJuIHRleGVsRmV0Y2godV9zdGF0ZVRleHR1cmUsIGNsYW1wZWRDb29yZCwgMCkucjtcbiAgfVxuXG4gIC8vIC0tLSBJbnRlbmRlZCBDb25uZWN0b3IgU2FtcGxpbmcgLS0tXG4gIGZsb2F0IGdldEludGVuZGVkQ29ubmVjdG9yKGl2ZWMyIGNlbGxDb29yZCkge1xuICAgIGl2ZWMyIG1heENvb3JkID0gaXZlYzIodV90ZXh0dXJlUmVzb2x1dGlvbikgLSBpdmVjMigxKTtcbiAgICBpZiAoY2VsbENvb3JkLnggPCAwIHx8IGNlbGxDb29yZC54ID49IG1heENvb3JkLnggfHwgXG4gICAgICAgIGNlbGxDb29yZC55IDwgMCB8fCBjZWxsQ29vcmQueSA+PSBtYXhDb29yZC55KSB7XG4gICAgICByZXR1cm4gMC4wO1xuICAgIH1cbiAgICByZXR1cm4gdGV4ZWxGZXRjaCh1X2ludGVuZGVkQ29ubmVjdG9yVGV4dHVyZSwgY2VsbENvb3JkLCAwKS5yO1xuICB9XG5cbiAgLy8gLS0tIEdldCBDZWxsIENlbnRlciBpbiBXb3JsZCBTcGFjZSAtLS1cbiAgdmVjMiBnZXRDZWxsV29ybGRDZW50ZXIoaXZlYzIgY2VsbCkge1xuICAgIGZsb2F0IHdvcmxkWCA9IGZsb2F0KGNlbGwueCkgKiAke0ZJWEVEX1NQQUNJTkd9ICsgdV9jZW50ZXJPZmZzZXQueDtcbiAgICBmbG9hdCB3b3JsZFkgPSBmbG9hdChjZWxsLnkpICogJHtGSVhFRF9TUEFDSU5HfSArIHVfY2VudGVyT2Zmc2V0Lnk7XG4gICAgcmV0dXJuIHZlYzIod29ybGRYLCB3b3JsZFkpO1xuICB9XG5cbiAgdm9pZCBtYWluKCkge1xuICAgIC8vIENhbGN1bGF0ZSBmcmFnbWVudCdzIHdvcmxkIHBvc2l0aW9uXG4gICAgdmVjMiBwbGFuZU9yaWdpbiA9IC11X3BsYW5lU2l6ZSAqIDAuNTsgLy8gQXNzdW1pbmcgcGxhbmUgaXMgY2VudGVyZWQgYXQgKDAsMClcbiAgICB2ZWMyIGZyYWdXb3JsZFBvcyA9IHBsYW5lT3JpZ2luICsgdlV2ICogdV9wbGFuZVNpemU7XG4gICAgXG4gICAgLy8gRGV0ZXJtaW5lIHdoaWNoIGNlbGwgdGhpcyBmcmFnbWVudCBpcyBpbiAoZmluZCBuZWFyZXN0IGNlbGwpXG4gICAgdmVjMiBncmlkQ29vcmQgPSAoZnJhZ1dvcmxkUG9zIC0gdV9jZW50ZXJPZmZzZXQpIC8gJHtGSVhFRF9TUEFDSU5HfTtcbiAgICBpdmVjMiBjZWxsX2JsID0gaXZlYzIoZmxvb3IoZ3JpZENvb3JkKSk7XG4gICAgXG4gICAgLy8gRGVmaW5lIG5laWdoYm9yIGNlbGxzXG4gICAgaXZlYzIgY2VsbF9iciA9IGNlbGxfYmwgKyBpdmVjMigxLCAwKTtcbiAgICBpdmVjMiBjZWxsX3RsID0gY2VsbF9ibCArIGl2ZWMyKDAsIDEpO1xuICAgIGl2ZWMyIGNlbGxfdHIgPSBjZWxsX2JsICsgaXZlYzIoMSwgMSk7XG5cbiAgICAvLyBHZXQgc3RhdGVzIGZvciBhbGwgNCBjZWxscyBhcm91bmQgdGhpcyBmcmFnbWVudFxuICAgIGZsb2F0IHN0YXRlX2JsID0gZ2V0U3RhdGUoY2VsbF9ibCk7XG4gICAgZmxvYXQgc3RhdGVfYnIgPSBnZXRTdGF0ZShjZWxsX2JyKTtcbiAgICBmbG9hdCBzdGF0ZV90bCA9IGdldFN0YXRlKGNlbGxfdGwpO1xuICAgIGZsb2F0IHN0YXRlX3RyID0gZ2V0U3RhdGUoY2VsbF90cik7XG5cbiAgICAvLyBHZXQgaW50ZW5kZWQgY29ubmVjdG9yIGZvciB0aGlzIGNlbGwgZ3JvdXBcbiAgICBmbG9hdCBpbnRlbmRlZENvbm5lY3RvciA9IGdldEludGVuZGVkQ29ubmVjdG9yKGNlbGxfYmwpO1xuXG4gICAgLy8gR2V0IGNlbGwgY2VudGVycyBpbiB3b3JsZCBzcGFjZVxuICAgIHZlYzIgY2VudGVyX2JsID0gZ2V0Q2VsbFdvcmxkQ2VudGVyKGNlbGxfYmwpO1xuICAgIHZlYzIgY2VudGVyX2JyID0gZ2V0Q2VsbFdvcmxkQ2VudGVyKGNlbGxfYnIpO1xuICAgIHZlYzIgY2VudGVyX3RsID0gZ2V0Q2VsbFdvcmxkQ2VudGVyKGNlbGxfdGwpO1xuICAgIHZlYzIgY2VudGVyX3RyID0gZ2V0Q2VsbFdvcmxkQ2VudGVyKGNlbGxfdHIpO1xuXG4gICAgLy8gQ2FsY3VsYXRlIGJvdW5kaW5nIGJveCBpbiB3b3JsZCBzcGFjZVxuICAgIHZlYzIgYmJveENlbnRlciA9IChjZW50ZXJfYmwgKyBjZW50ZXJfYnIgKyBjZW50ZXJfdGwgKyBjZW50ZXJfdHIpICogMC4yNTtcbiAgICB2ZWMyIGJib3hIYWxmU2l6ZSA9IHZlYzIoJHtGSVhFRF9TUEFDSU5HfSAqIDAuNSk7XG5cbiAgICAvLyBDYWxjdWxhdGUgd29ybGQtc3BhY2UgcmFkaWlcbiAgICBmbG9hdCB3b3JsZFJhZGl1c0EgPSB1X3JhZGl1c0EgKiB1X2dyaWRTcGFjaW5nO1xuICAgIGZsb2F0IHdvcmxkUmFkaXVzQiA9IHVfcmFkaXVzQiAqIHVfZ3JpZFNwYWNpbmc7XG5cbiAgICBmbG9hdCBmaW5hbFNkZiA9IDFlNjtcblxuICAgIC8vIC0tLSBEaWFnb25hbCBcXFxcIChUTCB0byBCUikgQ29ubmVjdG9yIC0tLVxuICAgIGlmIChzdGF0ZV90bCA9PSAxLjAgJiYgc3RhdGVfYnIgPT0gMS4wICYmIGludGVuZGVkQ29ubmVjdG9yID09IDEuMCkge1xuICAgICAgLy8gQ3JlYXRlIGNvbm5lY3RvciBwYXRoXG4gICAgICBmbG9hdCBzZGZfY2Fwc3VsZV90bF9iciA9IHNkQ2Fwc3VsZShmcmFnV29ybGRQb3MsIGNlbnRlcl90bCwgY2VudGVyX2JyLCB3b3JsZFJhZGl1c0IpO1xuICAgICAgXG4gICAgICAvLyBNdXN0IGJlIG91dHNpZGUgdGhlIG91dGVyIGNpcmNsZXMgb2YgVFIgYW5kIEJMXG4gICAgICBmbG9hdCBzZGZfb3V0c2lkZV90cl9vdXRlciA9IHNkQ2lyY2xlKGZyYWdXb3JsZFBvcyAtIGNlbnRlcl90ciwgd29ybGRSYWRpdXNBKTtcbiAgICAgIGZsb2F0IHNkZl9vdXRzaWRlX2JsX291dGVyID0gc2RDaXJjbGUoZnJhZ1dvcmxkUG9zIC0gY2VudGVyX2JsLCB3b3JsZFJhZGl1c0EpO1xuICAgICAgXG4gICAgICAvLyBDb21iaW5lIGFsbCBjb25zdHJhaW50c1xuICAgICAgZmxvYXQgc2RmX2RpYWcxID0gc2RmX2NhcHN1bGVfdGxfYnI7XG4gICAgICBzZGZfZGlhZzEgPSBtYXgoc2RmX2RpYWcxLCAtc2RmX291dHNpZGVfdHJfb3V0ZXIpO1xuICAgICAgc2RmX2RpYWcxID0gbWF4KHNkZl9kaWFnMSwgLXNkZl9vdXRzaWRlX2JsX291dGVyKTtcblxuICAgICAgZmluYWxTZGYgPSBtaW4oZmluYWxTZGYsIHNkZl9kaWFnMSk7XG4gICAgfVxuXG4gICAgLy8gLS0tIERpYWdvbmFsIC8gKEJMIHRvIFRSKSBDb25uZWN0b3IgLS0tXG4gICAgaWYgKHN0YXRlX2JsID09IDEuMCAmJiBzdGF0ZV90ciA9PSAxLjAgJiYgaW50ZW5kZWRDb25uZWN0b3IgPT0gMi4wKSB7XG4gICAgICAvLyBDcmVhdGUgY29ubmVjdG9yIHBhdGhcbiAgICAgIGZsb2F0IHNkZl9jYXBzdWxlX2JsX3RyID0gc2RDYXBzdWxlKGZyYWdXb3JsZFBvcywgY2VudGVyX2JsLCBjZW50ZXJfdHIsIHdvcmxkUmFkaXVzQik7XG4gICAgICBcbiAgICAgIC8vIE11c3QgYmUgb3V0c2lkZSB0aGUgb3V0ZXIgY2lyY2xlcyBvZiBUTCBhbmQgQlJcbiAgICAgIGZsb2F0IHNkZl9vdXRzaWRlX3RsX291dGVyID0gc2RDaXJjbGUoZnJhZ1dvcmxkUG9zIC0gY2VudGVyX3RsLCB3b3JsZFJhZGl1c0EpO1xuICAgICAgZmxvYXQgc2RmX291dHNpZGVfYnJfb3V0ZXIgPSBzZENpcmNsZShmcmFnV29ybGRQb3MgLSBjZW50ZXJfYnIsIHdvcmxkUmFkaXVzQSk7XG4gICAgICBcbiAgICAgIC8vIENvbWJpbmUgYWxsIGNvbnN0cmFpbnRzXG4gICAgICBmbG9hdCBzZGZfZGlhZzIgPSBzZGZfY2Fwc3VsZV9ibF90cjtcbiAgICAgIHNkZl9kaWFnMiA9IG1heChzZGZfZGlhZzIsIC1zZGZfb3V0c2lkZV90bF9vdXRlcik7XG4gICAgICBzZGZfZGlhZzIgPSBtYXgoc2RmX2RpYWcyLCAtc2RmX291dHNpZGVfYnJfb3V0ZXIpO1xuXG4gICAgICBmaW5hbFNkZiA9IG1pbihmaW5hbFNkZiwgc2RmX2RpYWcyKTtcbiAgICB9XG5cbiAgICAvLyAtLS0gSG9yaXpvbnRhbCAoQkwgdG8gQlIpIENvbm5lY3RvciAtLS1cbiAgICBpZiAoc3RhdGVfYmwgPT0gMS4wICYmIHN0YXRlX2JyID09IDEuMCAmJiBpbnRlbmRlZENvbm5lY3RvciA9PSA0LjApIHtcbiAgICAgIGZsb2F0IHNkZl9oX2JvdHRvbSA9IHNkQ2Fwc3VsZShmcmFnV29ybGRQb3MsIGNlbnRlcl9ibCwgY2VudGVyX2JyLCB3b3JsZFJhZGl1c0IpO1xuICAgICAgZmluYWxTZGYgPSBtaW4oZmluYWxTZGYsIHNkZl9oX2JvdHRvbSk7XG4gICAgfVxuXG4gICAgLy8gLS0tIEhvcml6b250YWwgKFRMIHRvIFRSKSBDb25uZWN0b3IgLS0tXG4gICAgaWYgKHN0YXRlX3RsID09IDEuMCAmJiBzdGF0ZV90ciA9PSAxLjAgJiYgaW50ZW5kZWRDb25uZWN0b3IgPT0gMy4wKSB7XG4gICAgICBmbG9hdCBzZGZfaF90b3AgPSBzZENhcHN1bGUoZnJhZ1dvcmxkUG9zLCBjZW50ZXJfdGwsIGNlbnRlcl90ciwgd29ybGRSYWRpdXNCKTtcbiAgICAgIGZpbmFsU2RmID0gbWluKGZpbmFsU2RmLCBzZGZfaF90b3ApO1xuICAgIH1cblxuICAgIC8vIC0tLSBGaW5hbCBPdXRwdXQgd2l0aCBBbnRpLWFsaWFzaW5nIC0tLVxuICAgIGlmIChmaW5hbFNkZiA8IDAuMCkge1xuICAgICAgZmxvYXQgc21vb3RoRmFjdG9yID0gZndpZHRoKGZpbmFsU2RmKSAqIDAuODtcbiAgICAgIGZsb2F0IGFscGhhID0gc21vb3Roc3RlcChzbW9vdGhGYWN0b3IsIC1zbW9vdGhGYWN0b3IsIGZpbmFsU2RmKTtcbiAgICAgIFxuICAgICAgaWYgKGFscGhhID4gMC4wMSkge1xuICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIGFscGhhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpc2NhcmQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpc2NhcmQ7XG4gICAgfVxuICB9XG5gO1xuXG4vLyBDcmVhdGUgdGhlIHNoYWRlciBtYXRlcmlhbFxuY29uc3QgQ29ubmVjdG9yTWF0ZXJpYWwgPSBzaGFkZXJNYXRlcmlhbChcbiAge1xuICAgIHVfc3RhdGVUZXh0dXJlOiBudWxsLCBcbiAgICB1X2ludGVuZGVkQ29ubmVjdG9yVGV4dHVyZTogbnVsbCxcbiAgICB1X2dyaWREaW1lbnNpb25zOiBuZXcgVEhSRUUuVmVjdG9yMigxMCwgMTApLFxuICAgIHVfdGV4dHVyZVJlc29sdXRpb246IG5ldyBUSFJFRS5WZWN0b3IyKDEwLCAxMCksXG4gICAgdV9yYWRpdXNBOiBCQVNFX1JBRElVU19BLFxuICAgIHVfcmFkaXVzQjogQkFTRV9SQURJVVNfQixcbiAgICB1X2dyaWRTcGFjaW5nOiBCQVNFX0dSSURfU1BBQ0lORyxcbiAgICAvLyBXb3JsZCBzcGFjZSB1bmlmb3Jtc1xuICAgIHVfY2VudGVyT2Zmc2V0OiBuZXcgVEhSRUUuVmVjdG9yMigwLCAwKSxcbiAgICB1X3BsYW5lU2l6ZTogbmV3IFRIUkVFLlZlY3RvcjIoMTAsIDEwKSxcbiAgfSxcbiAgdmVydGV4U2hhZGVyLFxuICBmcmFnbWVudFNoYWRlclxuKTtcblxuLy8gRXh0ZW5kIFIzRlxuZXh0ZW5kKHsgQ29ubmVjdG9yTWF0ZXJpYWwgfSk7XG5cbi8vIERlZmluZSBUeXBlU2NyaXB0IHR5cGUgZm9yIEpTWCB1c2FnZVxuZGVjbGFyZSBnbG9iYWwge1xuICBuYW1lc3BhY2UgSlNYIHtcbiAgICBpbnRlcmZhY2UgSW50cmluc2ljRWxlbWVudHMge1xuICAgICAgY29ubmVjdG9yTWF0ZXJpYWw6IGFueTsgXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvbm5lY3Rvck1hdGVyaWFsO1xuLy8gRGVmaW5lIGNvbnN0YW50cyBtYXRjaGluZyBHcmlkU2NlbmUgZm9yIGRlZmF1bHRzIChvcHRpb25hbCwgYnV0IGhlbHBzIElERSlcbi8vIE1vdmVkIHRvIHRvcCAtIFJlbW92aW5nIHRoZXNlIGNvbW1lbnRlZCBvdXQgdmVyc2lvbnNcbi8vIGNvbnN0IEJBU0VfR1JJRF9TUEFDSU5HID0gMS4wO1xuLy8gY29uc3QgQkFTRV9SQURJVVNfQSA9IDAuNTtcbi8vIGNvbnN0IEJBU0VfUkFESVVTX0IgPSAwLjQ7IFxuIl0sIm5hbWVzIjpbIlRIUkVFIiwic2hhZGVyTWF0ZXJpYWwiLCJleHRlbmQiLCJCQVNFX0dSSURfU1BBQ0lORyIsIkJBU0VfUkFESVVTX0EiLCJCQVNFX1JBRElVU19CIiwiRklYRURfU1BBQ0lORyIsIkNPTk5FQ1RPUl9OT05FIiwiQ09OTkVDVE9SX0RJQUdfVExfQlIiLCJDT05ORUNUT1JfRElBR19CTF9UUiIsIkNPTk5FQ1RPUl9IT1JJWl9UIiwiQ09OTkVDVE9SX0hPUklaX0IiLCJDT05ORUNUT1JfSE9SSVpfQ01EIiwidmVydGV4U2hhZGVyIiwiZnJhZ21lbnRTaGFkZXIiLCJDb25uZWN0b3JNYXRlcmlhbCIsInVfc3RhdGVUZXh0dXJlIiwidV9pbnRlbmRlZENvbm5lY3RvclRleHR1cmUiLCJ1X2dyaWREaW1lbnNpb25zIiwiVmVjdG9yMiIsInVfdGV4dHVyZVJlc29sdXRpb24iLCJ1X3JhZGl1c0EiLCJ1X3JhZGl1c0IiLCJ1X2dyaWRTcGFjaW5nIiwidV9jZW50ZXJPZmZzZXQiLCJ1X3BsYW5lU2l6ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./components/ConnectorMaterial.tsx\n");

/***/ }),

/***/ "./components/GridScene.tsx":
/*!**********************************!*\
  !*** ./components/GridScene.tsx ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var leva__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! leva */ \"leva\");\n/* harmony import */ var leva__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(leva__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _CircleMaterial__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./CircleMaterial */ \"./components/CircleMaterial.tsx\");\n/* harmony import */ var _ConnectorMaterial__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ConnectorMaterial */ \"./components/ConnectorMaterial.tsx\");\n/* harmony import */ var _CmdHorizConnectorMaterial__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./CmdHorizConnectorMaterial */ \"./components/CmdHorizConnectorMaterial.tsx\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([three__WEBPACK_IMPORTED_MODULE_2__, _CircleMaterial__WEBPACK_IMPORTED_MODULE_4__, _ConnectorMaterial__WEBPACK_IMPORTED_MODULE_5__, _CmdHorizConnectorMaterial__WEBPACK_IMPORTED_MODULE_6__]);\n([three__WEBPACK_IMPORTED_MODULE_2__, _CircleMaterial__WEBPACK_IMPORTED_MODULE_4__, _ConnectorMaterial__WEBPACK_IMPORTED_MODULE_5__, _CmdHorizConnectorMaterial__WEBPACK_IMPORTED_MODULE_6__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n\n\n\n// === Feature 1: Grid Data & Configuration ===\n// Constants for base geometry\nconst BASE_GRID_SPACING = 1.0; // Keep for reference if needed, but spacing is now fixed\nconst BASE_RADIUS_A = 0.5; // Outer radius\nconst BASE_RADIUS_B = 0.4; // Inner radius\n// Calculate the fixed spacing based on desired overlap\nconst FIXED_SPACING = BASE_RADIUS_A + BASE_RADIUS_B; // 0.5 + 0.4 = 0.9\n// Helper Functions\nconst getIndex = (row, col, gridWidth)=>{\n    return row * gridWidth + col;\n};\nconst getCoords = (index, gridWidth)=>{\n    const row = Math.floor(index / gridWidth);\n    const col = index % gridWidth;\n    return {\n        row,\n        col\n    };\n};\n// Modified to use fixed spacing\nconst getCenterOffset = (gridWidth, gridHeight, spacing)=>{\n    const totalWidth = (gridWidth - 1) * spacing;\n    const totalHeight = (gridHeight - 1) * spacing;\n    return new three__WEBPACK_IMPORTED_MODULE_2__.Vector2(-totalWidth / 2, -totalHeight / 2);\n};\n// Modified to use fixed spacing\nconst getWorldPosition = (row, col, gridWidth, gridHeight, spacing, centerOffset)=>{\n    const x = col * spacing + centerOffset.x;\n    const y = row * spacing + centerOffset.y;\n    return {\n        x,\n        y\n    };\n};\n// Define connector types as constants\nconst CONNECTOR_NONE = 0;\nconst CONNECTOR_DIAG_TL_BR = 1; // Diagonal \\\nconst CONNECTOR_DIAG_BL_TR = 2; // Diagonal /\nconst CONNECTOR_HORIZ_T = 3; // Horizontal Top\nconst CONNECTOR_HORIZ_B = 4; // Horizontal Bottom\nconst CONNECTOR_HORIZ_CMD = 5; // New: Cmd-click horizontal connector\n// === GridScene Component ===\n// Dummy object for matrix calculations\nconst dummy = new three__WEBPACK_IMPORTED_MODULE_2__.Object3D();\nconst tempMatrix = new three__WEBPACK_IMPORTED_MODULE_2__.Matrix4();\nconst tempVec = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n// New: Helper for horizontal cmd-click connector key generation\nconst getHorizCmdConnectorKey = (x, y)=>`hcmd:${x},${y}`;\nconst GridScene = ()=>{\n    // Leva controls for grid parameters\n    const { GRID_WIDTH, GRID_HEIGHT, visualScale } = (0,leva__WEBPACK_IMPORTED_MODULE_3__.useControls)(\"Grid\", {\n        GRID_WIDTH: {\n            value: 10,\n            min: 2,\n            max: 100,\n            step: 1\n        },\n        GRID_HEIGHT: {\n            value: 10,\n            min: 2,\n            max: 100,\n            step: 1\n        },\n        visualScale: {\n            value: 1.0,\n            min: 0.1,\n            max: 5,\n            step: 0.1,\n            label: \"Visual Scale\" // Updated label\n        }\n    });\n    // Derived values calculation using useMemo for optimization\n    const { TOTAL_CIRCLES, centerOffset, planeWidth, planeHeight// Based on FIXED_SPACING\n     } = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        const total = GRID_WIDTH * GRID_HEIGHT;\n        // Offset and plane dimensions depend on the fixed spacing between centers\n        const offset = getCenterOffset(GRID_WIDTH, GRID_HEIGHT, FIXED_SPACING);\n        // Calculate actual grid extent based on fixed spacing\n        const width = (GRID_WIDTH > 1 ? (GRID_WIDTH - 1) * FIXED_SPACING : 0) + visualScale * BASE_RADIUS_A * 2; // Add diameter margin\n        const height = (GRID_HEIGHT > 1 ? (GRID_HEIGHT - 1) * FIXED_SPACING : 0) + visualScale * BASE_RADIUS_A * 2; // Add diameter margin\n        console.log(`Layout Spacing: ${FIXED_SPACING.toFixed(2)}`);\n        console.log(`Calculated Center Offset: x=${offset.x.toFixed(2)}, y=${offset.y.toFixed(2)}`);\n        console.log(`Calculated Plane Size: w=${width.toFixed(2)}, h=${height.toFixed(2)}`);\n        return {\n            TOTAL_CIRCLES: total,\n            centerOffset: offset,\n            planeWidth: width,\n            planeHeight: height\n        };\n    }, [\n        GRID_WIDTH,\n        GRID_HEIGHT,\n        visualScale\n    ]); // Depend on grid size and visual scale for plane margin\n    // Refs for mesh and material\n    const meshRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const materialRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null); // Use 'any' or specific type for CircleMaterial\n    const activationAttributeRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const connectorMaterialRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null); // Ref for connector material\n    // === Feature 3: Circle Activation State ===\n    const [activationState, setActivationState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(()=>new Float32Array(TOTAL_CIRCLES).fill(0.0) // 0.0 inactive, 1.0 active\n    );\n    // New: Add horizontal cmd-click connector state\n    const [cmdHorizConnectors, setCmdHorizConnectors] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    // State needs to be reset if TOTAL_CIRCLES changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        console.log(\"Resetting activation state due to grid size change\");\n        setActivationState(new Float32Array(TOTAL_CIRCLES).fill(0.0));\n    }, [\n        TOTAL_CIRCLES\n    ]);\n    // Update buffer attribute when state changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (activationAttributeRef.current) {\n            activationAttributeRef.current.array = activationState;\n            activationAttributeRef.current.needsUpdate = true;\n            console.log(\"Updated activation buffer attribute.\");\n        }\n    }, [\n        activationState\n    ]);\n    // === Feature 2: Static Circle Rendering ===\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!meshRef.current) return;\n        // Calculate and set instance matrices\n        for(let index = 0; index < TOTAL_CIRCLES; index++){\n            const { row, col } = getCoords(index, GRID_WIDTH);\n            const { x, y } = getWorldPosition(row, col, GRID_WIDTH, GRID_HEIGHT, FIXED_SPACING, centerOffset);\n            dummy.position.set(x, y, 0); // Z=0 for circles\n            // Retrieve existing scale/rotation before setting position to avoid overwriting scale effect\n            const currentMatrix = new three__WEBPACK_IMPORTED_MODULE_2__.Matrix4();\n            meshRef.current.getMatrixAt(index, currentMatrix);\n            const position = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n            const quaternion = new three__WEBPACK_IMPORTED_MODULE_2__.Quaternion();\n            const scaleVec = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n            currentMatrix.decompose(position, quaternion, scaleVec);\n            // Update only position\n            position.set(x, y, 0);\n            dummy.matrix.compose(position, quaternion, scaleVec); // Recompose with original scale/rotation\n            meshRef.current.setMatrixAt(index, dummy.matrix);\n        }\n        meshRef.current.instanceMatrix.needsUpdate = true;\n    // console.log(`Updated ${TOTAL_CIRCLES} instance matrices (position).`);\n    }, [\n        GRID_WIDTH,\n        GRID_HEIGHT,\n        FIXED_SPACING,\n        TOTAL_CIRCLES,\n        centerOffset\n    ]);\n    // Update shader uniforms when scaled radii change\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (materialRef.current) {\n            // Shader expects radii relative to plane size (0.0 to 0.5 range if plane is size 1)\n            // Let's use plane size 1 and scale radii to 0.0-0.5 range for shader.\n            materialRef.current.uniforms.u_radiusA.value = BASE_RADIUS_A; // Use base radius relative to plane size 1\n            materialRef.current.uniforms.u_radiusB.value = BASE_RADIUS_B; // Use base radius relative to plane size 1\n            // Scale the whole instance instead to match spacing\n            console.log(`Updated material radii uniforms: A=${BASE_RADIUS_A}, B=${BASE_RADIUS_B}`);\n        }\n    }, []); // Depend on scaled radii, though using base for uniform now\n    // Adjust instance scale based on spacing\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!meshRef.current) return;\n        const scale = visualScale; // Use the leva control value for scale\n        console.log(`Updating instance scales to: ${scale.toFixed(2)}`);\n        for(let index = 0; index < TOTAL_CIRCLES; index++){\n            meshRef.current.getMatrixAt(index, tempMatrix);\n            const position = tempVec.setFromMatrixPosition(tempMatrix);\n            const quaternion = new three__WEBPACK_IMPORTED_MODULE_2__.Quaternion().setFromRotationMatrix(tempMatrix);\n            // Update only scale\n            const scaleVec = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3().set(scale, scale, 1);\n            tempMatrix.compose(position, quaternion, scaleVec);\n            meshRef.current.setMatrixAt(index, tempMatrix);\n        }\n        meshRef.current.instanceMatrix.needsUpdate = true;\n    }, [\n        visualScale,\n        TOTAL_CIRCLES\n    ]); // Depends on scale control and count\n    // === Feature 4: Circle Interaction ===\n    const handleCircleClick = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((event)=>{\n        event.stopPropagation();\n        if (event.instanceId === undefined || !meshRef.current) return;\n        const index = event.instanceId;\n        const { row: y, col: x } = getCoords(index, GRID_WIDTH);\n        console.log(\"Circle clicked:\", {\n            index,\n            x,\n            y,\n            isCmdClick: event.metaKey || event.ctrlKey,\n            point: event.point,\n            currentState: activationState[index]\n        });\n        // Get the center of the clicked instance\n        meshRef.current.getMatrixAt(index, tempMatrix);\n        const instanceCenter = tempVec.setFromMatrixPosition(tempMatrix);\n        // Calculate distance from click point to instance center\n        const distFromCenter = event.point.distanceTo(instanceCenter);\n        // Get the CURRENT world-space inner radius\n        const currentInnerRadius = BASE_RADIUS_B * visualScale;\n        console.log(\"Click details:\", {\n            distFromCenter,\n            currentInnerRadius,\n            isInside: distFromCenter <= currentInnerRadius\n        });\n        // Check if click is inside the inner circle\n        if (distFromCenter <= currentInnerRadius) {\n            // Check if this is a cmd/ctrl click\n            if (event.metaKey || event.ctrlKey) {\n                // Check conditions for horizontal connector\n                const rightIndex = getIndex(y, x + 1, GRID_WIDTH);\n                const canConnect = x < GRID_WIDTH - 1 && activationState[index] === 1.0 && activationState[rightIndex] === 1.0;\n                console.log(\"Processing cmd-click on circle:\", {\n                    x,\n                    y,\n                    rightIndex,\n                    leftActive: activationState[index] === 1.0,\n                    rightActive: x < GRID_WIDTH - 1 ? activationState[rightIndex] === 1.0 : false,\n                    canConnect\n                });\n                if (canConnect) {\n                    const connectorKey = getHorizCmdConnectorKey(x, y);\n                    console.log(\"Toggling horizontal connector:\", {\n                        key: connectorKey,\n                        currentValue: cmdHorizConnectors[connectorKey] || 0\n                    });\n                    // Toggle the horizontal connector\n                    setCmdHorizConnectors((prev)=>{\n                        const newValue = prev[connectorKey] ? 0 : 1;\n                        const newState = {\n                            ...prev,\n                            [connectorKey]: newValue\n                        };\n                        console.log(\"Updated connector state:\", {\n                            key: connectorKey,\n                            newValue,\n                            allConnectors: newState\n                        });\n                        return newState;\n                    });\n                    return;\n                }\n            }\n            // Regular click behavior (toggle activation)\n            console.log(\"Toggling circle activation\");\n            setActivationState((current)=>{\n                const newState = new Float32Array(current);\n                newState[index] = newState[index] === 1.0 ? 0.0 : 1.0;\n                console.log(\"New activation state for circle:\", {\n                    index,\n                    oldValue: current[index],\n                    newValue: newState[index]\n                });\n                return newState;\n            });\n        }\n    }, [\n        meshRef,\n        setActivationState,\n        GRID_WIDTH,\n        visualScale,\n        setCmdHorizConnectors,\n        cmdHorizConnectors\n    ]);\n    // === Feature 5: State Data Texture ===\n    const stateTexture = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        console.log(`Creating state texture: ${GRID_WIDTH}x${GRID_HEIGHT}`);\n        const texture = new three__WEBPACK_IMPORTED_MODULE_2__.DataTexture(new Float32Array(TOTAL_CIRCLES).fill(0.0), GRID_WIDTH, GRID_HEIGHT, three__WEBPACK_IMPORTED_MODULE_2__.RedFormat, three__WEBPACK_IMPORTED_MODULE_2__.FloatType);\n        texture.minFilter = three__WEBPACK_IMPORTED_MODULE_2__.NearestFilter; // Crucial: No interpolation\n        texture.magFilter = three__WEBPACK_IMPORTED_MODULE_2__.NearestFilter;\n        texture.needsUpdate = true; // Initial update needed\n        return texture;\n    }, [\n        GRID_WIDTH,\n        GRID_HEIGHT,\n        TOTAL_CIRCLES\n    ]); // Recreate texture if grid dimensions change\n    // Update texture data when activationState changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (stateTexture && activationState.length === stateTexture.image.data.length) {\n            stateTexture.image.data.set(activationState); // Update texture data directly\n            stateTexture.needsUpdate = true; // Mark for GPU upload\n            console.log(\"Updated state texture data.\");\n        } else {\n            console.warn(\"Skipping texture update: Mismatch between state array and texture size or texture not ready.\");\n        }\n    }, [\n        activationState,\n        stateTexture\n    ]); // Depend on activation state and the texture itself\n    // === Feature 8: Connector Interaction ===\n    // Connector intent state - track which connector types are intended for 2x2 cell groups\n    const [intendedConnectors, setIntendedConnectors] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    // Helper to get the key for a 2x2 cell group\n    const getCellGroupKey = (cellX, cellY)=>`${cellX},${cellY}`;\n    // Helper to get the intended connector for a 2x2 cell group\n    const getIntendedConnector = (cellX, cellY)=>{\n        const key = getCellGroupKey(cellX, cellY);\n        return intendedConnectors[key] || CONNECTOR_NONE;\n    };\n    // Handle clicks on the connector plane\n    const handleConnectorClick = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((event)=>{\n        event.stopPropagation();\n        console.log(\"Connector plane clicked:\", {\n            point: event.point,\n            isCmdClick: event.metaKey || event.ctrlKey\n        });\n        // Get the click point in world space\n        const clickPoint = event.point;\n        // First, check if the click is on a circle\n        // Determine which grid cell this point is closest to\n        const gridX = Math.round((clickPoint.x - centerOffset.x) / FIXED_SPACING);\n        const gridY = Math.round((clickPoint.y - centerOffset.y) / FIXED_SPACING);\n        // Check if this cell is within grid bounds\n        if (gridX >= 0 && gridX < GRID_WIDTH && gridY >= 0 && gridY < GRID_HEIGHT) {\n            // Calculate the cell center in world space\n            const cellCenter = getWorldPosition(gridY, gridX, GRID_WIDTH, GRID_HEIGHT, FIXED_SPACING, centerOffset);\n            // Calculate distance from click to cell center\n            const distFromCenter = Math.sqrt(Math.pow(clickPoint.x - cellCenter.x, 2) + Math.pow(clickPoint.y - cellCenter.y, 2));\n            // Check if click is inside the inner circle\n            const currentInnerRadius = BASE_RADIUS_B * visualScale;\n            if (distFromCenter <= currentInnerRadius) {\n                // This is a click on a circle - toggle its activation state\n                const index = getIndex(gridY, gridX, GRID_WIDTH);\n                // If this is a cmd/ctrl click and there's an active circle to the right\n                if ((event.metaKey || event.ctrlKey) && gridX < GRID_WIDTH - 1) {\n                    const rightIndex = getIndex(gridY, gridX + 1, GRID_WIDTH);\n                    const leftActive = activationState[index] === 1.0;\n                    const rightActive = activationState[rightIndex] === 1.0;\n                    console.log(\"Processing cmd-click:\", {\n                        x: gridX,\n                        y: gridY,\n                        leftActive,\n                        rightActive\n                    });\n                    // If both circles are active, toggle the connector\n                    if (leftActive && rightActive) {\n                        const connectorKey = getHorizCmdConnectorKey(gridX, gridY);\n                        setCmdHorizConnectors((prev)=>{\n                            const newConnectors = {\n                                ...prev\n                            };\n                            newConnectors[connectorKey] = prev[connectorKey] ? 0 : 1;\n                            console.log(\"Toggling cmd-horiz connector:\", {\n                                key: connectorKey,\n                                newValue: newConnectors[connectorKey]\n                            });\n                            return newConnectors;\n                        });\n                        return;\n                    }\n                }\n                // Regular click behavior (toggle activation)\n                setActivationState((current)=>{\n                    const newState = new Float32Array(current);\n                    newState[index] = newState[index] === 1.0 ? 0.0 : 1.0;\n                    return newState;\n                });\n                console.log(`Toggling circle at (${gridX},${gridY})`);\n                return;\n            }\n        }\n        // If we get here, the click wasn't on a circle, so treat it as a connector click\n        // Determine which grid cell (bottom-left of a 2x2 group) this point is closest to\n        const groupX = Math.floor((clickPoint.x - centerOffset.x) / FIXED_SPACING);\n        const groupY = Math.floor((clickPoint.y - centerOffset.y) / FIXED_SPACING);\n        // Get the indices of the four cells in the 2x2 group\n        const blIndex = getIndex(groupY, groupX, GRID_WIDTH);\n        const brIndex = getIndex(groupY, groupX + 1, GRID_WIDTH);\n        const tlIndex = getIndex(groupY + 1, groupX, GRID_WIDTH);\n        const trIndex = getIndex(groupY + 1, groupX + 1, GRID_WIDTH);\n        // Check which cells are within grid bounds\n        const isValidGroup = groupX >= 0 && groupX < GRID_WIDTH - 1 && groupY >= 0 && groupY < GRID_HEIGHT - 1;\n        if (!isValidGroup) return;\n        // Get activation states for the four cells\n        const blActive = activationState[blIndex] === 1.0;\n        const brActive = activationState[brIndex] === 1.0;\n        const tlActive = activationState[tlIndex] === 1.0;\n        const trActive = activationState[trIndex] === 1.0;\n        // Get the world positions of the cell centers\n        const blPos = getWorldPosition(groupY, groupX, GRID_WIDTH, GRID_HEIGHT, FIXED_SPACING, centerOffset);\n        const brPos = getWorldPosition(groupY, groupX + 1, GRID_WIDTH, GRID_HEIGHT, FIXED_SPACING, centerOffset);\n        const tlPos = getWorldPosition(groupY + 1, groupX, GRID_WIDTH, GRID_HEIGHT, FIXED_SPACING, centerOffset);\n        const trPos = getWorldPosition(groupY + 1, groupX + 1, GRID_WIDTH, GRID_HEIGHT, FIXED_SPACING, centerOffset);\n        // Calculate the center of the 2x2 group\n        const centerX = (blPos.x + brPos.x + tlPos.x + trPos.x) / 4;\n        const centerY = (blPos.y + brPos.y + tlPos.y + trPos.y) / 4;\n        // Calculate distance from click to center of 2x2 group\n        const distToCenter = Math.sqrt(Math.pow(clickPoint.x - centerX, 2) + Math.pow(clickPoint.y - centerY, 2));\n        // Check if the click is in the center zone (30% of cell spacing)\n        const isCenterClick = distToCenter < FIXED_SPACING * 0.3 * visualScale;\n        // Get the possible diagonal connectors\n        const canUseDiagTLBR = tlActive && brActive;\n        const canUseDiagBLTR = blActive && trActive;\n        const hasDiagonalOptions = canUseDiagTLBR || canUseDiagBLTR;\n        // Get current intended connector\n        const currentConnector = getIntendedConnector(groupX, groupY);\n        const groupKey = getCellGroupKey(groupX, groupY);\n        let newConnector = CONNECTOR_NONE;\n        // If clicked in the center and diagonal connectors are available, cycle through them\n        if (isCenterClick && hasDiagonalOptions) {\n            if (canUseDiagTLBR && canUseDiagBLTR) {\n                // Both diagonals are available, cycle through the options: NONE -> TL-BR -> BL-TR -> NONE\n                if (currentConnector === CONNECTOR_NONE) {\n                    newConnector = CONNECTOR_DIAG_TL_BR;\n                } else if (currentConnector === CONNECTOR_DIAG_TL_BR) {\n                    newConnector = CONNECTOR_DIAG_BL_TR;\n                } else {\n                    newConnector = CONNECTOR_NONE;\n                }\n            } else if (canUseDiagTLBR) {\n                // Only TL-BR diagonal is available, toggle it\n                newConnector = currentConnector === CONNECTOR_DIAG_TL_BR ? CONNECTOR_NONE : CONNECTOR_DIAG_TL_BR;\n            } else if (canUseDiagBLTR) {\n                // Only BL-TR diagonal is available, toggle it\n                newConnector = currentConnector === CONNECTOR_DIAG_BL_TR ? CONNECTOR_NONE : CONNECTOR_DIAG_BL_TR;\n            }\n        } else {\n            // For clicks outside the center, use the original logic\n            // Determine which connector was clicked\n            let clickedType = CONNECTOR_NONE;\n            // Calculate distances from click to each diagonal\n            const distToBLTR = Math.abs((clickPoint.x - blPos.x) * (trPos.y - blPos.y) - (clickPoint.y - blPos.y) * (trPos.x - blPos.x)) / Math.sqrt(Math.pow(trPos.x - blPos.x, 2) + Math.pow(trPos.y - blPos.y, 2));\n            const distToTLBR = Math.abs((clickPoint.x - tlPos.x) * (brPos.y - tlPos.y) - (clickPoint.y - tlPos.y) * (brPos.x - tlPos.x)) / Math.sqrt(Math.pow(brPos.x - tlPos.x, 2) + Math.pow(brPos.y - tlPos.y, 2));\n            // Determine if click is closer to horizontal or vertical\n            const clickOffsetX = clickPoint.x - centerX;\n            const clickOffsetY = clickPoint.y - centerY;\n            const isHorizontalClick = Math.abs(clickOffsetY) < Math.abs(clickOffsetX);\n            const isTopHalf = clickOffsetY > 0;\n            if (distToBLTR < distToTLBR) {\n                // Closer to BL-TR diagonal (/)\n                if (blActive && trActive) {\n                    clickedType = CONNECTOR_DIAG_BL_TR;\n                }\n            } else {\n                // Closer to TL-BR diagonal (\\)\n                if (tlActive && brActive) {\n                    clickedType = CONNECTOR_DIAG_TL_BR;\n                }\n            }\n            // Horizontal connector logic\n            if (isHorizontalClick) {\n                if (isTopHalf) {\n                    // Top horizontal\n                    if (tlActive && trActive) {\n                        clickedType = CONNECTOR_HORIZ_T;\n                    }\n                } else {\n                    // Bottom horizontal\n                    if (blActive && brActive) {\n                        clickedType = CONNECTOR_HORIZ_B;\n                    }\n                }\n            }\n            // Toggle logic - if the clicked connector is already active, turn it off\n            // Otherwise, turn off any current connector and turn on the clicked one\n            if (currentConnector === clickedType) {\n                newConnector = CONNECTOR_NONE; // Toggle off\n            } else if (clickedType !== CONNECTOR_NONE) {\n                newConnector = clickedType; // Toggle on new connector\n            }\n        }\n        // Update the intended connector\n        setIntendedConnectors((prev)=>({\n                ...prev,\n                [groupKey]: newConnector\n            }));\n        console.log(`Clicked cell group (${groupX},${groupY}), setting connector to ${newConnector}`);\n    }, [\n        GRID_WIDTH,\n        GRID_HEIGHT,\n        FIXED_SPACING,\n        centerOffset,\n        activationState,\n        intendedConnectors,\n        visualScale\n    ]);\n    // Reset connector intent when a circle is deactivated\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        // Check all cell groups\n        const newIntendedConnectors = {\n            ...intendedConnectors\n        };\n        const newCmdHorizConnectors = {\n            ...cmdHorizConnectors\n        };\n        let hasChanges = false;\n        let hasCmdHorizChanges = false;\n        // First check regular connectors\n        for(const key in intendedConnectors){\n            const connector = intendedConnectors[key];\n            if (connector === CONNECTOR_NONE) continue;\n            // Parse x,y from key\n            const [x, y] = key.split(\",\").map(Number);\n            // Get the indices of the four cells\n            const blIndex = getIndex(y, x, GRID_WIDTH);\n            const brIndex = getIndex(y, x + 1, GRID_WIDTH);\n            const tlIndex = getIndex(y + 1, x, GRID_WIDTH);\n            const trIndex = getIndex(y + 1, x + 1, GRID_WIDTH);\n            // Get activation states\n            const blActive = activationState[blIndex] === 1.0;\n            const brActive = activationState[brIndex] === 1.0;\n            const tlActive = activationState[tlIndex] === 1.0;\n            const trActive = activationState[trIndex] === 1.0;\n            // Check if the connector is still valid\n            let isValid = true;\n            switch(connector){\n                case CONNECTOR_DIAG_TL_BR:\n                    isValid = tlActive && brActive;\n                    break;\n                case CONNECTOR_DIAG_BL_TR:\n                    isValid = blActive && trActive;\n                    break;\n                case CONNECTOR_HORIZ_T:\n                    isValid = tlActive && trActive;\n                    break;\n                case CONNECTOR_HORIZ_B:\n                    isValid = blActive && brActive;\n                    break;\n            }\n            if (!isValid) {\n                newIntendedConnectors[key] = CONNECTOR_NONE;\n                hasChanges = true;\n            }\n        }\n        // Now check cmd-click horizontal connectors\n        for(const key in cmdHorizConnectors){\n            if (cmdHorizConnectors[key] === 0) continue;\n            // Parse x,y from key (remove 'hcmd:' prefix)\n            const [x, y] = key.substring(5).split(\",\").map(Number);\n            // Get indices for left and right circles\n            const leftIndex = getIndex(y, x, GRID_WIDTH);\n            const rightIndex = getIndex(y, x + 1, GRID_WIDTH);\n            // Check if both circles are still active\n            const leftActive = activationState[leftIndex] === 1.0;\n            const rightActive = activationState[rightIndex] === 1.0;\n            if (!leftActive || !rightActive) {\n                newCmdHorizConnectors[key] = 0;\n                hasCmdHorizChanges = true;\n            }\n        }\n        if (hasChanges) {\n            setIntendedConnectors(newIntendedConnectors);\n        }\n        if (hasCmdHorizChanges) {\n            setCmdHorizConnectors(newCmdHorizConnectors);\n        }\n    }, [\n        activationState,\n        GRID_WIDTH,\n        intendedConnectors,\n        cmdHorizConnectors\n    ]);\n    // Create a data texture for intended connectors\n    const intendedConnectorTexture = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        console.log(`Creating intended connector texture: ${GRID_WIDTH - 1}x${GRID_HEIGHT - 1}`);\n        // Texture has one pixel per 2x2 cell group (grid cells minus 1 in each dimension)\n        const width = Math.max(1, GRID_WIDTH - 1);\n        const height = Math.max(1, GRID_HEIGHT - 1);\n        const texture = new three__WEBPACK_IMPORTED_MODULE_2__.DataTexture(new Float32Array(width * height).fill(0.0), width, height, three__WEBPACK_IMPORTED_MODULE_2__.RedFormat, three__WEBPACK_IMPORTED_MODULE_2__.FloatType);\n        texture.minFilter = three__WEBPACK_IMPORTED_MODULE_2__.NearestFilter;\n        texture.magFilter = three__WEBPACK_IMPORTED_MODULE_2__.NearestFilter;\n        texture.needsUpdate = true;\n        return texture;\n    }, [\n        GRID_WIDTH,\n        GRID_HEIGHT\n    ]);\n    // Update the intended connector texture when state changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const width = Math.max(1, GRID_WIDTH - 1);\n        const data = new Float32Array(width * Math.max(1, GRID_HEIGHT - 1));\n        for(let y = 0; y < GRID_HEIGHT - 1; y++){\n            for(let x = 0; x < GRID_WIDTH - 1; x++){\n                const index = y * width + x;\n                const connector = getIntendedConnector(x, y);\n                data[index] = connector;\n            }\n        }\n        if (intendedConnectorTexture && data.length === intendedConnectorTexture.image.data.length) {\n            intendedConnectorTexture.image.data.set(data);\n            intendedConnectorTexture.needsUpdate = true;\n        }\n    }, [\n        intendedConnectors,\n        GRID_WIDTH,\n        GRID_HEIGHT,\n        intendedConnectorTexture\n    ]);\n    // Create horizontal cmd-click connector texture\n    const cmdHorizConnectorTexture = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        console.log(`Creating cmd-click horizontal connector texture: ${GRID_WIDTH - 1}x${GRID_HEIGHT}`);\n        // Texture has one pixel per horizontal connection possibility\n        const width = Math.max(1, GRID_WIDTH - 1);\n        const height = GRID_HEIGHT;\n        const texture = new three__WEBPACK_IMPORTED_MODULE_2__.DataTexture(new Float32Array(width * height).fill(0.0), width, height, three__WEBPACK_IMPORTED_MODULE_2__.RedFormat, three__WEBPACK_IMPORTED_MODULE_2__.FloatType);\n        texture.minFilter = three__WEBPACK_IMPORTED_MODULE_2__.NearestFilter;\n        texture.magFilter = three__WEBPACK_IMPORTED_MODULE_2__.NearestFilter;\n        texture.needsUpdate = true;\n        return texture;\n    }, [\n        GRID_WIDTH,\n        GRID_HEIGHT\n    ]);\n    // Update the cmd-click horizontal connector texture when state changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const width = Math.max(1, GRID_WIDTH - 1);\n        const data = new Float32Array(width * GRID_HEIGHT);\n        console.log(\"Updating cmd-horiz connector texture:\", {\n            width,\n            height: GRID_HEIGHT,\n            connectors: cmdHorizConnectors\n        });\n        for(let y = 0; y < GRID_HEIGHT; y++){\n            for(let x = 0; x < width; x++){\n                const key = getHorizCmdConnectorKey(x, y);\n                const value = cmdHorizConnectors[key] || 0;\n                data[y * width + x] = value;\n                if (value > 0) {\n                    console.log(\"Found active connector:\", {\n                        x,\n                        y,\n                        key,\n                        value\n                    });\n                }\n            }\n        }\n        if (cmdHorizConnectorTexture && data.length === cmdHorizConnectorTexture.image.data.length) {\n            cmdHorizConnectorTexture.image.data.set(data);\n            cmdHorizConnectorTexture.needsUpdate = true;\n            console.log(\"Updated cmd-horiz connector texture data\");\n        } else {\n            console.warn(\"Skipping cmd-horiz texture update: size mismatch or texture not ready\", {\n                textureSize: cmdHorizConnectorTexture?.image.data.length,\n                dataSize: data.length\n            });\n        }\n    }, [\n        cmdHorizConnectors,\n        GRID_WIDTH,\n        GRID_HEIGHT,\n        cmdHorizConnectorTexture\n    ]);\n    // Ref for the new material\n    const cmdHorizMaterialRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"group\", {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"instancedMesh\", {\n                ref: meshRef,\n                args: [\n                    undefined,\n                    undefined,\n                    TOTAL_CIRCLES\n                ],\n                onClick: handleCircleClick,\n                position: [\n                    0,\n                    0,\n                    -0.1\n                ],\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"planeGeometry\", {\n                        args: [\n                            1,\n                            1\n                        ],\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"instancedBufferAttribute\", {\n                            ref: activationAttributeRef,\n                            attach: \"attributes-a_activated\",\n                            args: [\n                                activationState,\n                                1\n                            ],\n                            usage: three__WEBPACK_IMPORTED_MODULE_2__.DynamicDrawUsage\n                        }, void 0, false, {\n                            fileName: \"/Users/ian/cursor_projects/webGL_meta/components/GridScene.tsx\",\n                            lineNumber: 737,\n                            columnNumber: 11\n                        }, undefined)\n                    }, void 0, false, {\n                        fileName: \"/Users/ian/cursor_projects/webGL_meta/components/GridScene.tsx\",\n                        lineNumber: 735,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"circleMaterial\", {\n                        ref: materialRef,\n                        transparent: true\n                    }, _CircleMaterial__WEBPACK_IMPORTED_MODULE_4__[\"default\"].key, false, {\n                        fileName: \"/Users/ian/cursor_projects/webGL_meta/components/GridScene.tsx\",\n                        lineNumber: 744,\n                        columnNumber: 9\n                    }, undefined)\n                ]\n            }, `circles-${TOTAL_CIRCLES}`, true, {\n                fileName: \"/Users/ian/cursor_projects/webGL_meta/components/GridScene.tsx\",\n                lineNumber: 727,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"mesh\", {\n                position: [\n                    0,\n                    0,\n                    0.1\n                ],\n                onClick: handleConnectorClick,\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"planeGeometry\", {\n                        args: [\n                            planeWidth,\n                            planeHeight\n                        ]\n                    }, void 0, false, {\n                        fileName: \"/Users/ian/cursor_projects/webGL_meta/components/GridScene.tsx\",\n                        lineNumber: 757,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"connectorMaterial\", {\n                        ref: connectorMaterialRef,\n                        transparent: true,\n                        side: three__WEBPACK_IMPORTED_MODULE_2__.DoubleSide,\n                        // Pass required uniforms (cmdHoriz texture removed)\n                        u_stateTexture: stateTexture,\n                        u_intendedConnectorTexture: intendedConnectorTexture,\n                        // u_cmdHorizConnectorTexture removed\n                        u_gridDimensions: [\n                            GRID_WIDTH,\n                            GRID_HEIGHT\n                        ],\n                        u_textureResolution: [\n                            GRID_WIDTH,\n                            GRID_HEIGHT\n                        ],\n                        u_radiusA: BASE_RADIUS_A,\n                        u_radiusB: BASE_RADIUS_B,\n                        u_gridSpacing: visualScale,\n                        u_centerOffset: [\n                            centerOffset.x,\n                            centerOffset.y\n                        ],\n                        u_planeSize: [\n                            planeWidth,\n                            planeHeight\n                        ]\n                    }, _ConnectorMaterial__WEBPACK_IMPORTED_MODULE_5__[\"default\"].key, false, {\n                        fileName: \"/Users/ian/cursor_projects/webGL_meta/components/GridScene.tsx\",\n                        lineNumber: 758,\n                        columnNumber: 9\n                    }, undefined)\n                ]\n            }, `connector-plane-${GRID_WIDTH}-${GRID_HEIGHT}-${visualScale}`, true, {\n                fileName: \"/Users/ian/cursor_projects/webGL_meta/components/GridScene.tsx\",\n                lineNumber: 752,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"mesh\", {\n                position: [\n                    0,\n                    0,\n                    0.2\n                ],\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"planeGeometry\", {\n                        args: [\n                            planeWidth,\n                            planeHeight\n                        ]\n                    }, void 0, false, {\n                        fileName: \"/Users/ian/cursor_projects/webGL_meta/components/GridScene.tsx\",\n                        lineNumber: 784,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"cmdHorizConnectorMaterial\", {\n                        ref: cmdHorizMaterialRef,\n                        transparent: true,\n                        side: three__WEBPACK_IMPORTED_MODULE_2__.DoubleSide,\n                        // Pass necessary uniforms for this specific material\n                        u_stateTexture: stateTexture,\n                        u_cmdHorizConnectorTexture: cmdHorizConnectorTexture,\n                        u_gridDimensions: [\n                            GRID_WIDTH,\n                            GRID_HEIGHT\n                        ],\n                        u_textureResolution: [\n                            GRID_WIDTH,\n                            GRID_HEIGHT\n                        ],\n                        u_radiusA: BASE_RADIUS_A,\n                        u_radiusB: BASE_RADIUS_B,\n                        u_gridSpacing: visualScale,\n                        u_centerOffset: [\n                            centerOffset.x,\n                            centerOffset.y\n                        ],\n                        u_planeSize: [\n                            planeWidth,\n                            planeHeight\n                        ]\n                    }, _CmdHorizConnectorMaterial__WEBPACK_IMPORTED_MODULE_6__[\"default\"].key, false, {\n                        fileName: \"/Users/ian/cursor_projects/webGL_meta/components/GridScene.tsx\",\n                        lineNumber: 785,\n                        columnNumber: 9\n                    }, undefined)\n                ]\n            }, `cmd-horiz-connector-plane-${GRID_WIDTH}-${GRID_HEIGHT}-${visualScale}`, true, {\n                fileName: \"/Users/ian/cursor_projects/webGL_meta/components/GridScene.tsx\",\n                lineNumber: 778,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/ian/cursor_projects/webGL_meta/components/GridScene.tsx\",\n        lineNumber: 726,\n        columnNumber: 5\n    }, undefined);\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GridScene);\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUtIO3dCQUVMWSxhQUFhO3dCQUNiRyxNQUFNaE4sNkNBQWdCO3dCQUN0QixxREFBcUQ7d0JBQ3JEa04sZ0JBQWdCN0Y7d0JBQ2hCcUcsNEJBQTRCN0I7d0JBQzVCdUIsa0JBQWtCOzRCQUFDM0s7NEJBQVlDO3lCQUFZO3dCQUMzQzJLLHFCQUFxQjs0QkFBQzVLOzRCQUFZQzt5QkFBWTt3QkFDOUMyQyxXQUFXL0U7d0JBQ1hnRixXQUFXL0U7d0JBQ1grTSxlQUFlM0s7d0JBQ2Y0SyxnQkFBZ0I7NEJBQUMvTCxhQUFhQyxDQUFDOzRCQUFFRCxhQUFhRSxDQUFDO3lCQUFDO3dCQUNoRDhMLGFBQWE7NEJBQUN0Szs0QkFBWUM7eUJBQVk7dUJBWmpDL0Msc0VBQTZCOzs7Ozs7ZUFQL0IsQ0FBQywwQkFBMEIsRUFBRXFDLFdBQVcsQ0FBQyxFQUFFQyxZQUFZLENBQUMsRUFBRUMsWUFBWSxDQUFDOzs7Ozs7Ozs7OztBQXlCcEY7QUFFQSxpRUFBZUgsU0FBU0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYmdsLWRvdC1ncmlkLW12cC8uL2NvbXBvbmVudHMvR3JpZFNjZW5lLnRzeD8wZGNjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VNZW1vLCB1c2VSZWYsIHVzZUVmZmVjdCwgdXNlU3RhdGUsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgdXNlQ29udHJvbHMgfSBmcm9tICdsZXZhJztcbmltcG9ydCB7IHVzZUZyYW1lIH0gZnJvbSAnQHJlYWN0LXRocmVlL2ZpYmVyJztcbmltcG9ydCBDaXJjbGVNYXRlcmlhbCBmcm9tICcuL0NpcmNsZU1hdGVyaWFsJztcbmltcG9ydCBDb25uZWN0b3JNYXRlcmlhbCBmcm9tICcuL0Nvbm5lY3Rvck1hdGVyaWFsJztcbmltcG9ydCBDbWRIb3JpekNvbm5lY3Rvck1hdGVyaWFsIGZyb20gJy4vQ21kSG9yaXpDb25uZWN0b3JNYXRlcmlhbCc7XG5cbi8vID09PSBGZWF0dXJlIDE6IEdyaWQgRGF0YSAmIENvbmZpZ3VyYXRpb24gPT09XG5cbi8vIENvbnN0YW50cyBmb3IgYmFzZSBnZW9tZXRyeVxuY29uc3QgQkFTRV9HUklEX1NQQUNJTkcgPSAxLjA7IC8vIEtlZXAgZm9yIHJlZmVyZW5jZSBpZiBuZWVkZWQsIGJ1dCBzcGFjaW5nIGlzIG5vdyBmaXhlZFxuY29uc3QgQkFTRV9SQURJVVNfQSA9IDAuNTsgLy8gT3V0ZXIgcmFkaXVzXG5jb25zdCBCQVNFX1JBRElVU19CID0gMC40OyAvLyBJbm5lciByYWRpdXNcblxuLy8gQ2FsY3VsYXRlIHRoZSBmaXhlZCBzcGFjaW5nIGJhc2VkIG9uIGRlc2lyZWQgb3ZlcmxhcFxuY29uc3QgRklYRURfU1BBQ0lORyA9IEJBU0VfUkFESVVTX0EgKyBCQVNFX1JBRElVU19COyAvLyAwLjUgKyAwLjQgPSAwLjlcblxuLy8gSGVscGVyIEZ1bmN0aW9uc1xuY29uc3QgZ2V0SW5kZXggPSAocm93OiBudW1iZXIsIGNvbDogbnVtYmVyLCBncmlkV2lkdGg6IG51bWJlcik6IG51bWJlciA9PiB7XG4gIHJldHVybiByb3cgKiBncmlkV2lkdGggKyBjb2w7XG59O1xuXG5jb25zdCBnZXRDb29yZHMgPSAoaW5kZXg6IG51bWJlciwgZ3JpZFdpZHRoOiBudW1iZXIpOiB7IHJvdzogbnVtYmVyOyBjb2w6IG51bWJlciB9ID0+IHtcbiAgY29uc3Qgcm93ID0gTWF0aC5mbG9vcihpbmRleCAvIGdyaWRXaWR0aCk7XG4gIGNvbnN0IGNvbCA9IGluZGV4ICUgZ3JpZFdpZHRoO1xuICByZXR1cm4geyByb3csIGNvbCB9O1xufTtcblxuLy8gTW9kaWZpZWQgdG8gdXNlIGZpeGVkIHNwYWNpbmdcbmNvbnN0IGdldENlbnRlck9mZnNldCA9IChncmlkV2lkdGg6IG51bWJlciwgZ3JpZEhlaWdodDogbnVtYmVyLCBzcGFjaW5nOiBudW1iZXIpOiBUSFJFRS5WZWN0b3IyID0+IHtcbiAgY29uc3QgdG90YWxXaWR0aCA9IChncmlkV2lkdGggLSAxKSAqIHNwYWNpbmc7XG4gIGNvbnN0IHRvdGFsSGVpZ2h0ID0gKGdyaWRIZWlnaHQgLSAxKSAqIHNwYWNpbmc7XG4gIHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMigtdG90YWxXaWR0aCAvIDIsIC10b3RhbEhlaWdodCAvIDIpO1xufTtcblxuLy8gTW9kaWZpZWQgdG8gdXNlIGZpeGVkIHNwYWNpbmdcbmNvbnN0IGdldFdvcmxkUG9zaXRpb24gPSAoXG4gIHJvdzogbnVtYmVyLFxuICBjb2w6IG51bWJlcixcbiAgZ3JpZFdpZHRoOiBudW1iZXIsIC8vIEtlZXAgZ3JpZCBkaW1lbnNpb25zIGZvciBvZmZzZXQgY2FsY3VsYXRpb24gaWYgbmVlZGVkXG4gIGdyaWRIZWlnaHQ6IG51bWJlcixcbiAgc3BhY2luZzogbnVtYmVyLCAvLyBUaGlzIHdpbGwgYmUgRklYRURfU1BBQ0lOR1xuICBjZW50ZXJPZmZzZXQ6IFRIUkVFLlZlY3RvcjJcbik6IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfSA9PiB7XG4gIGNvbnN0IHggPSBjb2wgKiBzcGFjaW5nICsgY2VudGVyT2Zmc2V0Lng7XG4gIGNvbnN0IHkgPSByb3cgKiBzcGFjaW5nICsgY2VudGVyT2Zmc2V0Lnk7XG4gIHJldHVybiB7IHgsIHkgfTtcbn07XG5cbi8vIERlZmluZSBjb25uZWN0b3IgdHlwZXMgYXMgY29uc3RhbnRzXG5jb25zdCBDT05ORUNUT1JfTk9ORSA9IDA7XG5jb25zdCBDT05ORUNUT1JfRElBR19UTF9CUiA9IDE7IC8vIERpYWdvbmFsIFxcXG5jb25zdCBDT05ORUNUT1JfRElBR19CTF9UUiA9IDI7IC8vIERpYWdvbmFsIC9cbmNvbnN0IENPTk5FQ1RPUl9IT1JJWl9UID0gMzsgICAgLy8gSG9yaXpvbnRhbCBUb3BcbmNvbnN0IENPTk5FQ1RPUl9IT1JJWl9CID0gNDsgICAgLy8gSG9yaXpvbnRhbCBCb3R0b21cbmNvbnN0IENPTk5FQ1RPUl9IT1JJWl9DTUQgPSA1OyAgLy8gTmV3OiBDbWQtY2xpY2sgaG9yaXpvbnRhbCBjb25uZWN0b3JcblxuLy8gPT09IEdyaWRTY2VuZSBDb21wb25lbnQgPT09XG5cbi8vIER1bW15IG9iamVjdCBmb3IgbWF0cml4IGNhbGN1bGF0aW9uc1xuY29uc3QgZHVtbXkgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcbmNvbnN0IHRlbXBNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuY29uc3QgdGVtcFZlYyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbi8vIE5ldzogSGVscGVyIGZvciBob3Jpem9udGFsIGNtZC1jbGljayBjb25uZWN0b3Iga2V5IGdlbmVyYXRpb25cbmNvbnN0IGdldEhvcml6Q21kQ29ubmVjdG9yS2V5ID0gKHg6IG51bWJlciwgeTogbnVtYmVyKSA9PiBgaGNtZDoke3h9LCR7eX1gO1xuXG5jb25zdCBHcmlkU2NlbmUgPSAoKSA9PiB7XG4gIC8vIExldmEgY29udHJvbHMgZm9yIGdyaWQgcGFyYW1ldGVyc1xuICBjb25zdCB7IEdSSURfV0lEVEgsIEdSSURfSEVJR0hULCB2aXN1YWxTY2FsZSB9ID0gdXNlQ29udHJvbHMoJ0dyaWQnLCB7XG4gICAgR1JJRF9XSURUSDogeyB2YWx1ZTogMTAsIG1pbjogMiwgbWF4OiAxMDAsIHN0ZXA6IDEgfSxcbiAgICBHUklEX0hFSUdIVDogeyB2YWx1ZTogMTAsIG1pbjogMiwgbWF4OiAxMDAsIHN0ZXA6IDEgfSxcbiAgICB2aXN1YWxTY2FsZTogeyAvLyBSZW5hbWVkIGZyb20gY3VycmVudEdyaWRTcGFjaW5nXG4gICAgICB2YWx1ZTogMS4wLCAvLyBEZWZhdWx0IHNjYWxlIGlzIDEuMFxuICAgICAgbWluOiAwLjEsXG4gICAgICBtYXg6IDUsXG4gICAgICBzdGVwOiAwLjEsXG4gICAgICBsYWJlbDogJ1Zpc3VhbCBTY2FsZScgLy8gVXBkYXRlZCBsYWJlbFxuICAgIH0sXG4gIH0pO1xuXG4gIC8vIERlcml2ZWQgdmFsdWVzIGNhbGN1bGF0aW9uIHVzaW5nIHVzZU1lbW8gZm9yIG9wdGltaXphdGlvblxuICBjb25zdCB7IFxuICAgIFRPVEFMX0NJUkNMRVMsIFxuICAgIGNlbnRlck9mZnNldCwgLy8gQmFzZWQgb24gRklYRURfU1BBQ0lOR1xuICAgIHBsYW5lV2lkdGgsICAgLy8gQmFzZWQgb24gRklYRURfU1BBQ0lOR1xuICAgIHBsYW5lSGVpZ2h0ICAgLy8gQmFzZWQgb24gRklYRURfU1BBQ0lOR1xuICB9ID0gdXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgdG90YWwgPSBHUklEX1dJRFRIICogR1JJRF9IRUlHSFQ7XG4gICAgLy8gT2Zmc2V0IGFuZCBwbGFuZSBkaW1lbnNpb25zIGRlcGVuZCBvbiB0aGUgZml4ZWQgc3BhY2luZyBiZXR3ZWVuIGNlbnRlcnNcbiAgICBjb25zdCBvZmZzZXQgPSBnZXRDZW50ZXJPZmZzZXQoR1JJRF9XSURUSCwgR1JJRF9IRUlHSFQsIEZJWEVEX1NQQUNJTkcpO1xuICAgIC8vIENhbGN1bGF0ZSBhY3R1YWwgZ3JpZCBleHRlbnQgYmFzZWQgb24gZml4ZWQgc3BhY2luZ1xuICAgIGNvbnN0IHdpZHRoID0gKEdSSURfV0lEVEggPiAxID8gKEdSSURfV0lEVEggLSAxKSAqIEZJWEVEX1NQQUNJTkcgOiAwKSArICh2aXN1YWxTY2FsZSAqIEJBU0VfUkFESVVTX0EgKiAyKTsgLy8gQWRkIGRpYW1ldGVyIG1hcmdpblxuICAgIGNvbnN0IGhlaWdodCA9IChHUklEX0hFSUdIVCA+IDEgPyAoR1JJRF9IRUlHSFQgLSAxKSAqIEZJWEVEX1NQQUNJTkcgOiAwKSArICh2aXN1YWxTY2FsZSAqIEJBU0VfUkFESVVTX0EgKiAyKTsgLy8gQWRkIGRpYW1ldGVyIG1hcmdpblxuICAgIFxuICAgIGNvbnNvbGUubG9nKGBMYXlvdXQgU3BhY2luZzogJHtGSVhFRF9TUEFDSU5HLnRvRml4ZWQoMil9YCk7XG4gICAgY29uc29sZS5sb2coYENhbGN1bGF0ZWQgQ2VudGVyIE9mZnNldDogeD0ke29mZnNldC54LnRvRml4ZWQoMil9LCB5PSR7b2Zmc2V0LnkudG9GaXhlZCgyKX1gKTtcbiAgICBjb25zb2xlLmxvZyhgQ2FsY3VsYXRlZCBQbGFuZSBTaXplOiB3PSR7d2lkdGgudG9GaXhlZCgyKX0sIGg9JHtoZWlnaHQudG9GaXhlZCgyKX1gKTtcblxuICAgIHJldHVybiB7XG4gICAgICBUT1RBTF9DSVJDTEVTOiB0b3RhbCxcbiAgICAgIGNlbnRlck9mZnNldDogb2Zmc2V0LFxuICAgICAgcGxhbmVXaWR0aDogd2lkdGgsXG4gICAgICBwbGFuZUhlaWdodDogaGVpZ2h0LFxuICAgIH07XG4gIH0sIFtHUklEX1dJRFRILCBHUklEX0hFSUdIVCwgdmlzdWFsU2NhbGVdKTsgLy8gRGVwZW5kIG9uIGdyaWQgc2l6ZSBhbmQgdmlzdWFsIHNjYWxlIGZvciBwbGFuZSBtYXJnaW5cblxuICAvLyBSZWZzIGZvciBtZXNoIGFuZCBtYXRlcmlhbFxuICBjb25zdCBtZXNoUmVmID0gdXNlUmVmPFRIUkVFLkluc3RhbmNlZE1lc2g+KG51bGwhKTtcbiAgY29uc3QgbWF0ZXJpYWxSZWYgPSB1c2VSZWY8YW55PihudWxsISk7IC8vIFVzZSAnYW55JyBvciBzcGVjaWZpYyB0eXBlIGZvciBDaXJjbGVNYXRlcmlhbFxuICBjb25zdCBhY3RpdmF0aW9uQXR0cmlidXRlUmVmID0gdXNlUmVmPFRIUkVFLkluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZT4obnVsbCEpO1xuICBjb25zdCBjb25uZWN0b3JNYXRlcmlhbFJlZiA9IHVzZVJlZjxhbnk+KG51bGwhKTsgLy8gUmVmIGZvciBjb25uZWN0b3IgbWF0ZXJpYWxcblxuICAvLyA9PT0gRmVhdHVyZSAzOiBDaXJjbGUgQWN0aXZhdGlvbiBTdGF0ZSA9PT1cbiAgY29uc3QgW2FjdGl2YXRpb25TdGF0ZSwgc2V0QWN0aXZhdGlvblN0YXRlXSA9IHVzZVN0YXRlPEZsb2F0MzJBcnJheT4oKCkgPT4gXG4gICAgbmV3IEZsb2F0MzJBcnJheShUT1RBTF9DSVJDTEVTKS5maWxsKDAuMCkgLy8gMC4wIGluYWN0aXZlLCAxLjAgYWN0aXZlXG4gICk7XG5cbiAgLy8gTmV3OiBBZGQgaG9yaXpvbnRhbCBjbWQtY2xpY2sgY29ubmVjdG9yIHN0YXRlXG4gIGNvbnN0IFtjbWRIb3JpekNvbm5lY3RvcnMsIHNldENtZEhvcml6Q29ubmVjdG9yc10gPSB1c2VTdGF0ZTxSZWNvcmQ8c3RyaW5nLCBudW1iZXI+Pih7fSk7XG5cbiAgLy8gU3RhdGUgbmVlZHMgdG8gYmUgcmVzZXQgaWYgVE9UQUxfQ0lSQ0xFUyBjaGFuZ2VzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ1Jlc2V0dGluZyBhY3RpdmF0aW9uIHN0YXRlIGR1ZSB0byBncmlkIHNpemUgY2hhbmdlJyk7XG4gICAgc2V0QWN0aXZhdGlvblN0YXRlKG5ldyBGbG9hdDMyQXJyYXkoVE9UQUxfQ0lSQ0xFUykuZmlsbCgwLjApKTtcbiAgfSwgW1RPVEFMX0NJUkNMRVNdKTtcblxuICAvLyBVcGRhdGUgYnVmZmVyIGF0dHJpYnV0ZSB3aGVuIHN0YXRlIGNoYW5nZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoYWN0aXZhdGlvbkF0dHJpYnV0ZVJlZi5jdXJyZW50KSB7XG4gICAgICBhY3RpdmF0aW9uQXR0cmlidXRlUmVmLmN1cnJlbnQuYXJyYXkgPSBhY3RpdmF0aW9uU3RhdGU7XG4gICAgICBhY3RpdmF0aW9uQXR0cmlidXRlUmVmLmN1cnJlbnQubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgY29uc29sZS5sb2coJ1VwZGF0ZWQgYWN0aXZhdGlvbiBidWZmZXIgYXR0cmlidXRlLicpO1xuICAgIH1cbiAgfSwgW2FjdGl2YXRpb25TdGF0ZV0pO1xuXG4gIC8vID09PSBGZWF0dXJlIDI6IFN0YXRpYyBDaXJjbGUgUmVuZGVyaW5nID09PVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghbWVzaFJlZi5jdXJyZW50KSByZXR1cm47XG5cbiAgICAvLyBDYWxjdWxhdGUgYW5kIHNldCBpbnN0YW5jZSBtYXRyaWNlc1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBUT1RBTF9DSVJDTEVTOyBpbmRleCsrKSB7XG4gICAgICBjb25zdCB7IHJvdywgY29sIH0gPSBnZXRDb29yZHMoaW5kZXgsIEdSSURfV0lEVEgpO1xuICAgICAgY29uc3QgeyB4LCB5IH0gPSBnZXRXb3JsZFBvc2l0aW9uKFxuICAgICAgICByb3csXG4gICAgICAgIGNvbCxcbiAgICAgICAgR1JJRF9XSURUSCxcbiAgICAgICAgR1JJRF9IRUlHSFQsXG4gICAgICAgIEZJWEVEX1NQQUNJTkcsXG4gICAgICAgIGNlbnRlck9mZnNldFxuICAgICAgKTtcbiAgICAgIGR1bW15LnBvc2l0aW9uLnNldCh4LCB5LCAwKTsgLy8gWj0wIGZvciBjaXJjbGVzXG4gICAgICAgLy8gUmV0cmlldmUgZXhpc3Rpbmcgc2NhbGUvcm90YXRpb24gYmVmb3JlIHNldHRpbmcgcG9zaXRpb24gdG8gYXZvaWQgb3ZlcndyaXRpbmcgc2NhbGUgZWZmZWN0XG4gICAgICBjb25zdCBjdXJyZW50TWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcbiAgICAgIG1lc2hSZWYuY3VycmVudC5nZXRNYXRyaXhBdChpbmRleCwgY3VycmVudE1hdHJpeCk7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICBjb25zdCBxdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcbiAgICAgIGNvbnN0IHNjYWxlVmVjID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgIGN1cnJlbnRNYXRyaXguZGVjb21wb3NlKHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCBzY2FsZVZlYyk7XG4gICAgICAvLyBVcGRhdGUgb25seSBwb3NpdGlvblxuICAgICAgcG9zaXRpb24uc2V0KHgsIHksIDApO1xuICAgICAgZHVtbXkubWF0cml4LmNvbXBvc2UocG9zaXRpb24sIHF1YXRlcm5pb24sIHNjYWxlVmVjKTsgLy8gUmVjb21wb3NlIHdpdGggb3JpZ2luYWwgc2NhbGUvcm90YXRpb25cbiAgICAgIG1lc2hSZWYuY3VycmVudC5zZXRNYXRyaXhBdChpbmRleCwgZHVtbXkubWF0cml4KTtcbiAgICB9XG4gICAgbWVzaFJlZi5jdXJyZW50Lmluc3RhbmNlTWF0cml4Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgIC8vIGNvbnNvbGUubG9nKGBVcGRhdGVkICR7VE9UQUxfQ0lSQ0xFU30gaW5zdGFuY2UgbWF0cmljZXMgKHBvc2l0aW9uKS5gKTtcblxuICB9LCBbR1JJRF9XSURUSCwgR1JJRF9IRUlHSFQsIEZJWEVEX1NQQUNJTkcsIFRPVEFMX0NJUkNMRVMsIGNlbnRlck9mZnNldF0pO1xuXG4gIC8vIFVwZGF0ZSBzaGFkZXIgdW5pZm9ybXMgd2hlbiBzY2FsZWQgcmFkaWkgY2hhbmdlXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKG1hdGVyaWFsUmVmLmN1cnJlbnQpIHtcbiAgICAgIC8vIFNoYWRlciBleHBlY3RzIHJhZGlpIHJlbGF0aXZlIHRvIHBsYW5lIHNpemUgKDAuMCB0byAwLjUgcmFuZ2UgaWYgcGxhbmUgaXMgc2l6ZSAxKVxuICAgICAgLy8gTGV0J3MgdXNlIHBsYW5lIHNpemUgMSBhbmQgc2NhbGUgcmFkaWkgdG8gMC4wLTAuNSByYW5nZSBmb3Igc2hhZGVyLlxuICAgICAgbWF0ZXJpYWxSZWYuY3VycmVudC51bmlmb3Jtcy51X3JhZGl1c0EudmFsdWUgPSBCQVNFX1JBRElVU19BOyAvLyBVc2UgYmFzZSByYWRpdXMgcmVsYXRpdmUgdG8gcGxhbmUgc2l6ZSAxXG4gICAgICBtYXRlcmlhbFJlZi5jdXJyZW50LnVuaWZvcm1zLnVfcmFkaXVzQi52YWx1ZSA9IEJBU0VfUkFESVVTX0I7IC8vIFVzZSBiYXNlIHJhZGl1cyByZWxhdGl2ZSB0byBwbGFuZSBzaXplIDFcbiAgICAgIC8vIFNjYWxlIHRoZSB3aG9sZSBpbnN0YW5jZSBpbnN0ZWFkIHRvIG1hdGNoIHNwYWNpbmdcbiAgICAgICBjb25zb2xlLmxvZyhgVXBkYXRlZCBtYXRlcmlhbCByYWRpaSB1bmlmb3JtczogQT0ke0JBU0VfUkFESVVTX0F9LCBCPSR7QkFTRV9SQURJVVNfQn1gKTtcbiAgICB9XG4gIH0sIFtdKTsgLy8gRGVwZW5kIG9uIHNjYWxlZCByYWRpaSwgdGhvdWdoIHVzaW5nIGJhc2UgZm9yIHVuaWZvcm0gbm93XG5cbiAvLyBBZGp1c3QgaW5zdGFuY2Ugc2NhbGUgYmFzZWQgb24gc3BhY2luZ1xuIHVzZUVmZmVjdCgoKSA9PiB7XG4gIGlmICghbWVzaFJlZi5jdXJyZW50KSByZXR1cm47XG4gIGNvbnN0IHNjYWxlID0gdmlzdWFsU2NhbGU7IC8vIFVzZSB0aGUgbGV2YSBjb250cm9sIHZhbHVlIGZvciBzY2FsZVxuICBjb25zb2xlLmxvZyhgVXBkYXRpbmcgaW5zdGFuY2Ugc2NhbGVzIHRvOiAke3NjYWxlLnRvRml4ZWQoMil9YCk7XG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBUT1RBTF9DSVJDTEVTOyBpbmRleCsrKSB7XG4gICAgICBtZXNoUmVmLmN1cnJlbnQuZ2V0TWF0cml4QXQoaW5kZXgsIHRlbXBNYXRyaXgpO1xuICAgICAgY29uc3QgcG9zaXRpb24gPSB0ZW1wVmVjLnNldEZyb21NYXRyaXhQb3NpdGlvbih0ZW1wTWF0cml4KTtcbiAgICAgIGNvbnN0IHF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpLnNldEZyb21Sb3RhdGlvbk1hdHJpeCh0ZW1wTWF0cml4KTtcbiAgICAgIC8vIFVwZGF0ZSBvbmx5IHNjYWxlXG4gICAgICBjb25zdCBzY2FsZVZlYyA9IG5ldyBUSFJFRS5WZWN0b3IzKCkuc2V0KHNjYWxlLCBzY2FsZSwgMSk7XG4gICAgICBcbiAgICAgIHRlbXBNYXRyaXguY29tcG9zZShwb3NpdGlvbiwgcXVhdGVybmlvbiwgc2NhbGVWZWMpO1xuICAgICAgbWVzaFJlZi5jdXJyZW50LnNldE1hdHJpeEF0KGluZGV4LCB0ZW1wTWF0cml4KTtcbiAgfVxuICBtZXNoUmVmLmN1cnJlbnQuaW5zdGFuY2VNYXRyaXgubmVlZHNVcGRhdGUgPSB0cnVlO1xufSwgW3Zpc3VhbFNjYWxlLCBUT1RBTF9DSVJDTEVTXSk7IC8vIERlcGVuZHMgb24gc2NhbGUgY29udHJvbCBhbmQgY291bnRcblxuICAvLyA9PT0gRmVhdHVyZSA0OiBDaXJjbGUgSW50ZXJhY3Rpb24gPT09XG4gIGNvbnN0IGhhbmRsZUNpcmNsZUNsaWNrID0gdXNlQ2FsbGJhY2soKGV2ZW50OiBhbnkpID0+IHtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBpZiAoZXZlbnQuaW5zdGFuY2VJZCA9PT0gdW5kZWZpbmVkIHx8ICFtZXNoUmVmLmN1cnJlbnQpIHJldHVybjtcblxuICAgIGNvbnN0IGluZGV4ID0gZXZlbnQuaW5zdGFuY2VJZDtcbiAgICBjb25zdCB7IHJvdzogeSwgY29sOiB4IH0gPSBnZXRDb29yZHMoaW5kZXgsIEdSSURfV0lEVEgpO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKCdDaXJjbGUgY2xpY2tlZDonLCB7XG4gICAgICBpbmRleCxcbiAgICAgIHgsIHksXG4gICAgICBpc0NtZENsaWNrOiBldmVudC5tZXRhS2V5IHx8IGV2ZW50LmN0cmxLZXksXG4gICAgICBwb2ludDogZXZlbnQucG9pbnQsXG4gICAgICBjdXJyZW50U3RhdGU6IGFjdGl2YXRpb25TdGF0ZVtpbmRleF1cbiAgICB9KTtcblxuICAgIC8vIEdldCB0aGUgY2VudGVyIG9mIHRoZSBjbGlja2VkIGluc3RhbmNlXG4gICAgbWVzaFJlZi5jdXJyZW50LmdldE1hdHJpeEF0KGluZGV4LCB0ZW1wTWF0cml4KTtcbiAgICBjb25zdCBpbnN0YW5jZUNlbnRlciA9IHRlbXBWZWMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHRlbXBNYXRyaXgpO1xuXG4gICAgLy8gQ2FsY3VsYXRlIGRpc3RhbmNlIGZyb20gY2xpY2sgcG9pbnQgdG8gaW5zdGFuY2UgY2VudGVyXG4gICAgY29uc3QgZGlzdEZyb21DZW50ZXIgPSBldmVudC5wb2ludC5kaXN0YW5jZVRvKGluc3RhbmNlQ2VudGVyKTtcblxuICAgIC8vIEdldCB0aGUgQ1VSUkVOVCB3b3JsZC1zcGFjZSBpbm5lciByYWRpdXNcbiAgICBjb25zdCBjdXJyZW50SW5uZXJSYWRpdXMgPSBCQVNFX1JBRElVU19CICogdmlzdWFsU2NhbGU7IFxuXG4gICAgY29uc29sZS5sb2coJ0NsaWNrIGRldGFpbHM6Jywge1xuICAgICAgZGlzdEZyb21DZW50ZXIsXG4gICAgICBjdXJyZW50SW5uZXJSYWRpdXMsXG4gICAgICBpc0luc2lkZTogZGlzdEZyb21DZW50ZXIgPD0gY3VycmVudElubmVyUmFkaXVzXG4gICAgfSk7XG5cbiAgICAvLyBDaGVjayBpZiBjbGljayBpcyBpbnNpZGUgdGhlIGlubmVyIGNpcmNsZVxuICAgIGlmIChkaXN0RnJvbUNlbnRlciA8PSBjdXJyZW50SW5uZXJSYWRpdXMpIHtcbiAgICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYSBjbWQvY3RybCBjbGlja1xuICAgICAgaWYgKGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuY3RybEtleSkge1xuICAgICAgICAvLyBDaGVjayBjb25kaXRpb25zIGZvciBob3Jpem9udGFsIGNvbm5lY3RvclxuICAgICAgICBjb25zdCByaWdodEluZGV4ID0gZ2V0SW5kZXgoeSwgeCArIDEsIEdSSURfV0lEVEgpO1xuICAgICAgICBjb25zdCBjYW5Db25uZWN0ID0geCA8IEdSSURfV0lEVEggLSAxICYmIFxuICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2YXRpb25TdGF0ZVtpbmRleF0gPT09IDEuMCAmJiBcbiAgICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmF0aW9uU3RhdGVbcmlnaHRJbmRleF0gPT09IDEuMDtcblxuICAgICAgICBjb25zb2xlLmxvZygnUHJvY2Vzc2luZyBjbWQtY2xpY2sgb24gY2lyY2xlOicsIHtcbiAgICAgICAgICB4LCB5LFxuICAgICAgICAgIHJpZ2h0SW5kZXgsXG4gICAgICAgICAgbGVmdEFjdGl2ZTogYWN0aXZhdGlvblN0YXRlW2luZGV4XSA9PT0gMS4wLFxuICAgICAgICAgIHJpZ2h0QWN0aXZlOiB4IDwgR1JJRF9XSURUSCAtIDEgPyBhY3RpdmF0aW9uU3RhdGVbcmlnaHRJbmRleF0gPT09IDEuMCA6IGZhbHNlLFxuICAgICAgICAgIGNhbkNvbm5lY3RcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGNhbkNvbm5lY3QpIHtcbiAgICAgICAgICBjb25zdCBjb25uZWN0b3JLZXkgPSBnZXRIb3JpekNtZENvbm5lY3RvcktleSh4LCB5KTtcbiAgICAgICAgICBjb25zb2xlLmxvZygnVG9nZ2xpbmcgaG9yaXpvbnRhbCBjb25uZWN0b3I6Jywge1xuICAgICAgICAgICAga2V5OiBjb25uZWN0b3JLZXksXG4gICAgICAgICAgICBjdXJyZW50VmFsdWU6IGNtZEhvcml6Q29ubmVjdG9yc1tjb25uZWN0b3JLZXldIHx8IDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBUb2dnbGUgdGhlIGhvcml6b250YWwgY29ubmVjdG9yXG4gICAgICAgICAgc2V0Q21kSG9yaXpDb25uZWN0b3JzKHByZXYgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBwcmV2W2Nvbm5lY3RvcktleV0gPyAwIDogMTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1N0YXRlID0ge1xuICAgICAgICAgICAgICAuLi5wcmV2LFxuICAgICAgICAgICAgICBbY29ubmVjdG9yS2V5XTogbmV3VmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnVXBkYXRlZCBjb25uZWN0b3Igc3RhdGU6Jywge1xuICAgICAgICAgICAgICBrZXk6IGNvbm5lY3RvcktleSxcbiAgICAgICAgICAgICAgbmV3VmFsdWUsXG4gICAgICAgICAgICAgIGFsbENvbm5lY3RvcnM6IG5ld1N0YXRlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUmVndWxhciBjbGljayBiZWhhdmlvciAodG9nZ2xlIGFjdGl2YXRpb24pXG4gICAgICBjb25zb2xlLmxvZygnVG9nZ2xpbmcgY2lyY2xlIGFjdGl2YXRpb24nKTtcbiAgICAgIHNldEFjdGl2YXRpb25TdGF0ZShjdXJyZW50ID0+IHtcbiAgICAgICAgY29uc3QgbmV3U3RhdGUgPSBuZXcgRmxvYXQzMkFycmF5KGN1cnJlbnQpO1xuICAgICAgICBuZXdTdGF0ZVtpbmRleF0gPSBuZXdTdGF0ZVtpbmRleF0gPT09IDEuMCA/IDAuMCA6IDEuMDtcbiAgICAgICAgY29uc29sZS5sb2coJ05ldyBhY3RpdmF0aW9uIHN0YXRlIGZvciBjaXJjbGU6Jywge1xuICAgICAgICAgIGluZGV4LFxuICAgICAgICAgIG9sZFZhbHVlOiBjdXJyZW50W2luZGV4XSxcbiAgICAgICAgICBuZXdWYWx1ZTogbmV3U3RhdGVbaW5kZXhdXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFttZXNoUmVmLCBzZXRBY3RpdmF0aW9uU3RhdGUsIEdSSURfV0lEVEgsIHZpc3VhbFNjYWxlLCBzZXRDbWRIb3JpekNvbm5lY3RvcnMsIGNtZEhvcml6Q29ubmVjdG9yc10pO1xuXG4gIC8vID09PSBGZWF0dXJlIDU6IFN0YXRlIERhdGEgVGV4dHVyZSA9PT1cbiAgY29uc3Qgc3RhdGVUZXh0dXJlID0gdXNlTWVtbygoKSA9PiB7XG4gICAgY29uc29sZS5sb2coYENyZWF0aW5nIHN0YXRlIHRleHR1cmU6ICR7R1JJRF9XSURUSH14JHtHUklEX0hFSUdIVH1gKTtcbiAgICBjb25zdCB0ZXh0dXJlID0gbmV3IFRIUkVFLkRhdGFUZXh0dXJlKFxuICAgICAgbmV3IEZsb2F0MzJBcnJheShUT1RBTF9DSVJDTEVTKS5maWxsKDAuMCksIC8vIEluaXRpYWwgZGF0YSBidWZmZXJcbiAgICAgIEdSSURfV0lEVEgsXG4gICAgICBHUklEX0hFSUdIVCxcbiAgICAgIFRIUkVFLlJlZEZvcm1hdCwgLy8gU3RvcmUgYWN0aXZhdGlvbiAoMC4wIG9yIDEuMCkgaW4gUmVkIGNoYW5uZWxcbiAgICAgIFRIUkVFLkZsb2F0VHlwZVxuICAgICk7XG4gICAgdGV4dHVyZS5taW5GaWx0ZXIgPSBUSFJFRS5OZWFyZXN0RmlsdGVyOyAvLyBDcnVjaWFsOiBObyBpbnRlcnBvbGF0aW9uXG4gICAgdGV4dHVyZS5tYWdGaWx0ZXIgPSBUSFJFRS5OZWFyZXN0RmlsdGVyO1xuICAgIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlOyAvLyBJbml0aWFsIHVwZGF0ZSBuZWVkZWRcbiAgICByZXR1cm4gdGV4dHVyZTtcbiAgfSwgW0dSSURfV0lEVEgsIEdSSURfSEVJR0hULCBUT1RBTF9DSVJDTEVTXSk7IC8vIFJlY3JlYXRlIHRleHR1cmUgaWYgZ3JpZCBkaW1lbnNpb25zIGNoYW5nZVxuXG4gIC8vIFVwZGF0ZSB0ZXh0dXJlIGRhdGEgd2hlbiBhY3RpdmF0aW9uU3RhdGUgY2hhbmdlc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChzdGF0ZVRleHR1cmUgJiYgYWN0aXZhdGlvblN0YXRlLmxlbmd0aCA9PT0gc3RhdGVUZXh0dXJlLmltYWdlLmRhdGEubGVuZ3RoKSB7XG4gICAgICBzdGF0ZVRleHR1cmUuaW1hZ2UuZGF0YS5zZXQoYWN0aXZhdGlvblN0YXRlKTsgLy8gVXBkYXRlIHRleHR1cmUgZGF0YSBkaXJlY3RseVxuICAgICAgc3RhdGVUZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTsgLy8gTWFyayBmb3IgR1BVIHVwbG9hZFxuICAgICAgY29uc29sZS5sb2coJ1VwZGF0ZWQgc3RhdGUgdGV4dHVyZSBkYXRhLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1NraXBwaW5nIHRleHR1cmUgdXBkYXRlOiBNaXNtYXRjaCBiZXR3ZWVuIHN0YXRlIGFycmF5IGFuZCB0ZXh0dXJlIHNpemUgb3IgdGV4dHVyZSBub3QgcmVhZHkuJyk7XG4gICAgfVxuICB9LCBbYWN0aXZhdGlvblN0YXRlLCBzdGF0ZVRleHR1cmVdKTsgLy8gRGVwZW5kIG9uIGFjdGl2YXRpb24gc3RhdGUgYW5kIHRoZSB0ZXh0dXJlIGl0c2VsZlxuXG4gIC8vID09PSBGZWF0dXJlIDg6IENvbm5lY3RvciBJbnRlcmFjdGlvbiA9PT1cbiAgLy8gQ29ubmVjdG9yIGludGVudCBzdGF0ZSAtIHRyYWNrIHdoaWNoIGNvbm5lY3RvciB0eXBlcyBhcmUgaW50ZW5kZWQgZm9yIDJ4MiBjZWxsIGdyb3Vwc1xuICBjb25zdCBbaW50ZW5kZWRDb25uZWN0b3JzLCBzZXRJbnRlbmRlZENvbm5lY3RvcnNdID0gdXNlU3RhdGU8UmVjb3JkPHN0cmluZywgbnVtYmVyPj4oe30pO1xuXG4gIC8vIEhlbHBlciB0byBnZXQgdGhlIGtleSBmb3IgYSAyeDIgY2VsbCBncm91cFxuICBjb25zdCBnZXRDZWxsR3JvdXBLZXkgPSAoY2VsbFg6IG51bWJlciwgY2VsbFk6IG51bWJlcikgPT4gYCR7Y2VsbFh9LCR7Y2VsbFl9YDtcblxuICAvLyBIZWxwZXIgdG8gZ2V0IHRoZSBpbnRlbmRlZCBjb25uZWN0b3IgZm9yIGEgMngyIGNlbGwgZ3JvdXBcbiAgY29uc3QgZ2V0SW50ZW5kZWRDb25uZWN0b3IgPSAoY2VsbFg6IG51bWJlciwgY2VsbFk6IG51bWJlcikgPT4ge1xuICAgIGNvbnN0IGtleSA9IGdldENlbGxHcm91cEtleShjZWxsWCwgY2VsbFkpO1xuICAgIHJldHVybiBpbnRlbmRlZENvbm5lY3RvcnNba2V5XSB8fCBDT05ORUNUT1JfTk9ORTtcbiAgfTtcblxuICAvLyBIYW5kbGUgY2xpY2tzIG9uIHRoZSBjb25uZWN0b3IgcGxhbmVcbiAgY29uc3QgaGFuZGxlQ29ubmVjdG9yQ2xpY2sgPSB1c2VDYWxsYmFjaygoZXZlbnQ6IGFueSkgPT4ge1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGNvbnNvbGUubG9nKCdDb25uZWN0b3IgcGxhbmUgY2xpY2tlZDonLCB7XG4gICAgICBwb2ludDogZXZlbnQucG9pbnQsXG4gICAgICBpc0NtZENsaWNrOiBldmVudC5tZXRhS2V5IHx8IGV2ZW50LmN0cmxLZXlcbiAgICB9KTtcbiAgICBcbiAgICAvLyBHZXQgdGhlIGNsaWNrIHBvaW50IGluIHdvcmxkIHNwYWNlXG4gICAgY29uc3QgY2xpY2tQb2ludCA9IGV2ZW50LnBvaW50O1xuICAgIFxuICAgIC8vIEZpcnN0LCBjaGVjayBpZiB0aGUgY2xpY2sgaXMgb24gYSBjaXJjbGVcbiAgICAvLyBEZXRlcm1pbmUgd2hpY2ggZ3JpZCBjZWxsIHRoaXMgcG9pbnQgaXMgY2xvc2VzdCB0b1xuICAgIGNvbnN0IGdyaWRYID0gTWF0aC5yb3VuZCgoY2xpY2tQb2ludC54IC0gY2VudGVyT2Zmc2V0LngpIC8gRklYRURfU1BBQ0lORyk7XG4gICAgY29uc3QgZ3JpZFkgPSBNYXRoLnJvdW5kKChjbGlja1BvaW50LnkgLSBjZW50ZXJPZmZzZXQueSkgLyBGSVhFRF9TUEFDSU5HKTtcbiAgICBcbiAgICAvLyBDaGVjayBpZiB0aGlzIGNlbGwgaXMgd2l0aGluIGdyaWQgYm91bmRzXG4gICAgaWYgKGdyaWRYID49IDAgJiYgZ3JpZFggPCBHUklEX1dJRFRIICYmIGdyaWRZID49IDAgJiYgZ3JpZFkgPCBHUklEX0hFSUdIVCkge1xuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBjZWxsIGNlbnRlciBpbiB3b3JsZCBzcGFjZVxuICAgICAgY29uc3QgY2VsbENlbnRlciA9IGdldFdvcmxkUG9zaXRpb24oZ3JpZFksIGdyaWRYLCBHUklEX1dJRFRILCBHUklEX0hFSUdIVCwgRklYRURfU1BBQ0lORywgY2VudGVyT2Zmc2V0KTtcbiAgICAgIFxuICAgICAgLy8gQ2FsY3VsYXRlIGRpc3RhbmNlIGZyb20gY2xpY2sgdG8gY2VsbCBjZW50ZXJcbiAgICAgIGNvbnN0IGRpc3RGcm9tQ2VudGVyID0gTWF0aC5zcXJ0KFxuICAgICAgICBNYXRoLnBvdyhjbGlja1BvaW50LnggLSBjZWxsQ2VudGVyLngsIDIpICsgXG4gICAgICAgIE1hdGgucG93KGNsaWNrUG9pbnQueSAtIGNlbGxDZW50ZXIueSwgMilcbiAgICAgICk7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIGNsaWNrIGlzIGluc2lkZSB0aGUgaW5uZXIgY2lyY2xlXG4gICAgICBjb25zdCBjdXJyZW50SW5uZXJSYWRpdXMgPSBCQVNFX1JBRElVU19CICogdmlzdWFsU2NhbGU7XG4gICAgICBpZiAoZGlzdEZyb21DZW50ZXIgPD0gY3VycmVudElubmVyUmFkaXVzKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBjbGljayBvbiBhIGNpcmNsZSAtIHRvZ2dsZSBpdHMgYWN0aXZhdGlvbiBzdGF0ZVxuICAgICAgICBjb25zdCBpbmRleCA9IGdldEluZGV4KGdyaWRZLCBncmlkWCwgR1JJRF9XSURUSCk7XG5cbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIGNtZC9jdHJsIGNsaWNrIGFuZCB0aGVyZSdzIGFuIGFjdGl2ZSBjaXJjbGUgdG8gdGhlIHJpZ2h0XG4gICAgICAgIGlmICgoZXZlbnQubWV0YUtleSB8fCBldmVudC5jdHJsS2V5KSAmJiBncmlkWCA8IEdSSURfV0lEVEggLSAxKSB7XG4gICAgICAgICAgY29uc3QgcmlnaHRJbmRleCA9IGdldEluZGV4KGdyaWRZLCBncmlkWCArIDEsIEdSSURfV0lEVEgpO1xuICAgICAgICAgIGNvbnN0IGxlZnRBY3RpdmUgPSBhY3RpdmF0aW9uU3RhdGVbaW5kZXhdID09PSAxLjA7XG4gICAgICAgICAgY29uc3QgcmlnaHRBY3RpdmUgPSBhY3RpdmF0aW9uU3RhdGVbcmlnaHRJbmRleF0gPT09IDEuMDtcblxuICAgICAgICAgIGNvbnNvbGUubG9nKCdQcm9jZXNzaW5nIGNtZC1jbGljazonLCB7XG4gICAgICAgICAgICB4OiBncmlkWCwgeTogZ3JpZFksXG4gICAgICAgICAgICBsZWZ0QWN0aXZlLFxuICAgICAgICAgICAgcmlnaHRBY3RpdmVcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIElmIGJvdGggY2lyY2xlcyBhcmUgYWN0aXZlLCB0b2dnbGUgdGhlIGNvbm5lY3RvclxuICAgICAgICAgIGlmIChsZWZ0QWN0aXZlICYmIHJpZ2h0QWN0aXZlKSB7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0b3JLZXkgPSBnZXRIb3JpekNtZENvbm5lY3RvcktleShncmlkWCwgZ3JpZFkpO1xuICAgICAgICAgICAgc2V0Q21kSG9yaXpDb25uZWN0b3JzKHByZXYgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBuZXdDb25uZWN0b3JzID0geyAuLi5wcmV2IH07XG4gICAgICAgICAgICAgIG5ld0Nvbm5lY3RvcnNbY29ubmVjdG9yS2V5XSA9IHByZXZbY29ubmVjdG9yS2V5XSA/IDAgOiAxO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVG9nZ2xpbmcgY21kLWhvcml6IGNvbm5lY3RvcjonLCB7XG4gICAgICAgICAgICAgICAga2V5OiBjb25uZWN0b3JLZXksXG4gICAgICAgICAgICAgICAgbmV3VmFsdWU6IG5ld0Nvbm5lY3RvcnNbY29ubmVjdG9yS2V5XVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ld0Nvbm5lY3RvcnM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZWd1bGFyIGNsaWNrIGJlaGF2aW9yICh0b2dnbGUgYWN0aXZhdGlvbilcbiAgICAgICAgc2V0QWN0aXZhdGlvblN0YXRlKGN1cnJlbnQgPT4ge1xuICAgICAgICAgIGNvbnN0IG5ld1N0YXRlID0gbmV3IEZsb2F0MzJBcnJheShjdXJyZW50KTtcbiAgICAgICAgICBuZXdTdGF0ZVtpbmRleF0gPSBuZXdTdGF0ZVtpbmRleF0gPT09IDEuMCA/IDAuMCA6IDEuMDtcbiAgICAgICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zb2xlLmxvZyhgVG9nZ2xpbmcgY2lyY2xlIGF0ICgke2dyaWRYfSwke2dyaWRZfSlgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBJZiB3ZSBnZXQgaGVyZSwgdGhlIGNsaWNrIHdhc24ndCBvbiBhIGNpcmNsZSwgc28gdHJlYXQgaXQgYXMgYSBjb25uZWN0b3IgY2xpY2tcbiAgICAvLyBEZXRlcm1pbmUgd2hpY2ggZ3JpZCBjZWxsIChib3R0b20tbGVmdCBvZiBhIDJ4MiBncm91cCkgdGhpcyBwb2ludCBpcyBjbG9zZXN0IHRvXG4gICAgY29uc3QgZ3JvdXBYID0gTWF0aC5mbG9vcigoY2xpY2tQb2ludC54IC0gY2VudGVyT2Zmc2V0LngpIC8gRklYRURfU1BBQ0lORyk7XG4gICAgY29uc3QgZ3JvdXBZID0gTWF0aC5mbG9vcigoY2xpY2tQb2ludC55IC0gY2VudGVyT2Zmc2V0LnkpIC8gRklYRURfU1BBQ0lORyk7XG4gICAgXG4gICAgLy8gR2V0IHRoZSBpbmRpY2VzIG9mIHRoZSBmb3VyIGNlbGxzIGluIHRoZSAyeDIgZ3JvdXBcbiAgICBjb25zdCBibEluZGV4ID0gZ2V0SW5kZXgoZ3JvdXBZLCBncm91cFgsIEdSSURfV0lEVEgpO1xuICAgIGNvbnN0IGJySW5kZXggPSBnZXRJbmRleChncm91cFksIGdyb3VwWCArIDEsIEdSSURfV0lEVEgpO1xuICAgIGNvbnN0IHRsSW5kZXggPSBnZXRJbmRleChncm91cFkgKyAxLCBncm91cFgsIEdSSURfV0lEVEgpO1xuICAgIGNvbnN0IHRySW5kZXggPSBnZXRJbmRleChncm91cFkgKyAxLCBncm91cFggKyAxLCBHUklEX1dJRFRIKTtcbiAgICBcbiAgICAvLyBDaGVjayB3aGljaCBjZWxscyBhcmUgd2l0aGluIGdyaWQgYm91bmRzXG4gICAgY29uc3QgaXNWYWxpZEdyb3VwID0gXG4gICAgICBncm91cFggPj0gMCAmJiBncm91cFggPCBHUklEX1dJRFRIIC0gMSAmJiBcbiAgICAgIGdyb3VwWSA+PSAwICYmIGdyb3VwWSA8IEdSSURfSEVJR0hUIC0gMTtcbiAgICBcbiAgICBpZiAoIWlzVmFsaWRHcm91cCkgcmV0dXJuO1xuICAgIFxuICAgIC8vIEdldCBhY3RpdmF0aW9uIHN0YXRlcyBmb3IgdGhlIGZvdXIgY2VsbHNcbiAgICBjb25zdCBibEFjdGl2ZSA9IGFjdGl2YXRpb25TdGF0ZVtibEluZGV4XSA9PT0gMS4wO1xuICAgIGNvbnN0IGJyQWN0aXZlID0gYWN0aXZhdGlvblN0YXRlW2JySW5kZXhdID09PSAxLjA7XG4gICAgY29uc3QgdGxBY3RpdmUgPSBhY3RpdmF0aW9uU3RhdGVbdGxJbmRleF0gPT09IDEuMDtcbiAgICBjb25zdCB0ckFjdGl2ZSA9IGFjdGl2YXRpb25TdGF0ZVt0ckluZGV4XSA9PT0gMS4wO1xuICAgIFxuICAgIC8vIEdldCB0aGUgd29ybGQgcG9zaXRpb25zIG9mIHRoZSBjZWxsIGNlbnRlcnNcbiAgICBjb25zdCBibFBvcyA9IGdldFdvcmxkUG9zaXRpb24oZ3JvdXBZLCBncm91cFgsIEdSSURfV0lEVEgsIEdSSURfSEVJR0hULCBGSVhFRF9TUEFDSU5HLCBjZW50ZXJPZmZzZXQpO1xuICAgIGNvbnN0IGJyUG9zID0gZ2V0V29ybGRQb3NpdGlvbihncm91cFksIGdyb3VwWCArIDEsIEdSSURfV0lEVEgsIEdSSURfSEVJR0hULCBGSVhFRF9TUEFDSU5HLCBjZW50ZXJPZmZzZXQpO1xuICAgIGNvbnN0IHRsUG9zID0gZ2V0V29ybGRQb3NpdGlvbihncm91cFkgKyAxLCBncm91cFgsIEdSSURfV0lEVEgsIEdSSURfSEVJR0hULCBGSVhFRF9TUEFDSU5HLCBjZW50ZXJPZmZzZXQpO1xuICAgIGNvbnN0IHRyUG9zID0gZ2V0V29ybGRQb3NpdGlvbihncm91cFkgKyAxLCBncm91cFggKyAxLCBHUklEX1dJRFRILCBHUklEX0hFSUdIVCwgRklYRURfU1BBQ0lORywgY2VudGVyT2Zmc2V0KTtcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgdGhlIGNlbnRlciBvZiB0aGUgMngyIGdyb3VwXG4gICAgY29uc3QgY2VudGVyWCA9IChibFBvcy54ICsgYnJQb3MueCArIHRsUG9zLnggKyB0clBvcy54KSAvIDQ7XG4gICAgY29uc3QgY2VudGVyWSA9IChibFBvcy55ICsgYnJQb3MueSArIHRsUG9zLnkgKyB0clBvcy55KSAvIDQ7XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIGRpc3RhbmNlIGZyb20gY2xpY2sgdG8gY2VudGVyIG9mIDJ4MiBncm91cFxuICAgIGNvbnN0IGRpc3RUb0NlbnRlciA9IE1hdGguc3FydChcbiAgICAgIE1hdGgucG93KGNsaWNrUG9pbnQueCAtIGNlbnRlclgsIDIpICsgXG4gICAgICBNYXRoLnBvdyhjbGlja1BvaW50LnkgLSBjZW50ZXJZLCAyKVxuICAgICk7XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgdGhlIGNsaWNrIGlzIGluIHRoZSBjZW50ZXIgem9uZSAoMzAlIG9mIGNlbGwgc3BhY2luZylcbiAgICBjb25zdCBpc0NlbnRlckNsaWNrID0gZGlzdFRvQ2VudGVyIDwgRklYRURfU1BBQ0lORyAqIDAuMyAqIHZpc3VhbFNjYWxlO1xuICAgIFxuICAgIC8vIEdldCB0aGUgcG9zc2libGUgZGlhZ29uYWwgY29ubmVjdG9yc1xuICAgIGNvbnN0IGNhblVzZURpYWdUTEJSID0gdGxBY3RpdmUgJiYgYnJBY3RpdmU7XG4gICAgY29uc3QgY2FuVXNlRGlhZ0JMVFIgPSBibEFjdGl2ZSAmJiB0ckFjdGl2ZTtcbiAgICBjb25zdCBoYXNEaWFnb25hbE9wdGlvbnMgPSBjYW5Vc2VEaWFnVExCUiB8fCBjYW5Vc2VEaWFnQkxUUjtcbiAgICBcbiAgICAvLyBHZXQgY3VycmVudCBpbnRlbmRlZCBjb25uZWN0b3JcbiAgICBjb25zdCBjdXJyZW50Q29ubmVjdG9yID0gZ2V0SW50ZW5kZWRDb25uZWN0b3IoZ3JvdXBYLCBncm91cFkpO1xuICAgIGNvbnN0IGdyb3VwS2V5ID0gZ2V0Q2VsbEdyb3VwS2V5KGdyb3VwWCwgZ3JvdXBZKTtcbiAgICBcbiAgICBsZXQgbmV3Q29ubmVjdG9yID0gQ09OTkVDVE9SX05PTkU7XG4gICAgXG4gICAgLy8gSWYgY2xpY2tlZCBpbiB0aGUgY2VudGVyIGFuZCBkaWFnb25hbCBjb25uZWN0b3JzIGFyZSBhdmFpbGFibGUsIGN5Y2xlIHRocm91Z2ggdGhlbVxuICAgIGlmIChpc0NlbnRlckNsaWNrICYmIGhhc0RpYWdvbmFsT3B0aW9ucykge1xuICAgICAgaWYgKGNhblVzZURpYWdUTEJSICYmIGNhblVzZURpYWdCTFRSKSB7XG4gICAgICAgIC8vIEJvdGggZGlhZ29uYWxzIGFyZSBhdmFpbGFibGUsIGN5Y2xlIHRocm91Z2ggdGhlIG9wdGlvbnM6IE5PTkUgLT4gVEwtQlIgLT4gQkwtVFIgLT4gTk9ORVxuICAgICAgICBpZiAoY3VycmVudENvbm5lY3RvciA9PT0gQ09OTkVDVE9SX05PTkUpIHtcbiAgICAgICAgICBuZXdDb25uZWN0b3IgPSBDT05ORUNUT1JfRElBR19UTF9CUjtcbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50Q29ubmVjdG9yID09PSBDT05ORUNUT1JfRElBR19UTF9CUikge1xuICAgICAgICAgIG5ld0Nvbm5lY3RvciA9IENPTk5FQ1RPUl9ESUFHX0JMX1RSO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0Nvbm5lY3RvciA9IENPTk5FQ1RPUl9OT05FO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNhblVzZURpYWdUTEJSKSB7XG4gICAgICAgIC8vIE9ubHkgVEwtQlIgZGlhZ29uYWwgaXMgYXZhaWxhYmxlLCB0b2dnbGUgaXRcbiAgICAgICAgbmV3Q29ubmVjdG9yID0gY3VycmVudENvbm5lY3RvciA9PT0gQ09OTkVDVE9SX0RJQUdfVExfQlIgPyBDT05ORUNUT1JfTk9ORSA6IENPTk5FQ1RPUl9ESUFHX1RMX0JSO1xuICAgICAgfSBlbHNlIGlmIChjYW5Vc2VEaWFnQkxUUikge1xuICAgICAgICAvLyBPbmx5IEJMLVRSIGRpYWdvbmFsIGlzIGF2YWlsYWJsZSwgdG9nZ2xlIGl0XG4gICAgICAgIG5ld0Nvbm5lY3RvciA9IGN1cnJlbnRDb25uZWN0b3IgPT09IENPTk5FQ1RPUl9ESUFHX0JMX1RSID8gQ09OTkVDVE9SX05PTkUgOiBDT05ORUNUT1JfRElBR19CTF9UUjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRm9yIGNsaWNrcyBvdXRzaWRlIHRoZSBjZW50ZXIsIHVzZSB0aGUgb3JpZ2luYWwgbG9naWNcbiAgICAgIC8vIERldGVybWluZSB3aGljaCBjb25uZWN0b3Igd2FzIGNsaWNrZWRcbiAgICAgIGxldCBjbGlja2VkVHlwZSA9IENPTk5FQ1RPUl9OT05FO1xuICAgICAgXG4gICAgICAvLyBDYWxjdWxhdGUgZGlzdGFuY2VzIGZyb20gY2xpY2sgdG8gZWFjaCBkaWFnb25hbFxuICAgICAgY29uc3QgZGlzdFRvQkxUUiA9IE1hdGguYWJzKChjbGlja1BvaW50LnggLSBibFBvcy54KSAqICh0clBvcy55IC0gYmxQb3MueSkgLSAoY2xpY2tQb2ludC55IC0gYmxQb3MueSkgKiAodHJQb3MueCAtIGJsUG9zLngpKSAvIFxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5zcXJ0KE1hdGgucG93KHRyUG9zLnggLSBibFBvcy54LCAyKSArIE1hdGgucG93KHRyUG9zLnkgLSBibFBvcy55LCAyKSk7XG4gICAgICBcbiAgICAgIGNvbnN0IGRpc3RUb1RMQlIgPSBNYXRoLmFicygoY2xpY2tQb2ludC54IC0gdGxQb3MueCkgKiAoYnJQb3MueSAtIHRsUG9zLnkpIC0gKGNsaWNrUG9pbnQueSAtIHRsUG9zLnkpICogKGJyUG9zLnggLSB0bFBvcy54KSkgLyBcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguc3FydChNYXRoLnBvdyhiclBvcy54IC0gdGxQb3MueCwgMikgKyBNYXRoLnBvdyhiclBvcy55IC0gdGxQb3MueSwgMikpO1xuICAgICAgXG4gICAgICAvLyBEZXRlcm1pbmUgaWYgY2xpY2sgaXMgY2xvc2VyIHRvIGhvcml6b250YWwgb3IgdmVydGljYWxcbiAgICAgIGNvbnN0IGNsaWNrT2Zmc2V0WCA9IGNsaWNrUG9pbnQueCAtIGNlbnRlclg7XG4gICAgICBjb25zdCBjbGlja09mZnNldFkgPSBjbGlja1BvaW50LnkgLSBjZW50ZXJZO1xuICAgICAgY29uc3QgaXNIb3Jpem9udGFsQ2xpY2sgPSBNYXRoLmFicyhjbGlja09mZnNldFkpIDwgTWF0aC5hYnMoY2xpY2tPZmZzZXRYKTtcbiAgICAgIGNvbnN0IGlzVG9wSGFsZiA9IGNsaWNrT2Zmc2V0WSA+IDA7XG4gICAgICBcbiAgICAgIGlmIChkaXN0VG9CTFRSIDwgZGlzdFRvVExCUikge1xuICAgICAgICAvLyBDbG9zZXIgdG8gQkwtVFIgZGlhZ29uYWwgKC8pXG4gICAgICAgIGlmIChibEFjdGl2ZSAmJiB0ckFjdGl2ZSkge1xuICAgICAgICAgIGNsaWNrZWRUeXBlID0gQ09OTkVDVE9SX0RJQUdfQkxfVFI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENsb3NlciB0byBUTC1CUiBkaWFnb25hbCAoXFwpXG4gICAgICAgIGlmICh0bEFjdGl2ZSAmJiBickFjdGl2ZSkge1xuICAgICAgICAgIGNsaWNrZWRUeXBlID0gQ09OTkVDVE9SX0RJQUdfVExfQlI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gSG9yaXpvbnRhbCBjb25uZWN0b3IgbG9naWNcbiAgICAgIGlmIChpc0hvcml6b250YWxDbGljaykge1xuICAgICAgICBpZiAoaXNUb3BIYWxmKSB7XG4gICAgICAgICAgLy8gVG9wIGhvcml6b250YWxcbiAgICAgICAgICBpZiAodGxBY3RpdmUgJiYgdHJBY3RpdmUpIHtcbiAgICAgICAgICAgIGNsaWNrZWRUeXBlID0gQ09OTkVDVE9SX0hPUklaX1Q7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEJvdHRvbSBob3Jpem9udGFsXG4gICAgICAgICAgaWYgKGJsQWN0aXZlICYmIGJyQWN0aXZlKSB7XG4gICAgICAgICAgICBjbGlja2VkVHlwZSA9IENPTk5FQ1RPUl9IT1JJWl9CO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBUb2dnbGUgbG9naWMgLSBpZiB0aGUgY2xpY2tlZCBjb25uZWN0b3IgaXMgYWxyZWFkeSBhY3RpdmUsIHR1cm4gaXQgb2ZmXG4gICAgICAvLyBPdGhlcndpc2UsIHR1cm4gb2ZmIGFueSBjdXJyZW50IGNvbm5lY3RvciBhbmQgdHVybiBvbiB0aGUgY2xpY2tlZCBvbmVcbiAgICAgIGlmIChjdXJyZW50Q29ubmVjdG9yID09PSBjbGlja2VkVHlwZSkge1xuICAgICAgICBuZXdDb25uZWN0b3IgPSBDT05ORUNUT1JfTk9ORTsgLy8gVG9nZ2xlIG9mZlxuICAgICAgfSBlbHNlIGlmIChjbGlja2VkVHlwZSAhPT0gQ09OTkVDVE9SX05PTkUpIHtcbiAgICAgICAgbmV3Q29ubmVjdG9yID0gY2xpY2tlZFR5cGU7IC8vIFRvZ2dsZSBvbiBuZXcgY29ubmVjdG9yXG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIFVwZGF0ZSB0aGUgaW50ZW5kZWQgY29ubmVjdG9yXG4gICAgc2V0SW50ZW5kZWRDb25uZWN0b3JzKHByZXYgPT4gKHtcbiAgICAgIC4uLnByZXYsXG4gICAgICBbZ3JvdXBLZXldOiBuZXdDb25uZWN0b3JcbiAgICB9KSk7XG4gICAgXG4gICAgY29uc29sZS5sb2coYENsaWNrZWQgY2VsbCBncm91cCAoJHtncm91cFh9LCR7Z3JvdXBZfSksIHNldHRpbmcgY29ubmVjdG9yIHRvICR7bmV3Q29ubmVjdG9yfWApO1xuICAgIFxuICB9LCBbR1JJRF9XSURUSCwgR1JJRF9IRUlHSFQsIEZJWEVEX1NQQUNJTkcsIGNlbnRlck9mZnNldCwgYWN0aXZhdGlvblN0YXRlLCBpbnRlbmRlZENvbm5lY3RvcnMsIHZpc3VhbFNjYWxlXSk7XG5cbiAgLy8gUmVzZXQgY29ubmVjdG9yIGludGVudCB3aGVuIGEgY2lyY2xlIGlzIGRlYWN0aXZhdGVkXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gQ2hlY2sgYWxsIGNlbGwgZ3JvdXBzXG4gICAgY29uc3QgbmV3SW50ZW5kZWRDb25uZWN0b3JzID0geyAuLi5pbnRlbmRlZENvbm5lY3RvcnMgfTtcbiAgICBjb25zdCBuZXdDbWRIb3JpekNvbm5lY3RvcnMgPSB7IC4uLmNtZEhvcml6Q29ubmVjdG9ycyB9O1xuICAgIGxldCBoYXNDaGFuZ2VzID0gZmFsc2U7XG4gICAgbGV0IGhhc0NtZEhvcml6Q2hhbmdlcyA9IGZhbHNlO1xuICAgIFxuICAgIC8vIEZpcnN0IGNoZWNrIHJlZ3VsYXIgY29ubmVjdG9yc1xuICAgIGZvciAoY29uc3Qga2V5IGluIGludGVuZGVkQ29ubmVjdG9ycykge1xuICAgICAgY29uc3QgY29ubmVjdG9yID0gaW50ZW5kZWRDb25uZWN0b3JzW2tleV07XG4gICAgICBpZiAoY29ubmVjdG9yID09PSBDT05ORUNUT1JfTk9ORSkgY29udGludWU7XG4gICAgICBcbiAgICAgIC8vIFBhcnNlIHgseSBmcm9tIGtleVxuICAgICAgY29uc3QgW3gsIHldID0ga2V5LnNwbGl0KCcsJykubWFwKE51bWJlcik7XG4gICAgICBcbiAgICAgIC8vIEdldCB0aGUgaW5kaWNlcyBvZiB0aGUgZm91ciBjZWxsc1xuICAgICAgY29uc3QgYmxJbmRleCA9IGdldEluZGV4KHksIHgsIEdSSURfV0lEVEgpO1xuICAgICAgY29uc3QgYnJJbmRleCA9IGdldEluZGV4KHksIHggKyAxLCBHUklEX1dJRFRIKTtcbiAgICAgIGNvbnN0IHRsSW5kZXggPSBnZXRJbmRleCh5ICsgMSwgeCwgR1JJRF9XSURUSCk7XG4gICAgICBjb25zdCB0ckluZGV4ID0gZ2V0SW5kZXgoeSArIDEsIHggKyAxLCBHUklEX1dJRFRIKTtcbiAgICAgIFxuICAgICAgLy8gR2V0IGFjdGl2YXRpb24gc3RhdGVzXG4gICAgICBjb25zdCBibEFjdGl2ZSA9IGFjdGl2YXRpb25TdGF0ZVtibEluZGV4XSA9PT0gMS4wO1xuICAgICAgY29uc3QgYnJBY3RpdmUgPSBhY3RpdmF0aW9uU3RhdGVbYnJJbmRleF0gPT09IDEuMDtcbiAgICAgIGNvbnN0IHRsQWN0aXZlID0gYWN0aXZhdGlvblN0YXRlW3RsSW5kZXhdID09PSAxLjA7XG4gICAgICBjb25zdCB0ckFjdGl2ZSA9IGFjdGl2YXRpb25TdGF0ZVt0ckluZGV4XSA9PT0gMS4wO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiB0aGUgY29ubmVjdG9yIGlzIHN0aWxsIHZhbGlkXG4gICAgICBsZXQgaXNWYWxpZCA9IHRydWU7XG4gICAgICBcbiAgICAgIHN3aXRjaCAoY29ubmVjdG9yKSB7XG4gICAgICAgIGNhc2UgQ09OTkVDVE9SX0RJQUdfVExfQlI6XG4gICAgICAgICAgaXNWYWxpZCA9IHRsQWN0aXZlICYmIGJyQWN0aXZlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIENPTk5FQ1RPUl9ESUFHX0JMX1RSOlxuICAgICAgICAgIGlzVmFsaWQgPSBibEFjdGl2ZSAmJiB0ckFjdGl2ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBDT05ORUNUT1JfSE9SSVpfVDpcbiAgICAgICAgICBpc1ZhbGlkID0gdGxBY3RpdmUgJiYgdHJBY3RpdmU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ09OTkVDVE9SX0hPUklaX0I6XG4gICAgICAgICAgaXNWYWxpZCA9IGJsQWN0aXZlICYmIGJyQWN0aXZlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgbmV3SW50ZW5kZWRDb25uZWN0b3JzW2tleV0gPSBDT05ORUNUT1JfTk9ORTtcbiAgICAgICAgaGFzQ2hhbmdlcyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTm93IGNoZWNrIGNtZC1jbGljayBob3Jpem9udGFsIGNvbm5lY3RvcnNcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBjbWRIb3JpekNvbm5lY3RvcnMpIHtcbiAgICAgIGlmIChjbWRIb3JpekNvbm5lY3RvcnNba2V5XSA9PT0gMCkgY29udGludWU7XG5cbiAgICAgIC8vIFBhcnNlIHgseSBmcm9tIGtleSAocmVtb3ZlICdoY21kOicgcHJlZml4KVxuICAgICAgY29uc3QgW3gsIHldID0ga2V5LnN1YnN0cmluZyg1KS5zcGxpdCgnLCcpLm1hcChOdW1iZXIpO1xuXG4gICAgICAvLyBHZXQgaW5kaWNlcyBmb3IgbGVmdCBhbmQgcmlnaHQgY2lyY2xlc1xuICAgICAgY29uc3QgbGVmdEluZGV4ID0gZ2V0SW5kZXgoeSwgeCwgR1JJRF9XSURUSCk7XG4gICAgICBjb25zdCByaWdodEluZGV4ID0gZ2V0SW5kZXgoeSwgeCArIDEsIEdSSURfV0lEVEgpO1xuXG4gICAgICAvLyBDaGVjayBpZiBib3RoIGNpcmNsZXMgYXJlIHN0aWxsIGFjdGl2ZVxuICAgICAgY29uc3QgbGVmdEFjdGl2ZSA9IGFjdGl2YXRpb25TdGF0ZVtsZWZ0SW5kZXhdID09PSAxLjA7XG4gICAgICBjb25zdCByaWdodEFjdGl2ZSA9IGFjdGl2YXRpb25TdGF0ZVtyaWdodEluZGV4XSA9PT0gMS4wO1xuXG4gICAgICBpZiAoIWxlZnRBY3RpdmUgfHwgIXJpZ2h0QWN0aXZlKSB7XG4gICAgICAgIG5ld0NtZEhvcml6Q29ubmVjdG9yc1trZXldID0gMDtcbiAgICAgICAgaGFzQ21kSG9yaXpDaGFuZ2VzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgaWYgKGhhc0NoYW5nZXMpIHtcbiAgICAgIHNldEludGVuZGVkQ29ubmVjdG9ycyhuZXdJbnRlbmRlZENvbm5lY3RvcnMpO1xuICAgIH1cbiAgICBpZiAoaGFzQ21kSG9yaXpDaGFuZ2VzKSB7XG4gICAgICBzZXRDbWRIb3JpekNvbm5lY3RvcnMobmV3Q21kSG9yaXpDb25uZWN0b3JzKTtcbiAgICB9XG4gIH0sIFthY3RpdmF0aW9uU3RhdGUsIEdSSURfV0lEVEgsIGludGVuZGVkQ29ubmVjdG9ycywgY21kSG9yaXpDb25uZWN0b3JzXSk7XG5cbiAgLy8gQ3JlYXRlIGEgZGF0YSB0ZXh0dXJlIGZvciBpbnRlbmRlZCBjb25uZWN0b3JzXG4gIGNvbnN0IGludGVuZGVkQ29ubmVjdG9yVGV4dHVyZSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKGBDcmVhdGluZyBpbnRlbmRlZCBjb25uZWN0b3IgdGV4dHVyZTogJHtHUklEX1dJRFRILTF9eCR7R1JJRF9IRUlHSFQtMX1gKTtcbiAgICBcbiAgICAvLyBUZXh0dXJlIGhhcyBvbmUgcGl4ZWwgcGVyIDJ4MiBjZWxsIGdyb3VwIChncmlkIGNlbGxzIG1pbnVzIDEgaW4gZWFjaCBkaW1lbnNpb24pXG4gICAgY29uc3Qgd2lkdGggPSBNYXRoLm1heCgxLCBHUklEX1dJRFRIIC0gMSk7XG4gICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5tYXgoMSwgR1JJRF9IRUlHSFQgLSAxKTtcbiAgICBcbiAgICBjb25zdCB0ZXh0dXJlID0gbmV3IFRIUkVFLkRhdGFUZXh0dXJlKFxuICAgICAgbmV3IEZsb2F0MzJBcnJheSh3aWR0aCAqIGhlaWdodCkuZmlsbCgwLjApLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBUSFJFRS5SZWRGb3JtYXQsXG4gICAgICBUSFJFRS5GbG9hdFR5cGVcbiAgICApO1xuICAgIFxuICAgIHRleHR1cmUubWluRmlsdGVyID0gVEhSRUUuTmVhcmVzdEZpbHRlcjtcbiAgICB0ZXh0dXJlLm1hZ0ZpbHRlciA9IFRIUkVFLk5lYXJlc3RGaWx0ZXI7XG4gICAgdGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgXG4gICAgcmV0dXJuIHRleHR1cmU7XG4gIH0sIFtHUklEX1dJRFRILCBHUklEX0hFSUdIVF0pO1xuICBcbiAgLy8gVXBkYXRlIHRoZSBpbnRlbmRlZCBjb25uZWN0b3IgdGV4dHVyZSB3aGVuIHN0YXRlIGNoYW5nZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCB3aWR0aCA9IE1hdGgubWF4KDEsIEdSSURfV0lEVEggLSAxKTtcbiAgICBjb25zdCBkYXRhID0gbmV3IEZsb2F0MzJBcnJheSh3aWR0aCAqIE1hdGgubWF4KDEsIEdSSURfSEVJR0hUIC0gMSkpO1xuICAgIFxuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgR1JJRF9IRUlHSFQgLSAxOyB5KyspIHtcbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgR1JJRF9XSURUSCAtIDE7IHgrKykge1xuICAgICAgICBjb25zdCBpbmRleCA9IHkgKiB3aWR0aCArIHg7XG4gICAgICAgIGNvbnN0IGNvbm5lY3RvciA9IGdldEludGVuZGVkQ29ubmVjdG9yKHgsIHkpO1xuICAgICAgICBkYXRhW2luZGV4XSA9IGNvbm5lY3RvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgaWYgKGludGVuZGVkQ29ubmVjdG9yVGV4dHVyZSAmJiBkYXRhLmxlbmd0aCA9PT0gaW50ZW5kZWRDb25uZWN0b3JUZXh0dXJlLmltYWdlLmRhdGEubGVuZ3RoKSB7XG4gICAgICBpbnRlbmRlZENvbm5lY3RvclRleHR1cmUuaW1hZ2UuZGF0YS5zZXQoZGF0YSk7XG4gICAgICBpbnRlbmRlZENvbm5lY3RvclRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgfSwgW2ludGVuZGVkQ29ubmVjdG9ycywgR1JJRF9XSURUSCwgR1JJRF9IRUlHSFQsIGludGVuZGVkQ29ubmVjdG9yVGV4dHVyZV0pO1xuXG4gIC8vIENyZWF0ZSBob3Jpem9udGFsIGNtZC1jbGljayBjb25uZWN0b3IgdGV4dHVyZVxuICBjb25zdCBjbWRIb3JpekNvbm5lY3RvclRleHR1cmUgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBjb25zb2xlLmxvZyhgQ3JlYXRpbmcgY21kLWNsaWNrIGhvcml6b250YWwgY29ubmVjdG9yIHRleHR1cmU6ICR7R1JJRF9XSURUSC0xfXgke0dSSURfSEVJR0hUfWApO1xuICAgIFxuICAgIC8vIFRleHR1cmUgaGFzIG9uZSBwaXhlbCBwZXIgaG9yaXpvbnRhbCBjb25uZWN0aW9uIHBvc3NpYmlsaXR5XG4gICAgY29uc3Qgd2lkdGggPSBNYXRoLm1heCgxLCBHUklEX1dJRFRIIC0gMSk7XG4gICAgY29uc3QgaGVpZ2h0ID0gR1JJRF9IRUlHSFQ7XG4gICAgXG4gICAgY29uc3QgdGV4dHVyZSA9IG5ldyBUSFJFRS5EYXRhVGV4dHVyZShcbiAgICAgIG5ldyBGbG9hdDMyQXJyYXkod2lkdGggKiBoZWlnaHQpLmZpbGwoMC4wKSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgVEhSRUUuUmVkRm9ybWF0LFxuICAgICAgVEhSRUUuRmxvYXRUeXBlXG4gICAgKTtcbiAgICBcbiAgICB0ZXh0dXJlLm1pbkZpbHRlciA9IFRIUkVFLk5lYXJlc3RGaWx0ZXI7XG4gICAgdGV4dHVyZS5tYWdGaWx0ZXIgPSBUSFJFRS5OZWFyZXN0RmlsdGVyO1xuICAgIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIFxuICAgIHJldHVybiB0ZXh0dXJlO1xuICB9LCBbR1JJRF9XSURUSCwgR1JJRF9IRUlHSFRdKTtcbiAgXG4gIC8vIFVwZGF0ZSB0aGUgY21kLWNsaWNrIGhvcml6b250YWwgY29ubmVjdG9yIHRleHR1cmUgd2hlbiBzdGF0ZSBjaGFuZ2VzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3Qgd2lkdGggPSBNYXRoLm1heCgxLCBHUklEX1dJRFRIIC0gMSk7XG4gICAgY29uc3QgZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkod2lkdGggKiBHUklEX0hFSUdIVCk7XG4gICAgXG4gICAgY29uc29sZS5sb2coJ1VwZGF0aW5nIGNtZC1ob3JpeiBjb25uZWN0b3IgdGV4dHVyZTonLCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodDogR1JJRF9IRUlHSFQsXG4gICAgICBjb25uZWN0b3JzOiBjbWRIb3JpekNvbm5lY3RvcnNcbiAgICB9KTtcbiAgICBcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IEdSSURfSEVJR0hUOyB5KyspIHtcbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICBjb25zdCBrZXkgPSBnZXRIb3JpekNtZENvbm5lY3RvcktleSh4LCB5KTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBjbWRIb3JpekNvbm5lY3RvcnNba2V5XSB8fCAwO1xuICAgICAgICBkYXRhW3kgKiB3aWR0aCArIHhdID0gdmFsdWU7XG4gICAgICAgIFxuICAgICAgICBpZiAodmFsdWUgPiAwKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ0ZvdW5kIGFjdGl2ZSBjb25uZWN0b3I6JywgeyB4LCB5LCBrZXksIHZhbHVlIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGlmIChjbWRIb3JpekNvbm5lY3RvclRleHR1cmUgJiYgZGF0YS5sZW5ndGggPT09IGNtZEhvcml6Q29ubmVjdG9yVGV4dHVyZS5pbWFnZS5kYXRhLmxlbmd0aCkge1xuICAgICAgY21kSG9yaXpDb25uZWN0b3JUZXh0dXJlLmltYWdlLmRhdGEuc2V0KGRhdGEpO1xuICAgICAgY21kSG9yaXpDb25uZWN0b3JUZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUubG9nKCdVcGRhdGVkIGNtZC1ob3JpeiBjb25uZWN0b3IgdGV4dHVyZSBkYXRhJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybignU2tpcHBpbmcgY21kLWhvcml6IHRleHR1cmUgdXBkYXRlOiBzaXplIG1pc21hdGNoIG9yIHRleHR1cmUgbm90IHJlYWR5Jywge1xuICAgICAgICB0ZXh0dXJlU2l6ZTogY21kSG9yaXpDb25uZWN0b3JUZXh0dXJlPy5pbWFnZS5kYXRhLmxlbmd0aCxcbiAgICAgICAgZGF0YVNpemU6IGRhdGEubGVuZ3RoXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFtjbWRIb3JpekNvbm5lY3RvcnMsIEdSSURfV0lEVEgsIEdSSURfSEVJR0hULCBjbWRIb3JpekNvbm5lY3RvclRleHR1cmVdKTtcblxuICAvLyBSZWYgZm9yIHRoZSBuZXcgbWF0ZXJpYWxcbiAgY29uc3QgY21kSG9yaXpNYXRlcmlhbFJlZiA9IHVzZVJlZjxhbnk+KG51bGwpO1xuXG4gIHJldHVybiAoXG4gICAgPGdyb3VwPlxuICAgICAgPGluc3RhbmNlZE1lc2ggXG4gICAgICAgIHJlZj17bWVzaFJlZn0gXG4gICAgICAgIGFyZ3M9e1t1bmRlZmluZWQsIHVuZGVmaW5lZCwgVE9UQUxfQ0lSQ0xFU119XG4gICAgICAgIGtleT17YGNpcmNsZXMtJHtUT1RBTF9DSVJDTEVTfWB9XG4gICAgICAgIG9uQ2xpY2s9e2hhbmRsZUNpcmNsZUNsaWNrfSAvLyBBdHRhY2ggY2xpY2sgaGFuZGxlclxuICAgICAgICBwb3NpdGlvbj17WzAsIDAsIC0wLjFdfSAvLyBQb3NpdGlvbiBjaXJjbGVzIGJlaGluZCBjb25uZWN0b3JzXG4gICAgICA+XG4gICAgICAgIHsvKiBQYXNzIGFyZ3MgZGlyZWN0bHkgdG8gZml4IFR5cGVTY3JpcHQgZXJyb3IgKi99XG4gICAgICAgIDxwbGFuZUdlb21ldHJ5IGFyZ3M9e1sxLCAxXX0+IFxuICAgICAgICAgIHsvKiBBdHRhY2ggdGhlIGluc3RhbmNlZCBidWZmZXIgYXR0cmlidXRlIGZvciBhY3RpdmF0aW9uIHN0YXRlICovfVxuICAgICAgICAgIDxpbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGVcbiAgICAgICAgICAgIHJlZj17YWN0aXZhdGlvbkF0dHJpYnV0ZVJlZn1cbiAgICAgICAgICAgIGF0dGFjaD1cImF0dHJpYnV0ZXMtYV9hY3RpdmF0ZWRcIlxuICAgICAgICAgICAgYXJncz17W2FjdGl2YXRpb25TdGF0ZSwgMV19IC8vIFBhc3MgaW5pdGlhbCBzdGF0ZSwgaXRlbSBzaXplIDFcbiAgICAgICAgICAgIHVzYWdlPXtUSFJFRS5EeW5hbWljRHJhd1VzYWdlfSAvLyBNYXJrIGFzIGR5bmFtaWNcbiAgICAgICAgICAvPlxuICAgICAgICA8L3BsYW5lR2VvbWV0cnk+IFxuICAgICAgICA8Y2lyY2xlTWF0ZXJpYWwgXG4gICAgICAgICAgICByZWY9e21hdGVyaWFsUmVmfSBcbiAgICAgICAgICAgIHRyYW5zcGFyZW50PXt0cnVlfSBcbiAgICAgICAgICAgIGtleT17Q2lyY2xlTWF0ZXJpYWwua2V5fSAvLyBBZGQga2V5IGZvciBtYXRlcmlhbCBob3Rzd2FwcGluZyBpZiBuZWVkZWRcbiAgICAgICAgLz5cbiAgICAgIDwvaW5zdGFuY2VkTWVzaD5cblxuICAgICAgey8qIE1haW4gQ29ubmVjdG9yIFBsYW5lIChFeGlzdGluZykgKi99XG4gICAgICA8bWVzaFxuICAgICAgICBwb3NpdGlvbj17WzAsIDAsIDAuMV19IC8vIEtlZXAgdGhpcyBzbGlnaHRseSBpbiBmcm9udCBvZiBjaXJjbGVzXG4gICAgICAgIGtleT17YGNvbm5lY3Rvci1wbGFuZS0ke0dSSURfV0lEVEh9LSR7R1JJRF9IRUlHSFR9LSR7dmlzdWFsU2NhbGV9YH1cbiAgICAgICAgb25DbGljaz17aGFuZGxlQ29ubmVjdG9yQ2xpY2t9IFxuICAgICAgPlxuICAgICAgICA8cGxhbmVHZW9tZXRyeSBhcmdzPXtbcGxhbmVXaWR0aCwgcGxhbmVIZWlnaHRdfSAvPlxuICAgICAgICA8Y29ubmVjdG9yTWF0ZXJpYWwgXG4gICAgICAgICAgcmVmPXtjb25uZWN0b3JNYXRlcmlhbFJlZn1cbiAgICAgICAgICBrZXk9e0Nvbm5lY3Rvck1hdGVyaWFsLmtleX1cbiAgICAgICAgICB0cmFuc3BhcmVudD17dHJ1ZX0gXG4gICAgICAgICAgc2lkZT17VEhSRUUuRG91YmxlU2lkZX0gXG4gICAgICAgICAgLy8gUGFzcyByZXF1aXJlZCB1bmlmb3JtcyAoY21kSG9yaXogdGV4dHVyZSByZW1vdmVkKVxuICAgICAgICAgIHVfc3RhdGVUZXh0dXJlPXtzdGF0ZVRleHR1cmV9IFxuICAgICAgICAgIHVfaW50ZW5kZWRDb25uZWN0b3JUZXh0dXJlPXtpbnRlbmRlZENvbm5lY3RvclRleHR1cmV9XG4gICAgICAgICAgLy8gdV9jbWRIb3JpekNvbm5lY3RvclRleHR1cmUgcmVtb3ZlZFxuICAgICAgICAgIHVfZ3JpZERpbWVuc2lvbnM9e1tHUklEX1dJRFRILCBHUklEX0hFSUdIVF19XG4gICAgICAgICAgdV90ZXh0dXJlUmVzb2x1dGlvbj17W0dSSURfV0lEVEgsIEdSSURfSEVJR0hUXX0gXG4gICAgICAgICAgdV9yYWRpdXNBPXtCQVNFX1JBRElVU19BfVxuICAgICAgICAgIHVfcmFkaXVzQj17QkFTRV9SQURJVVNfQn1cbiAgICAgICAgICB1X2dyaWRTcGFjaW5nPXt2aXN1YWxTY2FsZX1cbiAgICAgICAgICB1X2NlbnRlck9mZnNldD17W2NlbnRlck9mZnNldC54LCBjZW50ZXJPZmZzZXQueV19XG4gICAgICAgICAgdV9wbGFuZVNpemU9e1twbGFuZVdpZHRoLCBwbGFuZUhlaWdodF19XG4gICAgICAgIC8+XG4gICAgICA8L21lc2g+XG5cbiAgICAgIHsvKiBOZXcgQ21kLUNsaWNrIEhvcml6b250YWwgQ29ubmVjdG9yIFBsYW5lICovfVxuICAgICAgPG1lc2hcbiAgICAgICAgcG9zaXRpb249e1swLCAwLCAwLjJdfSAvLyBQb3NpdGlvbiB0aGlzIHNsaWdodGx5IGluIGZyb250IG9mIHRoZSBtYWluIGNvbm5lY3RvcnNcbiAgICAgICAga2V5PXtgY21kLWhvcml6LWNvbm5lY3Rvci1wbGFuZS0ke0dSSURfV0lEVEh9LSR7R1JJRF9IRUlHSFR9LSR7dmlzdWFsU2NhbGV9YH1cbiAgICAgICAgLy8gTm8gY2xpY2sgaGFuZGxlciBuZWVkZWQgaGVyZSwgaW50ZXJhY3Rpb24gaXMgdmlhIGNpcmNsZXNcbiAgICAgID5cbiAgICAgICAgey8qIFVzZSB0aGUgc2FtZSBwbGFuZSBnZW9tZXRyeSBkaW1lbnNpb25zICovfVxuICAgICAgICA8cGxhbmVHZW9tZXRyeSBhcmdzPXtbcGxhbmVXaWR0aCwgcGxhbmVIZWlnaHRdfSAvPiBcbiAgICAgICAgPGNtZEhvcml6Q29ubmVjdG9yTWF0ZXJpYWxcbiAgICAgICAgICByZWY9e2NtZEhvcml6TWF0ZXJpYWxSZWZ9XG4gICAgICAgICAga2V5PXtDbWRIb3JpekNvbm5lY3Rvck1hdGVyaWFsLmtleX1cbiAgICAgICAgICB0cmFuc3BhcmVudD17dHJ1ZX1cbiAgICAgICAgICBzaWRlPXtUSFJFRS5Eb3VibGVTaWRlfVxuICAgICAgICAgIC8vIFBhc3MgbmVjZXNzYXJ5IHVuaWZvcm1zIGZvciB0aGlzIHNwZWNpZmljIG1hdGVyaWFsXG4gICAgICAgICAgdV9zdGF0ZVRleHR1cmU9e3N0YXRlVGV4dHVyZX0gICAgICAgICAgICAgICAgIC8vIE5lZWQgZm9yIGNoZWNraW5nIGFjdGl2ZSBjaXJjbGVzXG4gICAgICAgICAgdV9jbWRIb3JpekNvbm5lY3RvclRleHR1cmU9e2NtZEhvcml6Q29ubmVjdG9yVGV4dHVyZX0gLy8gVGhlIHRleHR1cmUgd2l0aCBjbWQtaG9yaXogc3RhdGVcbiAgICAgICAgICB1X2dyaWREaW1lbnNpb25zPXtbR1JJRF9XSURUSCwgR1JJRF9IRUlHSFRdfSAgLy8gR3JpZCBkaW1lbnNpb25zXG4gICAgICAgICAgdV90ZXh0dXJlUmVzb2x1dGlvbj17W0dSSURfV0lEVEgsIEdSSURfSEVJR0hUXX0gLy8gU3RhdGUgdGV4dHVyZSByZXNvbHV0aW9uXG4gICAgICAgICAgdV9yYWRpdXNBPXtCQVNFX1JBRElVU19BfSAgICAgICAgICAgICAgICAgICAgIC8vIEJhc2UgcmFkaWlcbiAgICAgICAgICB1X3JhZGl1c0I9e0JBU0VfUkFESVVTX0J9XG4gICAgICAgICAgdV9ncmlkU3BhY2luZz17dmlzdWFsU2NhbGV9ICAgICAgICAgICAgICAgICAgIC8vIEN1cnJlbnQgdmlzdWFsIHNjYWxlXG4gICAgICAgICAgdV9jZW50ZXJPZmZzZXQ9e1tjZW50ZXJPZmZzZXQueCwgY2VudGVyT2Zmc2V0LnldfSAvLyBHcmlkIG9mZnNldFxuICAgICAgICAgIHVfcGxhbmVTaXplPXtbcGxhbmVXaWR0aCwgcGxhbmVIZWlnaHRdfSAgICAgICAvLyBQbGFuZSBkaW1lbnNpb25zXG4gICAgICAgIC8+XG4gICAgICA8L21lc2g+XG5cbiAgICA8L2dyb3VwPlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgR3JpZFNjZW5lOyAiXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VNZW1vIiwidXNlUmVmIiwidXNlRWZmZWN0IiwidXNlU3RhdGUiLCJ1c2VDYWxsYmFjayIsIlRIUkVFIiwidXNlQ29udHJvbHMiLCJDaXJjbGVNYXRlcmlhbCIsIkNvbm5lY3Rvck1hdGVyaWFsIiwiQ21kSG9yaXpDb25uZWN0b3JNYXRlcmlhbCIsIkJBU0VfR1JJRF9TUEFDSU5HIiwiQkFTRV9SQURJVVNfQSIsIkJBU0VfUkFESVVTX0IiLCJGSVhFRF9TUEFDSU5HIiwiZ2V0SW5kZXgiLCJyb3ciLCJjb2wiLCJncmlkV2lkdGgiLCJnZXRDb29yZHMiLCJpbmRleCIsIk1hdGgiLCJmbG9vciIsImdldENlbnRlck9mZnNldCIsImdyaWRIZWlnaHQiLCJzcGFjaW5nIiwidG90YWxXaWR0aCIsInRvdGFsSGVpZ2h0IiwiVmVjdG9yMiIsImdldFdvcmxkUG9zaXRpb24iLCJjZW50ZXJPZmZzZXQiLCJ4IiwieSIsIkNPTk5FQ1RPUl9OT05FIiwiQ09OTkVDVE9SX0RJQUdfVExfQlIiLCJDT05ORUNUT1JfRElBR19CTF9UUiIsIkNPTk5FQ1RPUl9IT1JJWl9UIiwiQ09OTkVDVE9SX0hPUklaX0IiLCJDT05ORUNUT1JfSE9SSVpfQ01EIiwiZHVtbXkiLCJPYmplY3QzRCIsInRlbXBNYXRyaXgiLCJNYXRyaXg0IiwidGVtcFZlYyIsIlZlY3RvcjMiLCJnZXRIb3JpekNtZENvbm5lY3RvcktleSIsIkdyaWRTY2VuZSIsIkdSSURfV0lEVEgiLCJHUklEX0hFSUdIVCIsInZpc3VhbFNjYWxlIiwidmFsdWUiLCJtaW4iLCJtYXgiLCJzdGVwIiwibGFiZWwiLCJUT1RBTF9DSVJDTEVTIiwicGxhbmVXaWR0aCIsInBsYW5lSGVpZ2h0IiwidG90YWwiLCJvZmZzZXQiLCJ3aWR0aCIsImhlaWdodCIsImNvbnNvbGUiLCJsb2ciLCJ0b0ZpeGVkIiwibWVzaFJlZiIsIm1hdGVyaWFsUmVmIiwiYWN0aXZhdGlvbkF0dHJpYnV0ZVJlZiIsImNvbm5lY3Rvck1hdGVyaWFsUmVmIiwiYWN0aXZhdGlvblN0YXRlIiwic2V0QWN0aXZhdGlvblN0YXRlIiwiRmxvYXQzMkFycmF5IiwiZmlsbCIsImNtZEhvcml6Q29ubmVjdG9ycyIsInNldENtZEhvcml6Q29ubmVjdG9ycyIsImN1cnJlbnQiLCJhcnJheSIsIm5lZWRzVXBkYXRlIiwicG9zaXRpb24iLCJzZXQiLCJjdXJyZW50TWF0cml4IiwiZ2V0TWF0cml4QXQiLCJxdWF0ZXJuaW9uIiwiUXVhdGVybmlvbiIsInNjYWxlVmVjIiwiZGVjb21wb3NlIiwibWF0cml4IiwiY29tcG9zZSIsInNldE1hdHJpeEF0IiwiaW5zdGFuY2VNYXRyaXgiLCJ1bmlmb3JtcyIsInVfcmFkaXVzQSIsInVfcmFkaXVzQiIsInNjYWxlIiwic2V0RnJvbU1hdHJpeFBvc2l0aW9uIiwic2V0RnJvbVJvdGF0aW9uTWF0cml4IiwiaGFuZGxlQ2lyY2xlQ2xpY2siLCJldmVudCIsInN0b3BQcm9wYWdhdGlvbiIsImluc3RhbmNlSWQiLCJ1bmRlZmluZWQiLCJpc0NtZENsaWNrIiwibWV0YUtleSIsImN0cmxLZXkiLCJwb2ludCIsImN1cnJlbnRTdGF0ZSIsImluc3RhbmNlQ2VudGVyIiwiZGlzdEZyb21DZW50ZXIiLCJkaXN0YW5jZVRvIiwiY3VycmVudElubmVyUmFkaXVzIiwiaXNJbnNpZGUiLCJyaWdodEluZGV4IiwiY2FuQ29ubmVjdCIsImxlZnRBY3RpdmUiLCJyaWdodEFjdGl2ZSIsImNvbm5lY3RvcktleSIsImtleSIsImN1cnJlbnRWYWx1ZSIsInByZXYiLCJuZXdWYWx1ZSIsIm5ld1N0YXRlIiwiYWxsQ29ubmVjdG9ycyIsIm9sZFZhbHVlIiwic3RhdGVUZXh0dXJlIiwidGV4dHVyZSIsIkRhdGFUZXh0dXJlIiwiUmVkRm9ybWF0IiwiRmxvYXRUeXBlIiwibWluRmlsdGVyIiwiTmVhcmVzdEZpbHRlciIsIm1hZ0ZpbHRlciIsImxlbmd0aCIsImltYWdlIiwiZGF0YSIsIndhcm4iLCJpbnRlbmRlZENvbm5lY3RvcnMiLCJzZXRJbnRlbmRlZENvbm5lY3RvcnMiLCJnZXRDZWxsR3JvdXBLZXkiLCJjZWxsWCIsImNlbGxZIiwiZ2V0SW50ZW5kZWRDb25uZWN0b3IiLCJoYW5kbGVDb25uZWN0b3JDbGljayIsImNsaWNrUG9pbnQiLCJncmlkWCIsInJvdW5kIiwiZ3JpZFkiLCJjZWxsQ2VudGVyIiwic3FydCIsInBvdyIsIm5ld0Nvbm5lY3RvcnMiLCJncm91cFgiLCJncm91cFkiLCJibEluZGV4IiwiYnJJbmRleCIsInRsSW5kZXgiLCJ0ckluZGV4IiwiaXNWYWxpZEdyb3VwIiwiYmxBY3RpdmUiLCJickFjdGl2ZSIsInRsQWN0aXZlIiwidHJBY3RpdmUiLCJibFBvcyIsImJyUG9zIiwidGxQb3MiLCJ0clBvcyIsImNlbnRlclgiLCJjZW50ZXJZIiwiZGlzdFRvQ2VudGVyIiwiaXNDZW50ZXJDbGljayIsImNhblVzZURpYWdUTEJSIiwiY2FuVXNlRGlhZ0JMVFIiLCJoYXNEaWFnb25hbE9wdGlvbnMiLCJjdXJyZW50Q29ubmVjdG9yIiwiZ3JvdXBLZXkiLCJuZXdDb25uZWN0b3IiLCJjbGlja2VkVHlwZSIsImRpc3RUb0JMVFIiLCJhYnMiLCJkaXN0VG9UTEJSIiwiY2xpY2tPZmZzZXRYIiwiY2xpY2tPZmZzZXRZIiwiaXNIb3Jpem9udGFsQ2xpY2siLCJpc1RvcEhhbGYiLCJuZXdJbnRlbmRlZENvbm5lY3RvcnMiLCJuZXdDbWRIb3JpekNvbm5lY3RvcnMiLCJoYXNDaGFuZ2VzIiwiaGFzQ21kSG9yaXpDaGFuZ2VzIiwiY29ubmVjdG9yIiwic3BsaXQiLCJtYXAiLCJOdW1iZXIiLCJpc1ZhbGlkIiwic3Vic3RyaW5nIiwibGVmdEluZGV4IiwiaW50ZW5kZWRDb25uZWN0b3JUZXh0dXJlIiwiY21kSG9yaXpDb25uZWN0b3JUZXh0dXJlIiwiY29ubmVjdG9ycyIsInRleHR1cmVTaXplIiwiZGF0YVNpemUiLCJjbWRIb3Jpek1hdGVyaWFsUmVmIiwiZ3JvdXAiLCJpbnN0YW5jZWRNZXNoIiwicmVmIiwiYXJncyIsIm9uQ2xpY2siLCJwbGFuZUdlb21ldHJ5IiwiaW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlIiwiYXR0YWNoIiwidXNhZ2UiLCJEeW5hbWljRHJhd1VzYWdlIiwiY2lyY2xlTWF0ZXJpYWwiLCJ0cmFuc3BhcmVudCIsIm1lc2giLCJjb25uZWN0b3JNYXRlcmlhbCIsInNpZGUiLCJEb3VibGVTaWRlIiwidV9zdGF0ZVRleHR1cmUiLCJ1X2ludGVuZGVkQ29ubmVjdG9yVGV4dHVyZSIsInVfZ3JpZERpbWVuc2lvbnMiLCJ1X3RleHR1cmVSZXNvbHV0aW9uIiwidV9ncmlkU3BhY2luZyIsInVfY2VudGVyT2Zmc2V0IiwidV9wbGFuZVNpemUiLCJjbWRIb3JpekNvbm5lY3Rvck1hdGVyaWFsIiwidV9jbWRIb3JpekNvbm5lY3RvclRleHR1cmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/GridScene.tsx\n");

/***/ }),

/***/ "./pages/index.js":
/*!************************!*\
  !*** ./pages/index.js ***!
  \************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-three/fiber */ \"@react-three/fiber\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-three/drei */ \"@react-three/drei\");\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_react_three_drei__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var leva__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! leva */ \"leva\");\n/* harmony import */ var leva__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(leva__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _components_GridScene__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../components/GridScene */ \"./components/GridScene.tsx\");\n/* harmony import */ var _styles_Home_module_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../styles/Home.module.css */ \"./styles/Home.module.css\");\n/* harmony import */ var _styles_Home_module_css__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_6__);\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_components_GridScene__WEBPACK_IMPORTED_MODULE_5__]);\n_components_GridScene__WEBPACK_IMPORTED_MODULE_5__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n\n\n // Adjust path if necessary\n // Assuming you have this for styling\nconst App = ()=>{\n    // Leva controls for camera zoom\n    const { cameraZoom } = (0,leva__WEBPACK_IMPORTED_MODULE_4__.useControls)({\n        cameraZoom: {\n            value: 50,\n            min: 10,\n            max: 200,\n            step: 1\n        }\n    });\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_6___default().container),\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(leva__WEBPACK_IMPORTED_MODULE_4__.Leva, {\n                collapsed: true\n            }, void 0, false, {\n                fileName: \"/Users/ian/cursor_projects/webGL_meta/pages/index.js\",\n                lineNumber: 16,\n                columnNumber: 7\n            }, undefined),\n            \" \",\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.Canvas, {\n                style: {\n                    position: \"absolute\",\n                    top: 0,\n                    left: 0,\n                    width: \"100%\",\n                    height: \"100%\"\n                },\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_react_three_drei__WEBPACK_IMPORTED_MODULE_3__.OrthographicCamera, {\n                        makeDefault: true,\n                        zoom: cameraZoom,\n                        position: [\n                            0,\n                            0,\n                            100\n                        ],\n                        near: 0.1,\n                        far: 1000\n                    }, void 0, false, {\n                        fileName: \"/Users/ian/cursor_projects/webGL_meta/pages/index.js\",\n                        lineNumber: 21,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ambientLight\", {\n                        intensity: 1.0\n                    }, void 0, false, {\n                        fileName: \"/Users/ian/cursor_projects/webGL_meta/pages/index.js\",\n                        lineNumber: 28,\n                        columnNumber: 9\n                    }, undefined),\n                    \" \",\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_GridScene__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {}, void 0, false, {\n                        fileName: \"/Users/ian/cursor_projects/webGL_meta/pages/index.js\",\n                        lineNumber: 31,\n                        columnNumber: 9\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/ian/cursor_projects/webGL_meta/pages/index.js\",\n                lineNumber: 17,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/ian/cursor_projects/webGL_meta/pages/index.js\",\n        lineNumber: 15,\n        columnNumber: 5\n    }, undefined);\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (App);\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWdlcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMEI7QUFDa0I7QUFDVztBQUNkO0FBQ08sQ0FBQywyQkFBMkI7QUFDN0IsQ0FBQyxxQ0FBcUM7QUFFckYsTUFBTU8sTUFBTTtJQUNWLGdDQUFnQztJQUNoQyxNQUFNLEVBQUVDLFVBQVUsRUFBRSxHQUFHSixpREFBV0EsQ0FBQztRQUNqQ0ksWUFBWTtZQUFFQyxPQUFPO1lBQUlDLEtBQUs7WUFBSUMsS0FBSztZQUFLQyxNQUFNO1FBQUU7SUFDdEQ7SUFFQSxxQkFDRSw4REFBQ0M7UUFBSUMsV0FBV1IsMEVBQWdCOzswQkFDOUIsOERBQUNILHNDQUFJQTtnQkFBQ2EsU0FBUzs7Ozs7O1lBQUc7MEJBQ2xCLDhEQUFDZixzREFBTUE7Z0JBQ0xnQixPQUFPO29CQUFFQyxVQUFVO29CQUFZQyxLQUFLO29CQUFHQyxNQUFNO29CQUFHQyxPQUFPO29CQUFRQyxRQUFRO2dCQUFPOztrQ0FHOUUsOERBQUNwQixpRUFBa0JBO3dCQUNqQnFCLFdBQVc7d0JBQ1hDLE1BQU1oQjt3QkFDTlUsVUFBVTs0QkFBQzs0QkFBRzs0QkFBRzt5QkFBSTt3QkFDckJPLE1BQU07d0JBQ05DLEtBQUs7Ozs7OztrQ0FFUCw4REFBQ0M7d0JBQWFDLFdBQVc7Ozs7OztvQkFBTztrQ0FHaEMsOERBQUN2Qiw2REFBU0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBT2xCO0FBRUEsaUVBQWVFLEdBQUdBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWJnbC1kb3QtZ3JpZC1tdnAvLi9wYWdlcy9pbmRleC5qcz9iZWU3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBDYW52YXMgfSBmcm9tICdAcmVhY3QtdGhyZWUvZmliZXInO1xuaW1wb3J0IHsgT3J0aG9ncmFwaGljQ2FtZXJhIH0gZnJvbSAnQHJlYWN0LXRocmVlL2RyZWknO1xuaW1wb3J0IHsgTGV2YSwgdXNlQ29udHJvbHMgfSBmcm9tICdsZXZhJztcbmltcG9ydCBHcmlkU2NlbmUgZnJvbSAnLi4vY29tcG9uZW50cy9HcmlkU2NlbmUnOyAvLyBBZGp1c3QgcGF0aCBpZiBuZWNlc3NhcnlcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi4vc3R5bGVzL0hvbWUubW9kdWxlLmNzcyc7IC8vIEFzc3VtaW5nIHlvdSBoYXZlIHRoaXMgZm9yIHN0eWxpbmdcblxuY29uc3QgQXBwID0gKCkgPT4ge1xuICAvLyBMZXZhIGNvbnRyb2xzIGZvciBjYW1lcmEgem9vbVxuICBjb25zdCB7IGNhbWVyYVpvb20gfSA9IHVzZUNvbnRyb2xzKHtcbiAgICBjYW1lcmFab29tOiB7IHZhbHVlOiA1MCwgbWluOiAxMCwgbWF4OiAyMDAsIHN0ZXA6IDEgfSxcbiAgfSk7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmNvbnRhaW5lcn0+XG4gICAgICA8TGV2YSBjb2xsYXBzZWQgLz4gey8qIExldmEgcGFuZWwgZm9yIGNvbnRyb2xzICovfVxuICAgICAgPENhbnZhc1xuICAgICAgICBzdHlsZT17eyBwb3NpdGlvbjogJ2Fic29sdXRlJywgdG9wOiAwLCBsZWZ0OiAwLCB3aWR0aDogJzEwMCUnLCBoZWlnaHQ6ICcxMDAlJyB9fVxuICAgICAgPlxuICAgICAgICB7LyogVXNlIE9ydGhvZ3JhcGhpY0NhbWVyYSBmb3IgMkQgdmlldyAqL31cbiAgICAgICAgPE9ydGhvZ3JhcGhpY0NhbWVyYVxuICAgICAgICAgIG1ha2VEZWZhdWx0IC8vIFNldHMgdGhpcyBjYW1lcmEgYXMgdGhlIGRlZmF1bHRcbiAgICAgICAgICB6b29tPXtjYW1lcmFab29tfVxuICAgICAgICAgIHBvc2l0aW9uPXtbMCwgMCwgMTAwXX0gLy8gUG9zaXRpb25lZCB0byBsb29rIGFsb25nIC1aIGF4aXNcbiAgICAgICAgICBuZWFyPXswLjF9XG4gICAgICAgICAgZmFyPXsxMDAwfVxuICAgICAgICAvPlxuICAgICAgICA8YW1iaWVudExpZ2h0IGludGVuc2l0eT17MS4wfSAvPiB7LyogQmFzaWMgbGlnaHRpbmcgKi99XG4gICAgICAgIFxuICAgICAgICB7LyogUmVuZGVyIHRoZSBtYWluIHNjZW5lIGNvbXBvbmVudCAqL31cbiAgICAgICAgPEdyaWRTY2VuZSAvPiBcbiAgICAgICAgXG4gICAgICAgIHsvKiBPcHRpb25hbDogQWRkIE9yYml0Q29udHJvbHMgaWYgbmVlZGVkIGZvciBkZWJ1Z2dpbmcvbmF2aWdhdGlvbiAqL31cbiAgICAgICAgey8qIDxPcmJpdENvbnRyb2xzIGVuYWJsZVJvdGF0ZT17ZmFsc2V9IC8+ICovfVxuICAgICAgPC9DYW52YXM+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBBcHA7ICJdLCJuYW1lcyI6WyJSZWFjdCIsIkNhbnZhcyIsIk9ydGhvZ3JhcGhpY0NhbWVyYSIsIkxldmEiLCJ1c2VDb250cm9scyIsIkdyaWRTY2VuZSIsInN0eWxlcyIsIkFwcCIsImNhbWVyYVpvb20iLCJ2YWx1ZSIsIm1pbiIsIm1heCIsInN0ZXAiLCJkaXYiLCJjbGFzc05hbWUiLCJjb250YWluZXIiLCJjb2xsYXBzZWQiLCJzdHlsZSIsInBvc2l0aW9uIiwidG9wIiwibGVmdCIsIndpZHRoIiwiaGVpZ2h0IiwibWFrZURlZmF1bHQiLCJ6b29tIiwibmVhciIsImZhciIsImFtYmllbnRMaWdodCIsImludGVuc2l0eSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./pages/index.js\n");

/***/ }),

/***/ "@react-three/drei":
/*!************************************!*\
  !*** external "@react-three/drei" ***!
  \************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@react-three/drei");

/***/ }),

/***/ "@react-three/fiber":
/*!*************************************!*\
  !*** external "@react-three/fiber" ***!
  \*************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@react-three/fiber");

/***/ }),

/***/ "leva":
/*!***********************!*\
  !*** external "leva" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("leva");

/***/ }),

/***/ "next/dist/compiled/next-server/pages.runtime.dev.js":
/*!**********************************************************************!*\
  !*** external "next/dist/compiled/next-server/pages.runtime.dev.js" ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/next-server/pages.runtime.dev.js");

/***/ }),

/***/ "react":
/*!************************!*\
  !*** external "react" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("react");

/***/ }),

/***/ "react/jsx-dev-runtime":
/*!****************************************!*\
  !*** external "react/jsx-dev-runtime" ***!
  \****************************************/
/***/ ((module) => {

"use strict";
module.exports = require("react/jsx-dev-runtime");

/***/ }),

/***/ "three":
/*!************************!*\
  !*** external "three" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = import("three");;

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next","vendor-chunks/@swc"], () => (__webpack_exec__("./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES&page=%2F&preferredRegion=&absolutePagePath=.%2Fpages%2Findex.js&absoluteAppPath=private-next-pages%2F_app&absoluteDocumentPath=private-next-pages%2F_document&middlewareConfigBase64=e30%3D!")));
module.exports = __webpack_exports__;

})();