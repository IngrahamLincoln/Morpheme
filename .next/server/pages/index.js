/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/index";
exports.ids = ["pages/index"];
exports.modules = {

/***/ "./styles/Home.module.css":
/*!********************************!*\
  !*** ./styles/Home.module.css ***!
  \********************************/
/***/ ((module) => {

eval("// Exports\nmodule.exports = {\n\t\"container\": \"Home_container__d256j\",\n\t\"main\": \"Home_main__VkIEL\",\n\t\"title\": \"Home_title__hYX6j\"\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zdHlsZXMvSG9tZS5tb2R1bGUuY3NzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYmdsLWRvdC1ncmlkLW12cC8uL3N0eWxlcy9Ib21lLm1vZHVsZS5jc3M/YmMyMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBFeHBvcnRzXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0XCJjb250YWluZXJcIjogXCJIb21lX2NvbnRhaW5lcl9fZDI1NmpcIixcblx0XCJtYWluXCI6IFwiSG9tZV9tYWluX19Wa0lFTFwiLFxuXHRcInRpdGxlXCI6IFwiSG9tZV90aXRsZV9faFlYNmpcIlxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./styles/Home.module.css\n");

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES&page=%2F&preferredRegion=&absolutePagePath=.%2Fpages%2Findex.js&absoluteAppPath=private-next-pages%2F_app&absoluteDocumentPath=private-next-pages%2F_document&middlewareConfigBase64=e30%3D!":
/*!*****************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES&page=%2F&preferredRegion=&absolutePagePath=.%2Fpages%2Findex.js&absoluteAppPath=private-next-pages%2F_app&absoluteDocumentPath=private-next-pages%2F_document&middlewareConfigBase64=e30%3D! ***!
  \*****************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   getServerSideProps: () => (/* binding */ getServerSideProps),\n/* harmony export */   getStaticPaths: () => (/* binding */ getStaticPaths),\n/* harmony export */   getStaticProps: () => (/* binding */ getStaticProps),\n/* harmony export */   reportWebVitals: () => (/* binding */ reportWebVitals),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   unstable_getServerProps: () => (/* binding */ unstable_getServerProps),\n/* harmony export */   unstable_getServerSideProps: () => (/* binding */ unstable_getServerSideProps),\n/* harmony export */   unstable_getStaticParams: () => (/* binding */ unstable_getStaticParams),\n/* harmony export */   unstable_getStaticPaths: () => (/* binding */ unstable_getStaticPaths),\n/* harmony export */   unstable_getStaticProps: () => (/* binding */ unstable_getStaticProps)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_pages_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/pages/module.compiled */ \"./node_modules/next/dist/server/future/route-modules/pages/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_pages_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_pages_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/build/templates/helpers */ \"./node_modules/next/dist/build/templates/helpers.js\");\n/* harmony import */ var private_next_pages_document__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! private-next-pages/_document */ \"./node_modules/next/dist/pages/_document.js\");\n/* harmony import */ var private_next_pages_document__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(private_next_pages_document__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var private_next_pages_app__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! private-next-pages/_app */ \"./node_modules/next/dist/pages/_app.js\");\n/* harmony import */ var private_next_pages_app__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(private_next_pages_app__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _pages_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./pages/index.js */ \"./pages/index.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_pages_index_js__WEBPACK_IMPORTED_MODULE_5__]);\n_pages_index_js__WEBPACK_IMPORTED_MODULE_5__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n// Import the app and document modules.\n\n\n// Import the userland code.\n\n// Re-export the component (should be the default export).\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_index_js__WEBPACK_IMPORTED_MODULE_5__, \"default\"));\n// Re-export methods.\nconst getStaticProps = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_index_js__WEBPACK_IMPORTED_MODULE_5__, \"getStaticProps\");\nconst getStaticPaths = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_index_js__WEBPACK_IMPORTED_MODULE_5__, \"getStaticPaths\");\nconst getServerSideProps = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_index_js__WEBPACK_IMPORTED_MODULE_5__, \"getServerSideProps\");\nconst config = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_index_js__WEBPACK_IMPORTED_MODULE_5__, \"config\");\nconst reportWebVitals = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_index_js__WEBPACK_IMPORTED_MODULE_5__, \"reportWebVitals\");\n// Re-export legacy methods.\nconst unstable_getStaticProps = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_index_js__WEBPACK_IMPORTED_MODULE_5__, \"unstable_getStaticProps\");\nconst unstable_getStaticPaths = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_index_js__WEBPACK_IMPORTED_MODULE_5__, \"unstable_getStaticPaths\");\nconst unstable_getStaticParams = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_index_js__WEBPACK_IMPORTED_MODULE_5__, \"unstable_getStaticParams\");\nconst unstable_getServerProps = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_index_js__WEBPACK_IMPORTED_MODULE_5__, \"unstable_getServerProps\");\nconst unstable_getServerSideProps = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_index_js__WEBPACK_IMPORTED_MODULE_5__, \"unstable_getServerSideProps\");\n// Create and export the route module that will be consumed.\nconst routeModule = new next_dist_server_future_route_modules_pages_module_compiled__WEBPACK_IMPORTED_MODULE_0__.PagesRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.PAGES,\n        page: \"/index\",\n        pathname: \"/\",\n        // The following aren't used in production.\n        bundlePath: \"\",\n        filename: \"\"\n    },\n    components: {\n        App: (private_next_pages_app__WEBPACK_IMPORTED_MODULE_4___default()),\n        Document: (private_next_pages_document__WEBPACK_IMPORTED_MODULE_3___default())\n    },\n    userland: _pages_index_js__WEBPACK_IMPORTED_MODULE_5__\n});\n\n//# sourceMappingURL=pages.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXJvdXRlLWxvYWRlci9pbmRleC5qcz9raW5kPVBBR0VTJnBhZ2U9JTJGJnByZWZlcnJlZFJlZ2lvbj0mYWJzb2x1dGVQYWdlUGF0aD0uJTJGcGFnZXMlMkZpbmRleC5qcyZhYnNvbHV0ZUFwcFBhdGg9cHJpdmF0ZS1uZXh0LXBhZ2VzJTJGX2FwcCZhYnNvbHV0ZURvY3VtZW50UGF0aD1wcml2YXRlLW5leHQtcGFnZXMlMkZfZG9jdW1lbnQmbWlkZGxld2FyZUNvbmZpZ0Jhc2U2ND1lMzAlM0QhIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUErRjtBQUNoQztBQUNMO0FBQzFEO0FBQ29EO0FBQ1Y7QUFDMUM7QUFDNkM7QUFDN0M7QUFDQSxpRUFBZSx3RUFBSyxDQUFDLDRDQUFRLFlBQVksRUFBQztBQUMxQztBQUNPLHVCQUF1Qix3RUFBSyxDQUFDLDRDQUFRO0FBQ3JDLHVCQUF1Qix3RUFBSyxDQUFDLDRDQUFRO0FBQ3JDLDJCQUEyQix3RUFBSyxDQUFDLDRDQUFRO0FBQ3pDLGVBQWUsd0VBQUssQ0FBQyw0Q0FBUTtBQUM3Qix3QkFBd0Isd0VBQUssQ0FBQyw0Q0FBUTtBQUM3QztBQUNPLGdDQUFnQyx3RUFBSyxDQUFDLDRDQUFRO0FBQzlDLGdDQUFnQyx3RUFBSyxDQUFDLDRDQUFRO0FBQzlDLGlDQUFpQyx3RUFBSyxDQUFDLDRDQUFRO0FBQy9DLGdDQUFnQyx3RUFBSyxDQUFDLDRDQUFRO0FBQzlDLG9DQUFvQyx3RUFBSyxDQUFDLDRDQUFRO0FBQ3pEO0FBQ08sd0JBQXdCLHlHQUFnQjtBQUMvQztBQUNBLGNBQWMseUVBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLFdBQVc7QUFDWCxnQkFBZ0I7QUFDaEIsS0FBSztBQUNMLFlBQVk7QUFDWixDQUFDOztBQUVELGlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViZ2wtZG90LWdyaWQtbXZwLz8xNDNkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBhZ2VzUm91dGVNb2R1bGUgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9mdXR1cmUvcm91dGUtbW9kdWxlcy9wYWdlcy9tb2R1bGUuY29tcGlsZWRcIjtcbmltcG9ydCB7IFJvdXRlS2luZCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1raW5kXCI7XG5pbXBvcnQgeyBob2lzdCB9IGZyb20gXCJuZXh0L2Rpc3QvYnVpbGQvdGVtcGxhdGVzL2hlbHBlcnNcIjtcbi8vIEltcG9ydCB0aGUgYXBwIGFuZCBkb2N1bWVudCBtb2R1bGVzLlxuaW1wb3J0IERvY3VtZW50IGZyb20gXCJwcml2YXRlLW5leHQtcGFnZXMvX2RvY3VtZW50XCI7XG5pbXBvcnQgQXBwIGZyb20gXCJwcml2YXRlLW5leHQtcGFnZXMvX2FwcFwiO1xuLy8gSW1wb3J0IHRoZSB1c2VybGFuZCBjb2RlLlxuaW1wb3J0ICogYXMgdXNlcmxhbmQgZnJvbSBcIi4vcGFnZXMvaW5kZXguanNcIjtcbi8vIFJlLWV4cG9ydCB0aGUgY29tcG9uZW50IChzaG91bGQgYmUgdGhlIGRlZmF1bHQgZXhwb3J0KS5cbmV4cG9ydCBkZWZhdWx0IGhvaXN0KHVzZXJsYW5kLCBcImRlZmF1bHRcIik7XG4vLyBSZS1leHBvcnQgbWV0aG9kcy5cbmV4cG9ydCBjb25zdCBnZXRTdGF0aWNQcm9wcyA9IGhvaXN0KHVzZXJsYW5kLCBcImdldFN0YXRpY1Byb3BzXCIpO1xuZXhwb3J0IGNvbnN0IGdldFN0YXRpY1BhdGhzID0gaG9pc3QodXNlcmxhbmQsIFwiZ2V0U3RhdGljUGF0aHNcIik7XG5leHBvcnQgY29uc3QgZ2V0U2VydmVyU2lkZVByb3BzID0gaG9pc3QodXNlcmxhbmQsIFwiZ2V0U2VydmVyU2lkZVByb3BzXCIpO1xuZXhwb3J0IGNvbnN0IGNvbmZpZyA9IGhvaXN0KHVzZXJsYW5kLCBcImNvbmZpZ1wiKTtcbmV4cG9ydCBjb25zdCByZXBvcnRXZWJWaXRhbHMgPSBob2lzdCh1c2VybGFuZCwgXCJyZXBvcnRXZWJWaXRhbHNcIik7XG4vLyBSZS1leHBvcnQgbGVnYWN5IG1ldGhvZHMuXG5leHBvcnQgY29uc3QgdW5zdGFibGVfZ2V0U3RhdGljUHJvcHMgPSBob2lzdCh1c2VybGFuZCwgXCJ1bnN0YWJsZV9nZXRTdGF0aWNQcm9wc1wiKTtcbmV4cG9ydCBjb25zdCB1bnN0YWJsZV9nZXRTdGF0aWNQYXRocyA9IGhvaXN0KHVzZXJsYW5kLCBcInVuc3RhYmxlX2dldFN0YXRpY1BhdGhzXCIpO1xuZXhwb3J0IGNvbnN0IHVuc3RhYmxlX2dldFN0YXRpY1BhcmFtcyA9IGhvaXN0KHVzZXJsYW5kLCBcInVuc3RhYmxlX2dldFN0YXRpY1BhcmFtc1wiKTtcbmV4cG9ydCBjb25zdCB1bnN0YWJsZV9nZXRTZXJ2ZXJQcm9wcyA9IGhvaXN0KHVzZXJsYW5kLCBcInVuc3RhYmxlX2dldFNlcnZlclByb3BzXCIpO1xuZXhwb3J0IGNvbnN0IHVuc3RhYmxlX2dldFNlcnZlclNpZGVQcm9wcyA9IGhvaXN0KHVzZXJsYW5kLCBcInVuc3RhYmxlX2dldFNlcnZlclNpZGVQcm9wc1wiKTtcbi8vIENyZWF0ZSBhbmQgZXhwb3J0IHRoZSByb3V0ZSBtb2R1bGUgdGhhdCB3aWxsIGJlIGNvbnN1bWVkLlxuZXhwb3J0IGNvbnN0IHJvdXRlTW9kdWxlID0gbmV3IFBhZ2VzUm91dGVNb2R1bGUoe1xuICAgIGRlZmluaXRpb246IHtcbiAgICAgICAga2luZDogUm91dGVLaW5kLlBBR0VTLFxuICAgICAgICBwYWdlOiBcIi9pbmRleFwiLFxuICAgICAgICBwYXRobmFtZTogXCIvXCIsXG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgYXJlbid0IHVzZWQgaW4gcHJvZHVjdGlvbi5cbiAgICAgICAgYnVuZGxlUGF0aDogXCJcIixcbiAgICAgICAgZmlsZW5hbWU6IFwiXCJcbiAgICB9LFxuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgQXBwLFxuICAgICAgICBEb2N1bWVudFxuICAgIH0sXG4gICAgdXNlcmxhbmRcbn0pO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYWdlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES&page=%2F&preferredRegion=&absolutePagePath=.%2Fpages%2Findex.js&absoluteAppPath=private-next-pages%2F_app&absoluteDocumentPath=private-next-pages%2F_document&middlewareConfigBase64=e30%3D!\n");

/***/ }),

/***/ "./components/CircleMaterial.tsx":
/*!***************************************!*\
  !*** ./components/CircleMaterial.tsx ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-three/drei */ \"@react-three/drei\");\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_react_three_drei__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-three/fiber */ \"@react-three/fiber\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__);\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([three__WEBPACK_IMPORTED_MODULE_0__]);\nthree__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n// Simple vertex shader\nconst vertexShader = /*glsl*/ `\n  varying vec2 vUv;\n  attribute float a_activated; // Will be used in Feature 4\n  varying float v_activated;   // Will be used in Feature 4\n  void main() {\n    vUv = uv;\n    v_activated = a_activated; // Pass activation state\n    gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0);\n  }\n`;\n// Fragment shader to draw two concentric circles\nconst fragmentShader = /*glsl*/ `\n  uniform float u_radiusA;      // Outer radius (scaled relative to instance size)\n  uniform float u_radiusB;      // Inner radius (scaled relative to instance size)\n  uniform vec3 u_bgColor;       // Background color (or transparent)\n  uniform vec3 u_outerColor;    // Color of the outer ring\n  uniform vec3 u_innerColorEmpty; // Color of the inner circle when inactive\n  uniform vec3 u_innerColorActive;// Color of the inner circle when active\n\n  varying vec2 vUv;\n  varying float v_activated; // Read from vertex shader (comes from a_activated attribute)\n\n  void main() {\n    float dist = distance(vUv, vec2(0.5));\n\n    // Discard if outside the outer circle\n    if (dist > u_radiusA) {\n        discard;\n    }\n\n    // Check activation state first\n    if (v_activated == 1.0) {\n        // If activated, only draw the inner circle (black)\n        if (dist <= u_radiusB) {\n            gl_FragColor = vec4(u_innerColorActive, 1.0); // Solid black inner circle\n        } else {\n            discard; // Make outer ring transparent when activated\n        }\n    } else {\n        // Not activated - draw both inner and outer circles\n        if (dist > u_radiusB) {\n            // In the outer ring\n            gl_FragColor = vec4(u_outerColor, 1.0);\n        } else {\n            // In the inner circle - empty/inactive\n            gl_FragColor = vec4(u_innerColorEmpty, 1.0);\n        }\n    }\n  }\n`;\n// Create the shader material using drei/shaderMaterial\nconst CircleMaterial = (0,_react_three_drei__WEBPACK_IMPORTED_MODULE_1__.shaderMaterial)({\n    u_radiusA: 0.5,\n    u_radiusB: 0.4,\n    u_bgColor: new three__WEBPACK_IMPORTED_MODULE_0__.Color(\"#ffffff\"),\n    u_outerColor: new three__WEBPACK_IMPORTED_MODULE_0__.Color(\"#cccccc\"),\n    u_innerColorEmpty: new three__WEBPACK_IMPORTED_MODULE_0__.Color(\"#ffffff\"),\n    u_innerColorActive: new three__WEBPACK_IMPORTED_MODULE_0__.Color(\"#000000\")\n}, vertexShader, fragmentShader);\n// Extend R3F to recognize the material\n(0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.extend)({\n    CircleMaterial\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CircleMaterial);\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL0NpcmNsZU1hdGVyaWFsLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBK0I7QUFDb0I7QUFDUDtBQUU1Qyx1QkFBdUI7QUFDdkIsTUFBTUcsZUFBZSxNQUFNLEdBQUcsQ0FBQzs7Ozs7Ozs7O0FBUy9CLENBQUM7QUFFRCxpREFBaUQ7QUFDakQsTUFBTUMsaUJBQWlCLE1BQU0sR0FBRyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNDakMsQ0FBQztBQUVELHVEQUF1RDtBQUN2RCxNQUFNQyxpQkFBaUJKLGlFQUFjQSxDQUNuQztJQUNFSyxXQUFXO0lBQ1hDLFdBQVc7SUFDWEMsV0FBVyxJQUFJUix3Q0FBVyxDQUFDO0lBQzNCVSxjQUFjLElBQUlWLHdDQUFXLENBQUM7SUFDOUJXLG1CQUFtQixJQUFJWCx3Q0FBVyxDQUFDO0lBQ25DWSxvQkFBb0IsSUFBSVosd0NBQVcsQ0FBQztBQUN0QyxHQUNBRyxjQUNBQztBQUdGLHVDQUF1QztBQUN2Q0YsMERBQU1BLENBQUM7SUFBRUc7QUFBZTtBQVd4QixpRUFBZUEsY0FBY0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYmdsLWRvdC1ncmlkLW12cC8uL2NvbXBvbmVudHMvQ2lyY2xlTWF0ZXJpYWwudHN4PzQyNTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgc2hhZGVyTWF0ZXJpYWwgfSBmcm9tICdAcmVhY3QtdGhyZWUvZHJlaSc7XG5pbXBvcnQgeyBleHRlbmQgfSBmcm9tICdAcmVhY3QtdGhyZWUvZmliZXInO1xuXG4vLyBTaW1wbGUgdmVydGV4IHNoYWRlclxuY29uc3QgdmVydGV4U2hhZGVyID0gLypnbHNsKi8gYFxuICB2YXJ5aW5nIHZlYzIgdlV2O1xuICBhdHRyaWJ1dGUgZmxvYXQgYV9hY3RpdmF0ZWQ7IC8vIFdpbGwgYmUgdXNlZCBpbiBGZWF0dXJlIDRcbiAgdmFyeWluZyBmbG9hdCB2X2FjdGl2YXRlZDsgICAvLyBXaWxsIGJlIHVzZWQgaW4gRmVhdHVyZSA0XG4gIHZvaWQgbWFpbigpIHtcbiAgICB2VXYgPSB1djtcbiAgICB2X2FjdGl2YXRlZCA9IGFfYWN0aXZhdGVkOyAvLyBQYXNzIGFjdGl2YXRpb24gc3RhdGVcbiAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiBpbnN0YW5jZU1hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XG4gIH1cbmA7XG5cbi8vIEZyYWdtZW50IHNoYWRlciB0byBkcmF3IHR3byBjb25jZW50cmljIGNpcmNsZXNcbmNvbnN0IGZyYWdtZW50U2hhZGVyID0gLypnbHNsKi8gYFxuICB1bmlmb3JtIGZsb2F0IHVfcmFkaXVzQTsgICAgICAvLyBPdXRlciByYWRpdXMgKHNjYWxlZCByZWxhdGl2ZSB0byBpbnN0YW5jZSBzaXplKVxuICB1bmlmb3JtIGZsb2F0IHVfcmFkaXVzQjsgICAgICAvLyBJbm5lciByYWRpdXMgKHNjYWxlZCByZWxhdGl2ZSB0byBpbnN0YW5jZSBzaXplKVxuICB1bmlmb3JtIHZlYzMgdV9iZ0NvbG9yOyAgICAgICAvLyBCYWNrZ3JvdW5kIGNvbG9yIChvciB0cmFuc3BhcmVudClcbiAgdW5pZm9ybSB2ZWMzIHVfb3V0ZXJDb2xvcjsgICAgLy8gQ29sb3Igb2YgdGhlIG91dGVyIHJpbmdcbiAgdW5pZm9ybSB2ZWMzIHVfaW5uZXJDb2xvckVtcHR5OyAvLyBDb2xvciBvZiB0aGUgaW5uZXIgY2lyY2xlIHdoZW4gaW5hY3RpdmVcbiAgdW5pZm9ybSB2ZWMzIHVfaW5uZXJDb2xvckFjdGl2ZTsvLyBDb2xvciBvZiB0aGUgaW5uZXIgY2lyY2xlIHdoZW4gYWN0aXZlXG5cbiAgdmFyeWluZyB2ZWMyIHZVdjtcbiAgdmFyeWluZyBmbG9hdCB2X2FjdGl2YXRlZDsgLy8gUmVhZCBmcm9tIHZlcnRleCBzaGFkZXIgKGNvbWVzIGZyb20gYV9hY3RpdmF0ZWQgYXR0cmlidXRlKVxuXG4gIHZvaWQgbWFpbigpIHtcbiAgICBmbG9hdCBkaXN0ID0gZGlzdGFuY2UodlV2LCB2ZWMyKDAuNSkpO1xuXG4gICAgLy8gRGlzY2FyZCBpZiBvdXRzaWRlIHRoZSBvdXRlciBjaXJjbGVcbiAgICBpZiAoZGlzdCA+IHVfcmFkaXVzQSkge1xuICAgICAgICBkaXNjYXJkO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGFjdGl2YXRpb24gc3RhdGUgZmlyc3RcbiAgICBpZiAodl9hY3RpdmF0ZWQgPT0gMS4wKSB7XG4gICAgICAgIC8vIElmIGFjdGl2YXRlZCwgb25seSBkcmF3IHRoZSBpbm5lciBjaXJjbGUgKGJsYWNrKVxuICAgICAgICBpZiAoZGlzdCA8PSB1X3JhZGl1c0IpIHtcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQodV9pbm5lckNvbG9yQWN0aXZlLCAxLjApOyAvLyBTb2xpZCBibGFjayBpbm5lciBjaXJjbGVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpc2NhcmQ7IC8vIE1ha2Ugb3V0ZXIgcmluZyB0cmFuc3BhcmVudCB3aGVuIGFjdGl2YXRlZFxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm90IGFjdGl2YXRlZCAtIGRyYXcgYm90aCBpbm5lciBhbmQgb3V0ZXIgY2lyY2xlc1xuICAgICAgICBpZiAoZGlzdCA+IHVfcmFkaXVzQikge1xuICAgICAgICAgICAgLy8gSW4gdGhlIG91dGVyIHJpbmdcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQodV9vdXRlckNvbG9yLCAxLjApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSW4gdGhlIGlubmVyIGNpcmNsZSAtIGVtcHR5L2luYWN0aXZlXG4gICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHVfaW5uZXJDb2xvckVtcHR5LCAxLjApO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5gO1xuXG4vLyBDcmVhdGUgdGhlIHNoYWRlciBtYXRlcmlhbCB1c2luZyBkcmVpL3NoYWRlck1hdGVyaWFsXG5jb25zdCBDaXJjbGVNYXRlcmlhbCA9IHNoYWRlck1hdGVyaWFsKFxuICB7XG4gICAgdV9yYWRpdXNBOiAwLjUsIC8vIERlZmF1bHQgdmFsdWUsIHdpbGwgYmUgdXBkYXRlZFxuICAgIHVfcmFkaXVzQjogMC40LCAvLyBEZWZhdWx0IHZhbHVlLCB3aWxsIGJlIHVwZGF0ZWRcbiAgICB1X2JnQ29sb3I6IG5ldyBUSFJFRS5Db2xvcignI2ZmZmZmZicpLCAvLyBEZWZhdWx0IGJnXG4gICAgdV9vdXRlckNvbG9yOiBuZXcgVEhSRUUuQ29sb3IoJyNjY2NjY2MnKSwgLy8gTGlnaHQgZ3JleSBvdXRlciByaW5nXG4gICAgdV9pbm5lckNvbG9yRW1wdHk6IG5ldyBUSFJFRS5Db2xvcignI2ZmZmZmZicpLCAvLyBXaGl0ZS90cmFuc3BhcmVudCBpbm5lciBlbXB0eVxuICAgIHVfaW5uZXJDb2xvckFjdGl2ZTogbmV3IFRIUkVFLkNvbG9yKCcjMDAwMDAwJyksIC8vIEJsYWNrIGlubmVyIGFjdGl2ZVxuICB9LFxuICB2ZXJ0ZXhTaGFkZXIsXG4gIGZyYWdtZW50U2hhZGVyXG4pO1xuXG4vLyBFeHRlbmQgUjNGIHRvIHJlY29nbml6ZSB0aGUgbWF0ZXJpYWxcbmV4dGVuZCh7IENpcmNsZU1hdGVyaWFsIH0pO1xuXG4vLyBEZWZpbmUgVHlwZVNjcmlwdCB0eXBlIGZvciBKU1ggdXNhZ2VcbmRlY2xhcmUgZ2xvYmFsIHtcbiAgbmFtZXNwYWNlIEpTWCB7XG4gICAgaW50ZXJmYWNlIEludHJpbnNpY0VsZW1lbnRzIHtcbiAgICAgIGNpcmNsZU1hdGVyaWFsOiBhbnk7IC8vIFVzZSBcXCdhbnlcXCcgb3IgZGVmaW5lIG1vcmUgc3BlY2lmaWMgdHlwZXNcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2lyY2xlTWF0ZXJpYWw7ICJdLCJuYW1lcyI6WyJUSFJFRSIsInNoYWRlck1hdGVyaWFsIiwiZXh0ZW5kIiwidmVydGV4U2hhZGVyIiwiZnJhZ21lbnRTaGFkZXIiLCJDaXJjbGVNYXRlcmlhbCIsInVfcmFkaXVzQSIsInVfcmFkaXVzQiIsInVfYmdDb2xvciIsIkNvbG9yIiwidV9vdXRlckNvbG9yIiwidV9pbm5lckNvbG9yRW1wdHkiLCJ1X2lubmVyQ29sb3JBY3RpdmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/CircleMaterial.tsx\n");

/***/ }),

/***/ "./components/CmdHorizConnectorMaterial.tsx":
/*!**************************************************!*\
  !*** ./components/CmdHorizConnectorMaterial.tsx ***!
  \**************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-three/drei */ \"@react-three/drei\");\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_react_three_drei__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-three/fiber */ \"@react-three/fiber\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__);\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([three__WEBPACK_IMPORTED_MODULE_0__]);\nthree__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n// Constants from GridScene/ConnectorMaterial needed for calculations\nconst BASE_RADIUS_A = 0.5; // Outer radius relative to spacing=1\nconst BASE_RADIUS_B = 0.4; // Inner radius relative to spacing=1\nconst FIXED_SPACING = BASE_RADIUS_A + BASE_RADIUS_B; // 0.9\n// Vertex shader: Pass UVs (same as ConnectorMaterial)\nconst vertexShader = /*glsl*/ `\n  varying vec2 vUv;\n  void main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  }\n`;\n// Fragment shader: Only for Cmd-Click Horizontal Connectors\nconst fragmentShader = /*glsl*/ `\n  uniform sampler2D u_stateTexture;             // Need state to confirm circles are active\n  uniform sampler2D u_cmdHorizConnectorTexture; // Texture for cmd-click horizontal connectors\n  uniform vec2 u_gridDimensions;            // Grid size (width, height) in cells\n  uniform vec2 u_textureResolution;         // State Texture size (width, height) in pixels\n  uniform float u_radiusA;                  // Outer radius (base value)\n  uniform float u_radiusB;                  // Inner radius (base value)\n  uniform float u_gridSpacing;              // Visual scale factor (from Leva)\n  uniform float u_fixedSpacing;             // Base spacing between circle centers (e.g., 0.9)\n  // World space uniforms\n  uniform vec2 u_centerOffset;              // World offset for centering grid\n  uniform vec2 u_planeSize;                 // World size of connector plane\n\n  varying vec2 vUv;\n\n  // --- SDF Helper Functions ---\n  float sdCircle(vec2 p, float r) {\n    return length(p) - r;\n  }\n\n  // SDF function for rectangle with sharp corners\n  float sdBox2D(vec2 p, vec2 halfSize) {\n    vec2 d = abs(p) - halfSize;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n  }\n\n  // --- State Sampling Helper ---\n  float getState(ivec2 cellCoord) {\n    // Use u_textureResolution (size of stateTexture) for clamping\n    ivec2 clampedCoord = clamp(cellCoord, ivec2(0), ivec2(u_textureResolution) - ivec2(1));\n    if (cellCoord != clampedCoord) return 0.0;\n    return texelFetch(u_stateTexture, clampedCoord, 0).r;\n  }\n\n  // --- Cmd-Click Horizontal Connector Sampling ---\n  float getCmdHorizConnector(ivec2 cellCoord) {\n    // The cmd-horiz texture is (gridWidth-1) x gridHeight\n    ivec2 horizTextureSize = ivec2(u_gridDimensions.x - 1.0, u_gridDimensions.y);\n     // Check bounds against the actual size of the cmdHorizConnectorTexture\n    if (cellCoord.x < 0 || cellCoord.x >= horizTextureSize.x ||\n        cellCoord.y < 0 || cellCoord.y >= horizTextureSize.y) {\n      return 0.0;\n    }\n    // Fetch from the dedicated texture\n    return texelFetch(u_cmdHorizConnectorTexture, cellCoord, 0).r;\n  }\n\n  // --- Get Cell Center in World Space ---\n  vec2 getCellWorldCenter(ivec2 cell) {\n    // Calculate scaled spacing\n    float scaledSpacing = u_fixedSpacing * u_gridSpacing;\n    float worldX = float(cell.x) * scaledSpacing + u_centerOffset.x;\n    float worldY = float(cell.y) * scaledSpacing + u_centerOffset.y;\n    return vec2(worldX, worldY);\n  }\n\n  // --- Function to calculate SDF for a given row ---\n  float calculateConnectorSDF(ivec2 baseCell, vec2 fragPos, float worldRadA, float worldRadB, float scaledSpacing) {\n    float sdf = 1e6; // Default to outside\n\n    float cmdConn = getCmdHorizConnector(baseCell);\n    if (cmdConn > 0.0) {\n        ivec2 rightCell = baseCell + ivec2(1, 0);\n        float stateL = getState(baseCell);\n        float stateR = getState(rightCell);\n\n        if (stateL == 1.0 && stateR == 1.0) {\n            vec2 centerL = getCellWorldCenter(baseCell); // Uses scaled spacing internally now\n            vec2 centerR = getCellWorldCenter(rightCell); // Uses scaled spacing internally now\n\n            vec2 connCenter = (centerL + centerR) * 0.5;\n\n            // Use scaled spacing for width calculation too\n            float connWidth = scaledSpacing; // Width is simply the distance between centers\n            // Use inner radius (RadiusB) for thinner connector matching circle thickness\n            // Add a small epsilon to ensure overlap between rows\n            float connHeight = worldRadB * 2.0 + 0.01 * u_gridSpacing; // Added small overlap based on scale\n\n            vec2 p = fragPos - connCenter;\n\n            sdf = sdBox2D(p, vec2(connWidth * 0.5, connHeight * 0.5));\n        }\n    }\n    return sdf;\n  }\n\n\n  void main() {\n    // Calculate fragment's world position\n    vec2 planeOrigin = -u_planeSize * 0.5;\n    vec2 fragWorldPos = planeOrigin + vUv * u_planeSize;\n\n    // Calculate scaled spacing consistently\n    float scaledSpacing = u_fixedSpacing * u_gridSpacing;\n\n    // Determine the potential bottom-left cell based on floor, using scaled spacing\n    // Add a small offset (0.5) before flooring to handle positions exactly on the boundary better? Maybe not needed yet.\n    vec2 gridCoord = (fragWorldPos - u_centerOffset) / scaledSpacing;\n    ivec2 cell_bl_current = ivec2(floor(gridCoord)); // Cell for the current row floor\n\n    // Define the cell for the row above\n    ivec2 cell_bl_above = cell_bl_current + ivec2(0, 1);\n\n    // Calculate world-space radii (these are already scaled by u_gridSpacing in GridScene and passed)\n    // Wait, radiusA/B are BASE values. Scale them here.\n    float worldRadiusA = u_radiusA * u_gridSpacing;\n    float worldRadiusB = u_radiusB * u_gridSpacing;\n\n    // Calculate SDF for the connector potentially in the current row\n    float sdf_current = calculateConnectorSDF(cell_bl_current, fragWorldPos, worldRadiusA, worldRadiusB, scaledSpacing);\n\n    // Calculate SDF for the connector potentially in the row above\n    float sdf_above = calculateConnectorSDF(cell_bl_above, fragWorldPos, worldRadiusA, worldRadiusB, scaledSpacing);\n\n    // The final SDF is the minimum of the two (closest connector wins)\n    float finalSdf = min(sdf_current, sdf_above);\n\n    // Final Output: Draw if inside the combined SDF\n    if (finalSdf < 0.0) {\n      float smoothFactor = fwidth(finalSdf) * 0.8; // Anti-aliasing\n      float alpha = smoothstep(smoothFactor, -smoothFactor, finalSdf);\n\n      if (alpha > 0.01) {\n        gl_FragColor = vec4(0.0, 0.0, 0.0, alpha); // Black connector\n      } else {\n        discard; // Discard transparent fragments\n      }\n    } else {\n      discard; // Discard fragments outside the shape\n    }\n  }\n`;\n// Create the shader material\nconst CmdHorizConnectorMaterial = (0,_react_three_drei__WEBPACK_IMPORTED_MODULE_1__.shaderMaterial)({\n    u_stateTexture: null,\n    u_cmdHorizConnectorTexture: null,\n    u_gridDimensions: new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(10, 10),\n    u_textureResolution: new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(10, 10),\n    u_radiusA: BASE_RADIUS_A,\n    u_radiusB: BASE_RADIUS_B,\n    u_gridSpacing: 1.0,\n    u_fixedSpacing: FIXED_SPACING,\n    u_centerOffset: new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(0, 0),\n    u_planeSize: new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(10, 10)\n}, vertexShader, fragmentShader);\n// Extend R3F\n(0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.extend)({\n    CmdHorizConnectorMaterial\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CmdHorizConnectorMaterial);\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL0NtZEhvcml6Q29ubmVjdG9yTWF0ZXJpYWwudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUErQjtBQUNvQjtBQUNQO0FBRTVDLHFFQUFxRTtBQUNyRSxNQUFNRyxnQkFBZ0IsS0FBSyxxQ0FBcUM7QUFDaEUsTUFBTUMsZ0JBQWdCLEtBQUsscUNBQXFDO0FBQ2hFLE1BQU1DLGdCQUFnQkYsZ0JBQWdCQyxlQUFlLE1BQU07QUFFM0Qsc0RBQXNEO0FBQ3RELE1BQU1FLGVBQWUsTUFBTSxHQUFHLENBQUM7Ozs7OztBQU0vQixDQUFDO0FBRUQsNERBQTREO0FBQzVELE1BQU1DLGlCQUFpQixNQUFNLEdBQUcsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtSWpDLENBQUM7QUFFRCw2QkFBNkI7QUFDN0IsTUFBTUMsNEJBQTRCUCxpRUFBY0EsQ0FDOUM7SUFDRVEsZ0JBQWdCO0lBQ2hCQyw0QkFBNEI7SUFDNUJDLGtCQUFrQixJQUFJWCwwQ0FBYSxDQUFDLElBQUk7SUFDeENhLHFCQUFxQixJQUFJYiwwQ0FBYSxDQUFDLElBQUk7SUFDM0NjLFdBQVdYO0lBQ1hZLFdBQVdYO0lBQ1hZLGVBQWU7SUFDZkMsZ0JBQWdCWjtJQUNoQmEsZ0JBQWdCLElBQUlsQiwwQ0FBYSxDQUFDLEdBQUc7SUFDckNtQixhQUFhLElBQUluQiwwQ0FBYSxDQUFDLElBQUk7QUFDckMsR0FDQU0sY0FDQUM7QUFHRixhQUFhO0FBQ2JMLDBEQUFNQSxDQUFDO0lBQUVNO0FBQTBCO0FBV25DLGlFQUFlQSx5QkFBeUJBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWJnbC1kb3QtZ3JpZC1tdnAvLi9jb21wb25lbnRzL0NtZEhvcml6Q29ubmVjdG9yTWF0ZXJpYWwudHN4PzEzNmQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgc2hhZGVyTWF0ZXJpYWwgfSBmcm9tICdAcmVhY3QtdGhyZWUvZHJlaSc7XG5pbXBvcnQgeyBleHRlbmQgfSBmcm9tICdAcmVhY3QtdGhyZWUvZmliZXInO1xuXG4vLyBDb25zdGFudHMgZnJvbSBHcmlkU2NlbmUvQ29ubmVjdG9yTWF0ZXJpYWwgbmVlZGVkIGZvciBjYWxjdWxhdGlvbnNcbmNvbnN0IEJBU0VfUkFESVVTX0EgPSAwLjU7IC8vIE91dGVyIHJhZGl1cyByZWxhdGl2ZSB0byBzcGFjaW5nPTFcbmNvbnN0IEJBU0VfUkFESVVTX0IgPSAwLjQ7IC8vIElubmVyIHJhZGl1cyByZWxhdGl2ZSB0byBzcGFjaW5nPTFcbmNvbnN0IEZJWEVEX1NQQUNJTkcgPSBCQVNFX1JBRElVU19BICsgQkFTRV9SQURJVVNfQjsgLy8gMC45XG5cbi8vIFZlcnRleCBzaGFkZXI6IFBhc3MgVVZzIChzYW1lIGFzIENvbm5lY3Rvck1hdGVyaWFsKVxuY29uc3QgdmVydGV4U2hhZGVyID0gLypnbHNsKi8gYFxuICB2YXJ5aW5nIHZlYzIgdlV2O1xuICB2b2lkIG1haW4oKSB7XG4gICAgdlV2ID0gdXY7XG4gICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTtcbiAgfVxuYDtcblxuLy8gRnJhZ21lbnQgc2hhZGVyOiBPbmx5IGZvciBDbWQtQ2xpY2sgSG9yaXpvbnRhbCBDb25uZWN0b3JzXG5jb25zdCBmcmFnbWVudFNoYWRlciA9IC8qZ2xzbCovIGBcbiAgdW5pZm9ybSBzYW1wbGVyMkQgdV9zdGF0ZVRleHR1cmU7ICAgICAgICAgICAgIC8vIE5lZWQgc3RhdGUgdG8gY29uZmlybSBjaXJjbGVzIGFyZSBhY3RpdmVcbiAgdW5pZm9ybSBzYW1wbGVyMkQgdV9jbWRIb3JpekNvbm5lY3RvclRleHR1cmU7IC8vIFRleHR1cmUgZm9yIGNtZC1jbGljayBob3Jpem9udGFsIGNvbm5lY3RvcnNcbiAgdW5pZm9ybSB2ZWMyIHVfZ3JpZERpbWVuc2lvbnM7ICAgICAgICAgICAgLy8gR3JpZCBzaXplICh3aWR0aCwgaGVpZ2h0KSBpbiBjZWxsc1xuICB1bmlmb3JtIHZlYzIgdV90ZXh0dXJlUmVzb2x1dGlvbjsgICAgICAgICAvLyBTdGF0ZSBUZXh0dXJlIHNpemUgKHdpZHRoLCBoZWlnaHQpIGluIHBpeGVsc1xuICB1bmlmb3JtIGZsb2F0IHVfcmFkaXVzQTsgICAgICAgICAgICAgICAgICAvLyBPdXRlciByYWRpdXMgKGJhc2UgdmFsdWUpXG4gIHVuaWZvcm0gZmxvYXQgdV9yYWRpdXNCOyAgICAgICAgICAgICAgICAgIC8vIElubmVyIHJhZGl1cyAoYmFzZSB2YWx1ZSlcbiAgdW5pZm9ybSBmbG9hdCB1X2dyaWRTcGFjaW5nOyAgICAgICAgICAgICAgLy8gVmlzdWFsIHNjYWxlIGZhY3RvciAoZnJvbSBMZXZhKVxuICB1bmlmb3JtIGZsb2F0IHVfZml4ZWRTcGFjaW5nOyAgICAgICAgICAgICAvLyBCYXNlIHNwYWNpbmcgYmV0d2VlbiBjaXJjbGUgY2VudGVycyAoZS5nLiwgMC45KVxuICAvLyBXb3JsZCBzcGFjZSB1bmlmb3Jtc1xuICB1bmlmb3JtIHZlYzIgdV9jZW50ZXJPZmZzZXQ7ICAgICAgICAgICAgICAvLyBXb3JsZCBvZmZzZXQgZm9yIGNlbnRlcmluZyBncmlkXG4gIHVuaWZvcm0gdmVjMiB1X3BsYW5lU2l6ZTsgICAgICAgICAgICAgICAgIC8vIFdvcmxkIHNpemUgb2YgY29ubmVjdG9yIHBsYW5lXG5cbiAgdmFyeWluZyB2ZWMyIHZVdjtcblxuICAvLyAtLS0gU0RGIEhlbHBlciBGdW5jdGlvbnMgLS0tXG4gIGZsb2F0IHNkQ2lyY2xlKHZlYzIgcCwgZmxvYXQgcikge1xuICAgIHJldHVybiBsZW5ndGgocCkgLSByO1xuICB9XG5cbiAgLy8gU0RGIGZ1bmN0aW9uIGZvciByZWN0YW5nbGUgd2l0aCBzaGFycCBjb3JuZXJzXG4gIGZsb2F0IHNkQm94MkQodmVjMiBwLCB2ZWMyIGhhbGZTaXplKSB7XG4gICAgdmVjMiBkID0gYWJzKHApIC0gaGFsZlNpemU7XG4gICAgcmV0dXJuIGxlbmd0aChtYXgoZCwgMC4wKSkgKyBtaW4obWF4KGQueCwgZC55KSwgMC4wKTtcbiAgfVxuXG4gIC8vIC0tLSBTdGF0ZSBTYW1wbGluZyBIZWxwZXIgLS0tXG4gIGZsb2F0IGdldFN0YXRlKGl2ZWMyIGNlbGxDb29yZCkge1xuICAgIC8vIFVzZSB1X3RleHR1cmVSZXNvbHV0aW9uIChzaXplIG9mIHN0YXRlVGV4dHVyZSkgZm9yIGNsYW1waW5nXG4gICAgaXZlYzIgY2xhbXBlZENvb3JkID0gY2xhbXAoY2VsbENvb3JkLCBpdmVjMigwKSwgaXZlYzIodV90ZXh0dXJlUmVzb2x1dGlvbikgLSBpdmVjMigxKSk7XG4gICAgaWYgKGNlbGxDb29yZCAhPSBjbGFtcGVkQ29vcmQpIHJldHVybiAwLjA7XG4gICAgcmV0dXJuIHRleGVsRmV0Y2godV9zdGF0ZVRleHR1cmUsIGNsYW1wZWRDb29yZCwgMCkucjtcbiAgfVxuXG4gIC8vIC0tLSBDbWQtQ2xpY2sgSG9yaXpvbnRhbCBDb25uZWN0b3IgU2FtcGxpbmcgLS0tXG4gIGZsb2F0IGdldENtZEhvcml6Q29ubmVjdG9yKGl2ZWMyIGNlbGxDb29yZCkge1xuICAgIC8vIFRoZSBjbWQtaG9yaXogdGV4dHVyZSBpcyAoZ3JpZFdpZHRoLTEpIHggZ3JpZEhlaWdodFxuICAgIGl2ZWMyIGhvcml6VGV4dHVyZVNpemUgPSBpdmVjMih1X2dyaWREaW1lbnNpb25zLnggLSAxLjAsIHVfZ3JpZERpbWVuc2lvbnMueSk7XG4gICAgIC8vIENoZWNrIGJvdW5kcyBhZ2FpbnN0IHRoZSBhY3R1YWwgc2l6ZSBvZiB0aGUgY21kSG9yaXpDb25uZWN0b3JUZXh0dXJlXG4gICAgaWYgKGNlbGxDb29yZC54IDwgMCB8fCBjZWxsQ29vcmQueCA+PSBob3JpelRleHR1cmVTaXplLnggfHxcbiAgICAgICAgY2VsbENvb3JkLnkgPCAwIHx8IGNlbGxDb29yZC55ID49IGhvcml6VGV4dHVyZVNpemUueSkge1xuICAgICAgcmV0dXJuIDAuMDtcbiAgICB9XG4gICAgLy8gRmV0Y2ggZnJvbSB0aGUgZGVkaWNhdGVkIHRleHR1cmVcbiAgICByZXR1cm4gdGV4ZWxGZXRjaCh1X2NtZEhvcml6Q29ubmVjdG9yVGV4dHVyZSwgY2VsbENvb3JkLCAwKS5yO1xuICB9XG5cbiAgLy8gLS0tIEdldCBDZWxsIENlbnRlciBpbiBXb3JsZCBTcGFjZSAtLS1cbiAgdmVjMiBnZXRDZWxsV29ybGRDZW50ZXIoaXZlYzIgY2VsbCkge1xuICAgIC8vIENhbGN1bGF0ZSBzY2FsZWQgc3BhY2luZ1xuICAgIGZsb2F0IHNjYWxlZFNwYWNpbmcgPSB1X2ZpeGVkU3BhY2luZyAqIHVfZ3JpZFNwYWNpbmc7XG4gICAgZmxvYXQgd29ybGRYID0gZmxvYXQoY2VsbC54KSAqIHNjYWxlZFNwYWNpbmcgKyB1X2NlbnRlck9mZnNldC54O1xuICAgIGZsb2F0IHdvcmxkWSA9IGZsb2F0KGNlbGwueSkgKiBzY2FsZWRTcGFjaW5nICsgdV9jZW50ZXJPZmZzZXQueTtcbiAgICByZXR1cm4gdmVjMih3b3JsZFgsIHdvcmxkWSk7XG4gIH1cblxuICAvLyAtLS0gRnVuY3Rpb24gdG8gY2FsY3VsYXRlIFNERiBmb3IgYSBnaXZlbiByb3cgLS0tXG4gIGZsb2F0IGNhbGN1bGF0ZUNvbm5lY3RvclNERihpdmVjMiBiYXNlQ2VsbCwgdmVjMiBmcmFnUG9zLCBmbG9hdCB3b3JsZFJhZEEsIGZsb2F0IHdvcmxkUmFkQiwgZmxvYXQgc2NhbGVkU3BhY2luZykge1xuICAgIGZsb2F0IHNkZiA9IDFlNjsgLy8gRGVmYXVsdCB0byBvdXRzaWRlXG5cbiAgICBmbG9hdCBjbWRDb25uID0gZ2V0Q21kSG9yaXpDb25uZWN0b3IoYmFzZUNlbGwpO1xuICAgIGlmIChjbWRDb25uID4gMC4wKSB7XG4gICAgICAgIGl2ZWMyIHJpZ2h0Q2VsbCA9IGJhc2VDZWxsICsgaXZlYzIoMSwgMCk7XG4gICAgICAgIGZsb2F0IHN0YXRlTCA9IGdldFN0YXRlKGJhc2VDZWxsKTtcbiAgICAgICAgZmxvYXQgc3RhdGVSID0gZ2V0U3RhdGUocmlnaHRDZWxsKTtcblxuICAgICAgICBpZiAoc3RhdGVMID09IDEuMCAmJiBzdGF0ZVIgPT0gMS4wKSB7XG4gICAgICAgICAgICB2ZWMyIGNlbnRlckwgPSBnZXRDZWxsV29ybGRDZW50ZXIoYmFzZUNlbGwpOyAvLyBVc2VzIHNjYWxlZCBzcGFjaW5nIGludGVybmFsbHkgbm93XG4gICAgICAgICAgICB2ZWMyIGNlbnRlclIgPSBnZXRDZWxsV29ybGRDZW50ZXIocmlnaHRDZWxsKTsgLy8gVXNlcyBzY2FsZWQgc3BhY2luZyBpbnRlcm5hbGx5IG5vd1xuXG4gICAgICAgICAgICB2ZWMyIGNvbm5DZW50ZXIgPSAoY2VudGVyTCArIGNlbnRlclIpICogMC41O1xuXG4gICAgICAgICAgICAvLyBVc2Ugc2NhbGVkIHNwYWNpbmcgZm9yIHdpZHRoIGNhbGN1bGF0aW9uIHRvb1xuICAgICAgICAgICAgZmxvYXQgY29ubldpZHRoID0gc2NhbGVkU3BhY2luZzsgLy8gV2lkdGggaXMgc2ltcGx5IHRoZSBkaXN0YW5jZSBiZXR3ZWVuIGNlbnRlcnNcbiAgICAgICAgICAgIC8vIFVzZSBpbm5lciByYWRpdXMgKFJhZGl1c0IpIGZvciB0aGlubmVyIGNvbm5lY3RvciBtYXRjaGluZyBjaXJjbGUgdGhpY2tuZXNzXG4gICAgICAgICAgICAvLyBBZGQgYSBzbWFsbCBlcHNpbG9uIHRvIGVuc3VyZSBvdmVybGFwIGJldHdlZW4gcm93c1xuICAgICAgICAgICAgZmxvYXQgY29ubkhlaWdodCA9IHdvcmxkUmFkQiAqIDIuMCArIDAuMDEgKiB1X2dyaWRTcGFjaW5nOyAvLyBBZGRlZCBzbWFsbCBvdmVybGFwIGJhc2VkIG9uIHNjYWxlXG5cbiAgICAgICAgICAgIHZlYzIgcCA9IGZyYWdQb3MgLSBjb25uQ2VudGVyO1xuXG4gICAgICAgICAgICBzZGYgPSBzZEJveDJEKHAsIHZlYzIoY29ubldpZHRoICogMC41LCBjb25uSGVpZ2h0ICogMC41KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNkZjtcbiAgfVxuXG5cbiAgdm9pZCBtYWluKCkge1xuICAgIC8vIENhbGN1bGF0ZSBmcmFnbWVudCdzIHdvcmxkIHBvc2l0aW9uXG4gICAgdmVjMiBwbGFuZU9yaWdpbiA9IC11X3BsYW5lU2l6ZSAqIDAuNTtcbiAgICB2ZWMyIGZyYWdXb3JsZFBvcyA9IHBsYW5lT3JpZ2luICsgdlV2ICogdV9wbGFuZVNpemU7XG5cbiAgICAvLyBDYWxjdWxhdGUgc2NhbGVkIHNwYWNpbmcgY29uc2lzdGVudGx5XG4gICAgZmxvYXQgc2NhbGVkU3BhY2luZyA9IHVfZml4ZWRTcGFjaW5nICogdV9ncmlkU3BhY2luZztcblxuICAgIC8vIERldGVybWluZSB0aGUgcG90ZW50aWFsIGJvdHRvbS1sZWZ0IGNlbGwgYmFzZWQgb24gZmxvb3IsIHVzaW5nIHNjYWxlZCBzcGFjaW5nXG4gICAgLy8gQWRkIGEgc21hbGwgb2Zmc2V0ICgwLjUpIGJlZm9yZSBmbG9vcmluZyB0byBoYW5kbGUgcG9zaXRpb25zIGV4YWN0bHkgb24gdGhlIGJvdW5kYXJ5IGJldHRlcj8gTWF5YmUgbm90IG5lZWRlZCB5ZXQuXG4gICAgdmVjMiBncmlkQ29vcmQgPSAoZnJhZ1dvcmxkUG9zIC0gdV9jZW50ZXJPZmZzZXQpIC8gc2NhbGVkU3BhY2luZztcbiAgICBpdmVjMiBjZWxsX2JsX2N1cnJlbnQgPSBpdmVjMihmbG9vcihncmlkQ29vcmQpKTsgLy8gQ2VsbCBmb3IgdGhlIGN1cnJlbnQgcm93IGZsb29yXG5cbiAgICAvLyBEZWZpbmUgdGhlIGNlbGwgZm9yIHRoZSByb3cgYWJvdmVcbiAgICBpdmVjMiBjZWxsX2JsX2Fib3ZlID0gY2VsbF9ibF9jdXJyZW50ICsgaXZlYzIoMCwgMSk7XG5cbiAgICAvLyBDYWxjdWxhdGUgd29ybGQtc3BhY2UgcmFkaWkgKHRoZXNlIGFyZSBhbHJlYWR5IHNjYWxlZCBieSB1X2dyaWRTcGFjaW5nIGluIEdyaWRTY2VuZSBhbmQgcGFzc2VkKVxuICAgIC8vIFdhaXQsIHJhZGl1c0EvQiBhcmUgQkFTRSB2YWx1ZXMuIFNjYWxlIHRoZW0gaGVyZS5cbiAgICBmbG9hdCB3b3JsZFJhZGl1c0EgPSB1X3JhZGl1c0EgKiB1X2dyaWRTcGFjaW5nO1xuICAgIGZsb2F0IHdvcmxkUmFkaXVzQiA9IHVfcmFkaXVzQiAqIHVfZ3JpZFNwYWNpbmc7XG5cbiAgICAvLyBDYWxjdWxhdGUgU0RGIGZvciB0aGUgY29ubmVjdG9yIHBvdGVudGlhbGx5IGluIHRoZSBjdXJyZW50IHJvd1xuICAgIGZsb2F0IHNkZl9jdXJyZW50ID0gY2FsY3VsYXRlQ29ubmVjdG9yU0RGKGNlbGxfYmxfY3VycmVudCwgZnJhZ1dvcmxkUG9zLCB3b3JsZFJhZGl1c0EsIHdvcmxkUmFkaXVzQiwgc2NhbGVkU3BhY2luZyk7XG5cbiAgICAvLyBDYWxjdWxhdGUgU0RGIGZvciB0aGUgY29ubmVjdG9yIHBvdGVudGlhbGx5IGluIHRoZSByb3cgYWJvdmVcbiAgICBmbG9hdCBzZGZfYWJvdmUgPSBjYWxjdWxhdGVDb25uZWN0b3JTREYoY2VsbF9ibF9hYm92ZSwgZnJhZ1dvcmxkUG9zLCB3b3JsZFJhZGl1c0EsIHdvcmxkUmFkaXVzQiwgc2NhbGVkU3BhY2luZyk7XG5cbiAgICAvLyBUaGUgZmluYWwgU0RGIGlzIHRoZSBtaW5pbXVtIG9mIHRoZSB0d28gKGNsb3Nlc3QgY29ubmVjdG9yIHdpbnMpXG4gICAgZmxvYXQgZmluYWxTZGYgPSBtaW4oc2RmX2N1cnJlbnQsIHNkZl9hYm92ZSk7XG5cbiAgICAvLyBGaW5hbCBPdXRwdXQ6IERyYXcgaWYgaW5zaWRlIHRoZSBjb21iaW5lZCBTREZcbiAgICBpZiAoZmluYWxTZGYgPCAwLjApIHtcbiAgICAgIGZsb2F0IHNtb290aEZhY3RvciA9IGZ3aWR0aChmaW5hbFNkZikgKiAwLjg7IC8vIEFudGktYWxpYXNpbmdcbiAgICAgIGZsb2F0IGFscGhhID0gc21vb3Roc3RlcChzbW9vdGhGYWN0b3IsIC1zbW9vdGhGYWN0b3IsIGZpbmFsU2RmKTtcblxuICAgICAgaWYgKGFscGhhID4gMC4wMSkge1xuICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIGFscGhhKTsgLy8gQmxhY2sgY29ubmVjdG9yXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaXNjYXJkOyAvLyBEaXNjYXJkIHRyYW5zcGFyZW50IGZyYWdtZW50c1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkaXNjYXJkOyAvLyBEaXNjYXJkIGZyYWdtZW50cyBvdXRzaWRlIHRoZSBzaGFwZVxuICAgIH1cbiAgfVxuYDtcblxuLy8gQ3JlYXRlIHRoZSBzaGFkZXIgbWF0ZXJpYWxcbmNvbnN0IENtZEhvcml6Q29ubmVjdG9yTWF0ZXJpYWwgPSBzaGFkZXJNYXRlcmlhbChcbiAge1xuICAgIHVfc3RhdGVUZXh0dXJlOiBudWxsLCAgICAgICAgICAgICAvLyBXaWxsIGJlIHBhc3NlZCBmcm9tIEdyaWRTY2VuZVxuICAgIHVfY21kSG9yaXpDb25uZWN0b3JUZXh0dXJlOiBudWxsLCAvLyBXaWxsIGJlIHBhc3NlZCBmcm9tIEdyaWRTY2VuZVxuICAgIHVfZ3JpZERpbWVuc2lvbnM6IG5ldyBUSFJFRS5WZWN0b3IyKDEwLCAxMCksXG4gICAgdV90ZXh0dXJlUmVzb2x1dGlvbjogbmV3IFRIUkVFLlZlY3RvcjIoMTAsIDEwKSwgLy8gU2hvdWxkIG1hdGNoIHN0YXRlVGV4dHVyZSBzaXplXG4gICAgdV9yYWRpdXNBOiBCQVNFX1JBRElVU19BLFxuICAgIHVfcmFkaXVzQjogQkFTRV9SQURJVVNfQixcbiAgICB1X2dyaWRTcGFjaW5nOiAxLjAsIC8vIERlZmF1bHQgc2NhbGVcbiAgICB1X2ZpeGVkU3BhY2luZzogRklYRURfU1BBQ0lORywgLy8gUGFzcyB0aGUgYmFzZSBmaXhlZCBzcGFjaW5nXG4gICAgdV9jZW50ZXJPZmZzZXQ6IG5ldyBUSFJFRS5WZWN0b3IyKDAsIDApLFxuICAgIHVfcGxhbmVTaXplOiBuZXcgVEhSRUUuVmVjdG9yMigxMCwgMTApLFxuICB9LFxuICB2ZXJ0ZXhTaGFkZXIsXG4gIGZyYWdtZW50U2hhZGVyXG4pO1xuXG4vLyBFeHRlbmQgUjNGXG5leHRlbmQoeyBDbWRIb3JpekNvbm5lY3Rvck1hdGVyaWFsIH0pO1xuXG4vLyBEZWZpbmUgVHlwZVNjcmlwdCB0eXBlIGZvciBKU1ggdXNhZ2VcbmRlY2xhcmUgZ2xvYmFsIHtcbiAgbmFtZXNwYWNlIEpTWCB7XG4gICAgaW50ZXJmYWNlIEludHJpbnNpY0VsZW1lbnRzIHtcbiAgICAgIGNtZEhvcml6Q29ubmVjdG9yTWF0ZXJpYWw6IGFueTsgLy8gVXNlICdhbnknIG9yIGRlZmluZSBzcGVjaWZpYyB0eXBlc1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDbWRIb3JpekNvbm5lY3Rvck1hdGVyaWFsOyAiXSwibmFtZXMiOlsiVEhSRUUiLCJzaGFkZXJNYXRlcmlhbCIsImV4dGVuZCIsIkJBU0VfUkFESVVTX0EiLCJCQVNFX1JBRElVU19CIiwiRklYRURfU1BBQ0lORyIsInZlcnRleFNoYWRlciIsImZyYWdtZW50U2hhZGVyIiwiQ21kSG9yaXpDb25uZWN0b3JNYXRlcmlhbCIsInVfc3RhdGVUZXh0dXJlIiwidV9jbWRIb3JpekNvbm5lY3RvclRleHR1cmUiLCJ1X2dyaWREaW1lbnNpb25zIiwiVmVjdG9yMiIsInVfdGV4dHVyZVJlc29sdXRpb24iLCJ1X3JhZGl1c0EiLCJ1X3JhZGl1c0IiLCJ1X2dyaWRTcGFjaW5nIiwidV9maXhlZFNwYWNpbmciLCJ1X2NlbnRlck9mZnNldCIsInVfcGxhbmVTaXplIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./components/CmdHorizConnectorMaterial.tsx\n");

/***/ }),

/***/ "./components/ConnectorMaterial.tsx":
/*!******************************************!*\
  !*** ./components/ConnectorMaterial.tsx ***!
  \******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-three/drei */ \"@react-three/drei\");\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_react_three_drei__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-three/fiber */ \"@react-three/fiber\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__);\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([three__WEBPACK_IMPORTED_MODULE_0__]);\nthree__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n// Define constants matching GridScene for defaults\n// Moved to top to fix linter errors\nconst BASE_GRID_SPACING = 1.0;\nconst BASE_RADIUS_A = 0.5; // Outer radius relative to spacing=1\nconst BASE_RADIUS_B = 0.4; // Inner radius relative to spacing=1\n// Fixed spacing is BASE_RADIUS_A + BASE_RADIUS_B = 0.9\nconst FIXED_SPACING = BASE_RADIUS_A + BASE_RADIUS_B;\n// Define connector types as constants - must match GridScene.tsx\nconst CONNECTOR_NONE = 0;\nconst CONNECTOR_DIAG_TL_BR = 1; // Diagonal \\\nconst CONNECTOR_DIAG_BL_TR = 2; // Diagonal /\nconst CONNECTOR_HORIZ_CMD = 3; // New: Cmd-click horizontal connector\n// Vertex shader: Pass UVs\nconst vertexShader = /*glsl*/ `\n  varying vec2 vUv;\n  void main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  }\n`;\n// Fragment shader: Updated to use world space coordinates\nconst fragmentShader = /*glsl*/ `\n  uniform sampler2D u_stateTexture;\n  uniform sampler2D u_intendedConnectorTexture;\n  uniform vec2 u_gridDimensions;    // Grid size (width, height) in cells\n  uniform vec2 u_textureResolution; // Texture size (width, height) in pixels\n  uniform float u_radiusA;          // Outer radius (base value)\n  uniform float u_radiusB;          // Inner radius (base value)\n  uniform float u_gridSpacing;      // Visual scale factor\n  // World space uniforms\n  uniform vec2 u_centerOffset;      // World offset for centering grid\n  uniform vec2 u_planeSize;         // World size of connector plane\n\n  varying vec2 vUv;\n\n  // --- SDF Helper Functions ---\n  float sdCircle(vec2 p, float r) {\n    return length(p) - r;\n  }\n\n  float sdBox(vec2 p, vec2 b) {\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n  }\n\n  float sdSegment(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n  }\n\n  float sdCapsule(vec2 p, vec2 a, vec2 b, float r) {\n    return sdSegment(p, a, b) - r;\n  }\n\n  float opUnion(float d1, float d2) { return min(d1, d2); }\n  float opIntersection(float d1, float d2) { return max(d1, d2); }\n  float opSubtraction(float d1, float d2) { return max(d1, -d2); }\n\n  // --- State Sampling Helper ---\n  float getState(ivec2 cellCoord) {\n    ivec2 clampedCoord = clamp(cellCoord, ivec2(0), ivec2(u_textureResolution) - ivec2(1));\n    if (cellCoord != clampedCoord) return 0.0;\n    return texelFetch(u_stateTexture, clampedCoord, 0).r;\n  }\n\n  // --- Intended Connector Sampling ---\n  float getIntendedConnector(ivec2 cellCoord) {\n    ivec2 maxCoord = ivec2(u_textureResolution) - ivec2(1);\n    if (cellCoord.x < 0 || cellCoord.x >= maxCoord.x || \n        cellCoord.y < 0 || cellCoord.y >= maxCoord.y) {\n      return 0.0;\n    }\n    return texelFetch(u_intendedConnectorTexture, cellCoord, 0).r;\n  }\n\n  // --- Get Cell Center in World Space ---\n  vec2 getCellWorldCenter(ivec2 cell) {\n    float worldX = float(cell.x) * ${FIXED_SPACING} + u_centerOffset.x;\n    float worldY = float(cell.y) * ${FIXED_SPACING} + u_centerOffset.y;\n    return vec2(worldX, worldY);\n  }\n\n  void main() {\n    // Calculate fragment's world position\n    vec2 planeOrigin = -u_planeSize * 0.5; // Assuming plane is centered at (0,0)\n    vec2 fragWorldPos = planeOrigin + vUv * u_planeSize;\n    \n    // Determine which cell this fragment is in (find nearest cell)\n    vec2 gridCoord = (fragWorldPos - u_centerOffset) / ${FIXED_SPACING};\n    ivec2 cell_bl = ivec2(floor(gridCoord));\n    \n    // Define neighbor cells\n    ivec2 cell_br = cell_bl + ivec2(1, 0);\n    ivec2 cell_tl = cell_bl + ivec2(0, 1);\n    ivec2 cell_tr = cell_bl + ivec2(1, 1);\n\n    // Get states for all 4 cells around this fragment\n    float state_bl = getState(cell_bl);\n    float state_br = getState(cell_br);\n    float state_tl = getState(cell_tl);\n    float state_tr = getState(cell_tr);\n\n    // Get intended connector for this cell group\n    float intendedConnector = getIntendedConnector(cell_bl);\n\n    // Get cell centers in world space\n    vec2 center_bl = getCellWorldCenter(cell_bl);\n    vec2 center_br = getCellWorldCenter(cell_br);\n    vec2 center_tl = getCellWorldCenter(cell_tl);\n    vec2 center_tr = getCellWorldCenter(cell_tr);\n\n    // Calculate bounding box in world space\n    vec2 bboxCenter = (center_bl + center_br + center_tl + center_tr) * 0.25;\n    vec2 bboxHalfSize = vec2(${FIXED_SPACING} * 0.5);\n\n    // Calculate world-space radii\n    float worldRadiusA = u_radiusA * u_gridSpacing;\n    float worldRadiusB = u_radiusB * u_gridSpacing;\n\n    float finalSdf = 1e6;\n\n    // --- Diagonal \\\\ (TL to BR) Connector ---\n    if (state_tl == 1.0 && state_br == 1.0 && intendedConnector == 1.0) {\n      // Create connector path\n      float sdf_capsule_tl_br = sdCapsule(fragWorldPos, center_tl, center_br, worldRadiusB);\n      \n      // Must be outside the outer circles of TR and BL\n      float sdf_outside_tr_outer = sdCircle(fragWorldPos - center_tr, worldRadiusA);\n      float sdf_outside_bl_outer = sdCircle(fragWorldPos - center_bl, worldRadiusA);\n      \n      // Combine all constraints\n      float sdf_diag1 = sdf_capsule_tl_br;\n      sdf_diag1 = max(sdf_diag1, -sdf_outside_tr_outer);\n      sdf_diag1 = max(sdf_diag1, -sdf_outside_bl_outer);\n\n      finalSdf = min(finalSdf, sdf_diag1);\n    }\n\n    // --- Diagonal / (BL to TR) Connector ---\n    if (state_bl == 1.0 && state_tr == 1.0 && intendedConnector == 2.0) {\n      // Create connector path\n      float sdf_capsule_bl_tr = sdCapsule(fragWorldPos, center_bl, center_tr, worldRadiusB);\n      \n      // Must be outside the outer circles of TL and BR\n      float sdf_outside_tl_outer = sdCircle(fragWorldPos - center_tl, worldRadiusA);\n      float sdf_outside_br_outer = sdCircle(fragWorldPos - center_br, worldRadiusA);\n      \n      // Combine all constraints\n      float sdf_diag2 = sdf_capsule_bl_tr;\n      sdf_diag2 = max(sdf_diag2, -sdf_outside_tl_outer);\n      sdf_diag2 = max(sdf_diag2, -sdf_outside_br_outer);\n\n      finalSdf = min(finalSdf, sdf_diag2);\n    }\n\n    // --- Horizontal (BL to BR) Connector ---\n    if (state_bl == 1.0 && state_br == 1.0 && intendedConnector == 4.0) {\n      float sdf_h_bottom = sdCapsule(fragWorldPos, center_bl, center_br, worldRadiusB);\n      finalSdf = min(finalSdf, sdf_h_bottom);\n    }\n\n    // --- Horizontal (TL to TR) Connector ---\n    if (state_tl == 1.0 && state_tr == 1.0 && intendedConnector == 3.0) {\n      float sdf_h_top = sdCapsule(fragWorldPos, center_tl, center_tr, worldRadiusB);\n      finalSdf = min(finalSdf, sdf_h_top);\n    }\n\n    // --- Final Output with Anti-aliasing ---\n    if (finalSdf < 0.0) {\n      float smoothFactor = fwidth(finalSdf) * 0.8;\n      float alpha = smoothstep(smoothFactor, -smoothFactor, finalSdf);\n      \n      if (alpha > 0.01) {\n        gl_FragColor = vec4(0.0, 0.0, 0.0, alpha);\n      } else {\n        discard;\n      }\n    } else {\n      discard;\n    }\n  }\n`;\n// Create the shader material\nconst ConnectorMaterial = (0,_react_three_drei__WEBPACK_IMPORTED_MODULE_1__.shaderMaterial)({\n    u_stateTexture: null,\n    u_intendedConnectorTexture: null,\n    u_gridDimensions: new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(10, 10),\n    u_textureResolution: new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(10, 10),\n    u_radiusA: BASE_RADIUS_A,\n    u_radiusB: BASE_RADIUS_B,\n    u_gridSpacing: BASE_GRID_SPACING,\n    // World space uniforms\n    u_centerOffset: new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(0, 0),\n    u_planeSize: new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(10, 10)\n}, vertexShader, fragmentShader);\n// Extend R3F\n(0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.extend)({\n    ConnectorMaterial\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ConnectorMaterial); // Define constants matching GridScene for defaults (optional, but helps IDE)\n // Moved to top - Removing these commented out versions\n // const BASE_GRID_SPACING = 1.0;\n // const BASE_RADIUS_A = 0.5;\n // const BASE_RADIUS_B = 0.4; \n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL0Nvbm5lY3Rvck1hdGVyaWFsLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBK0I7QUFDb0I7QUFDUDtBQUU1QyxtREFBbUQ7QUFDbkQsb0NBQW9DO0FBQ3BDLE1BQU1HLG9CQUFvQjtBQUMxQixNQUFNQyxnQkFBZ0IsS0FBSyxxQ0FBcUM7QUFDaEUsTUFBTUMsZ0JBQWdCLEtBQUsscUNBQXFDO0FBQ2hFLHVEQUF1RDtBQUN2RCxNQUFNQyxnQkFBZ0JGLGdCQUFnQkM7QUFFdEMsaUVBQWlFO0FBQ2pFLE1BQU1FLGlCQUFpQjtBQUN2QixNQUFNQyx1QkFBdUIsR0FBRyxhQUFhO0FBQzdDLE1BQU1DLHVCQUF1QixHQUFHLGFBQWE7QUFDN0MsTUFBTUMsc0JBQXNCLEdBQUksc0NBQXNDO0FBRXRFLDBCQUEwQjtBQUMxQixNQUFNQyxlQUFlLE1BQU0sR0FBRyxDQUFDOzs7Ozs7QUFNL0IsQ0FBQztBQUVELDBEQUEwRDtBQUMxRCxNQUFNQyxpQkFBaUIsTUFBTSxHQUFHLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzttQ0F5REUsRUFBRU4sY0FBYzttQ0FDaEIsRUFBRUEsY0FBYzs7Ozs7Ozs7Ozt1REFVSSxFQUFFQSxjQUFjOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzZCQXlCMUMsRUFBRUEsY0FBYzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvRTdDLENBQUM7QUFFRCw2QkFBNkI7QUFDN0IsTUFBTU8sb0JBQW9CWixpRUFBY0EsQ0FDdEM7SUFDRWEsZ0JBQWdCO0lBQ2hCQyw0QkFBNEI7SUFDNUJDLGtCQUFrQixJQUFJaEIsMENBQWEsQ0FBQyxJQUFJO0lBQ3hDa0IscUJBQXFCLElBQUlsQiwwQ0FBYSxDQUFDLElBQUk7SUFDM0NtQixXQUFXZjtJQUNYZ0IsV0FBV2Y7SUFDWGdCLGVBQWVsQjtJQUNmLHVCQUF1QjtJQUN2Qm1CLGdCQUFnQixJQUFJdEIsMENBQWEsQ0FBQyxHQUFHO0lBQ3JDdUIsYUFBYSxJQUFJdkIsMENBQWEsQ0FBQyxJQUFJO0FBQ3JDLEdBQ0FXLGNBQ0FDO0FBR0YsYUFBYTtBQUNiViwwREFBTUEsQ0FBQztJQUFFVztBQUFrQjtBQVczQixpRUFBZUEsaUJBQWlCQSxFQUFDLENBQ2pDLDZFQUE2RTtDQUM3RSx1REFBdUQ7Q0FDdkQsaUNBQWlDO0NBQ2pDLDZCQUE2QjtDQUM3Qiw4QkFBOEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWJnbC1kb3QtZ3JpZC1tdnAvLi9jb21wb25lbnRzL0Nvbm5lY3Rvck1hdGVyaWFsLnRzeD82MjUzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcbmltcG9ydCB7IHNoYWRlck1hdGVyaWFsIH0gZnJvbSAnQHJlYWN0LXRocmVlL2RyZWknO1xuaW1wb3J0IHsgZXh0ZW5kIH0gZnJvbSAnQHJlYWN0LXRocmVlL2ZpYmVyJztcblxuLy8gRGVmaW5lIGNvbnN0YW50cyBtYXRjaGluZyBHcmlkU2NlbmUgZm9yIGRlZmF1bHRzXG4vLyBNb3ZlZCB0byB0b3AgdG8gZml4IGxpbnRlciBlcnJvcnNcbmNvbnN0IEJBU0VfR1JJRF9TUEFDSU5HID0gMS4wO1xuY29uc3QgQkFTRV9SQURJVVNfQSA9IDAuNTsgLy8gT3V0ZXIgcmFkaXVzIHJlbGF0aXZlIHRvIHNwYWNpbmc9MVxuY29uc3QgQkFTRV9SQURJVVNfQiA9IDAuNDsgLy8gSW5uZXIgcmFkaXVzIHJlbGF0aXZlIHRvIHNwYWNpbmc9MVxuLy8gRml4ZWQgc3BhY2luZyBpcyBCQVNFX1JBRElVU19BICsgQkFTRV9SQURJVVNfQiA9IDAuOVxuY29uc3QgRklYRURfU1BBQ0lORyA9IEJBU0VfUkFESVVTX0EgKyBCQVNFX1JBRElVU19CO1xuXG4vLyBEZWZpbmUgY29ubmVjdG9yIHR5cGVzIGFzIGNvbnN0YW50cyAtIG11c3QgbWF0Y2ggR3JpZFNjZW5lLnRzeFxuY29uc3QgQ09OTkVDVE9SX05PTkUgPSAwO1xuY29uc3QgQ09OTkVDVE9SX0RJQUdfVExfQlIgPSAxOyAvLyBEaWFnb25hbCBcXFxuY29uc3QgQ09OTkVDVE9SX0RJQUdfQkxfVFIgPSAyOyAvLyBEaWFnb25hbCAvXG5jb25zdCBDT05ORUNUT1JfSE9SSVpfQ01EID0gMzsgIC8vIE5ldzogQ21kLWNsaWNrIGhvcml6b250YWwgY29ubmVjdG9yXG5cbi8vIFZlcnRleCBzaGFkZXI6IFBhc3MgVVZzXG5jb25zdCB2ZXJ0ZXhTaGFkZXIgPSAvKmdsc2wqLyBgXG4gIHZhcnlpbmcgdmVjMiB2VXY7XG4gIHZvaWQgbWFpbigpIHtcbiAgICB2VXYgPSB1djtcbiAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjApO1xuICB9XG5gO1xuXG4vLyBGcmFnbWVudCBzaGFkZXI6IFVwZGF0ZWQgdG8gdXNlIHdvcmxkIHNwYWNlIGNvb3JkaW5hdGVzXG5jb25zdCBmcmFnbWVudFNoYWRlciA9IC8qZ2xzbCovIGBcbiAgdW5pZm9ybSBzYW1wbGVyMkQgdV9zdGF0ZVRleHR1cmU7XG4gIHVuaWZvcm0gc2FtcGxlcjJEIHVfaW50ZW5kZWRDb25uZWN0b3JUZXh0dXJlO1xuICB1bmlmb3JtIHZlYzIgdV9ncmlkRGltZW5zaW9uczsgICAgLy8gR3JpZCBzaXplICh3aWR0aCwgaGVpZ2h0KSBpbiBjZWxsc1xuICB1bmlmb3JtIHZlYzIgdV90ZXh0dXJlUmVzb2x1dGlvbjsgLy8gVGV4dHVyZSBzaXplICh3aWR0aCwgaGVpZ2h0KSBpbiBwaXhlbHNcbiAgdW5pZm9ybSBmbG9hdCB1X3JhZGl1c0E7ICAgICAgICAgIC8vIE91dGVyIHJhZGl1cyAoYmFzZSB2YWx1ZSlcbiAgdW5pZm9ybSBmbG9hdCB1X3JhZGl1c0I7ICAgICAgICAgIC8vIElubmVyIHJhZGl1cyAoYmFzZSB2YWx1ZSlcbiAgdW5pZm9ybSBmbG9hdCB1X2dyaWRTcGFjaW5nOyAgICAgIC8vIFZpc3VhbCBzY2FsZSBmYWN0b3JcbiAgLy8gV29ybGQgc3BhY2UgdW5pZm9ybXNcbiAgdW5pZm9ybSB2ZWMyIHVfY2VudGVyT2Zmc2V0OyAgICAgIC8vIFdvcmxkIG9mZnNldCBmb3IgY2VudGVyaW5nIGdyaWRcbiAgdW5pZm9ybSB2ZWMyIHVfcGxhbmVTaXplOyAgICAgICAgIC8vIFdvcmxkIHNpemUgb2YgY29ubmVjdG9yIHBsYW5lXG5cbiAgdmFyeWluZyB2ZWMyIHZVdjtcblxuICAvLyAtLS0gU0RGIEhlbHBlciBGdW5jdGlvbnMgLS0tXG4gIGZsb2F0IHNkQ2lyY2xlKHZlYzIgcCwgZmxvYXQgcikge1xuICAgIHJldHVybiBsZW5ndGgocCkgLSByO1xuICB9XG5cbiAgZmxvYXQgc2RCb3godmVjMiBwLCB2ZWMyIGIpIHtcbiAgICB2ZWMyIGQgPSBhYnMocCkgLSBiO1xuICAgIHJldHVybiBsZW5ndGgobWF4KGQsIDAuMCkpICsgbWluKG1heChkLngsIGQueSksIDAuMCk7XG4gIH1cblxuICBmbG9hdCBzZFNlZ21lbnQodmVjMiBwLCB2ZWMyIGEsIHZlYzIgYikge1xuICAgIHZlYzIgcGEgPSBwIC0gYSwgYmEgPSBiIC0gYTtcbiAgICBmbG9hdCBoID0gY2xhbXAoZG90KHBhLCBiYSkgLyBkb3QoYmEsIGJhKSwgMC4wLCAxLjApO1xuICAgIHJldHVybiBsZW5ndGgocGEgLSBiYSAqIGgpO1xuICB9XG5cbiAgZmxvYXQgc2RDYXBzdWxlKHZlYzIgcCwgdmVjMiBhLCB2ZWMyIGIsIGZsb2F0IHIpIHtcbiAgICByZXR1cm4gc2RTZWdtZW50KHAsIGEsIGIpIC0gcjtcbiAgfVxuXG4gIGZsb2F0IG9wVW5pb24oZmxvYXQgZDEsIGZsb2F0IGQyKSB7IHJldHVybiBtaW4oZDEsIGQyKTsgfVxuICBmbG9hdCBvcEludGVyc2VjdGlvbihmbG9hdCBkMSwgZmxvYXQgZDIpIHsgcmV0dXJuIG1heChkMSwgZDIpOyB9XG4gIGZsb2F0IG9wU3VidHJhY3Rpb24oZmxvYXQgZDEsIGZsb2F0IGQyKSB7IHJldHVybiBtYXgoZDEsIC1kMik7IH1cblxuICAvLyAtLS0gU3RhdGUgU2FtcGxpbmcgSGVscGVyIC0tLVxuICBmbG9hdCBnZXRTdGF0ZShpdmVjMiBjZWxsQ29vcmQpIHtcbiAgICBpdmVjMiBjbGFtcGVkQ29vcmQgPSBjbGFtcChjZWxsQ29vcmQsIGl2ZWMyKDApLCBpdmVjMih1X3RleHR1cmVSZXNvbHV0aW9uKSAtIGl2ZWMyKDEpKTtcbiAgICBpZiAoY2VsbENvb3JkICE9IGNsYW1wZWRDb29yZCkgcmV0dXJuIDAuMDtcbiAgICByZXR1cm4gdGV4ZWxGZXRjaCh1X3N0YXRlVGV4dHVyZSwgY2xhbXBlZENvb3JkLCAwKS5yO1xuICB9XG5cbiAgLy8gLS0tIEludGVuZGVkIENvbm5lY3RvciBTYW1wbGluZyAtLS1cbiAgZmxvYXQgZ2V0SW50ZW5kZWRDb25uZWN0b3IoaXZlYzIgY2VsbENvb3JkKSB7XG4gICAgaXZlYzIgbWF4Q29vcmQgPSBpdmVjMih1X3RleHR1cmVSZXNvbHV0aW9uKSAtIGl2ZWMyKDEpO1xuICAgIGlmIChjZWxsQ29vcmQueCA8IDAgfHwgY2VsbENvb3JkLnggPj0gbWF4Q29vcmQueCB8fCBcbiAgICAgICAgY2VsbENvb3JkLnkgPCAwIHx8IGNlbGxDb29yZC55ID49IG1heENvb3JkLnkpIHtcbiAgICAgIHJldHVybiAwLjA7XG4gICAgfVxuICAgIHJldHVybiB0ZXhlbEZldGNoKHVfaW50ZW5kZWRDb25uZWN0b3JUZXh0dXJlLCBjZWxsQ29vcmQsIDApLnI7XG4gIH1cblxuICAvLyAtLS0gR2V0IENlbGwgQ2VudGVyIGluIFdvcmxkIFNwYWNlIC0tLVxuICB2ZWMyIGdldENlbGxXb3JsZENlbnRlcihpdmVjMiBjZWxsKSB7XG4gICAgZmxvYXQgd29ybGRYID0gZmxvYXQoY2VsbC54KSAqICR7RklYRURfU1BBQ0lOR30gKyB1X2NlbnRlck9mZnNldC54O1xuICAgIGZsb2F0IHdvcmxkWSA9IGZsb2F0KGNlbGwueSkgKiAke0ZJWEVEX1NQQUNJTkd9ICsgdV9jZW50ZXJPZmZzZXQueTtcbiAgICByZXR1cm4gdmVjMih3b3JsZFgsIHdvcmxkWSk7XG4gIH1cblxuICB2b2lkIG1haW4oKSB7XG4gICAgLy8gQ2FsY3VsYXRlIGZyYWdtZW50J3Mgd29ybGQgcG9zaXRpb25cbiAgICB2ZWMyIHBsYW5lT3JpZ2luID0gLXVfcGxhbmVTaXplICogMC41OyAvLyBBc3N1bWluZyBwbGFuZSBpcyBjZW50ZXJlZCBhdCAoMCwwKVxuICAgIHZlYzIgZnJhZ1dvcmxkUG9zID0gcGxhbmVPcmlnaW4gKyB2VXYgKiB1X3BsYW5lU2l6ZTtcbiAgICBcbiAgICAvLyBEZXRlcm1pbmUgd2hpY2ggY2VsbCB0aGlzIGZyYWdtZW50IGlzIGluIChmaW5kIG5lYXJlc3QgY2VsbClcbiAgICB2ZWMyIGdyaWRDb29yZCA9IChmcmFnV29ybGRQb3MgLSB1X2NlbnRlck9mZnNldCkgLyAke0ZJWEVEX1NQQUNJTkd9O1xuICAgIGl2ZWMyIGNlbGxfYmwgPSBpdmVjMihmbG9vcihncmlkQ29vcmQpKTtcbiAgICBcbiAgICAvLyBEZWZpbmUgbmVpZ2hib3IgY2VsbHNcbiAgICBpdmVjMiBjZWxsX2JyID0gY2VsbF9ibCArIGl2ZWMyKDEsIDApO1xuICAgIGl2ZWMyIGNlbGxfdGwgPSBjZWxsX2JsICsgaXZlYzIoMCwgMSk7XG4gICAgaXZlYzIgY2VsbF90ciA9IGNlbGxfYmwgKyBpdmVjMigxLCAxKTtcblxuICAgIC8vIEdldCBzdGF0ZXMgZm9yIGFsbCA0IGNlbGxzIGFyb3VuZCB0aGlzIGZyYWdtZW50XG4gICAgZmxvYXQgc3RhdGVfYmwgPSBnZXRTdGF0ZShjZWxsX2JsKTtcbiAgICBmbG9hdCBzdGF0ZV9iciA9IGdldFN0YXRlKGNlbGxfYnIpO1xuICAgIGZsb2F0IHN0YXRlX3RsID0gZ2V0U3RhdGUoY2VsbF90bCk7XG4gICAgZmxvYXQgc3RhdGVfdHIgPSBnZXRTdGF0ZShjZWxsX3RyKTtcblxuICAgIC8vIEdldCBpbnRlbmRlZCBjb25uZWN0b3IgZm9yIHRoaXMgY2VsbCBncm91cFxuICAgIGZsb2F0IGludGVuZGVkQ29ubmVjdG9yID0gZ2V0SW50ZW5kZWRDb25uZWN0b3IoY2VsbF9ibCk7XG5cbiAgICAvLyBHZXQgY2VsbCBjZW50ZXJzIGluIHdvcmxkIHNwYWNlXG4gICAgdmVjMiBjZW50ZXJfYmwgPSBnZXRDZWxsV29ybGRDZW50ZXIoY2VsbF9ibCk7XG4gICAgdmVjMiBjZW50ZXJfYnIgPSBnZXRDZWxsV29ybGRDZW50ZXIoY2VsbF9icik7XG4gICAgdmVjMiBjZW50ZXJfdGwgPSBnZXRDZWxsV29ybGRDZW50ZXIoY2VsbF90bCk7XG4gICAgdmVjMiBjZW50ZXJfdHIgPSBnZXRDZWxsV29ybGRDZW50ZXIoY2VsbF90cik7XG5cbiAgICAvLyBDYWxjdWxhdGUgYm91bmRpbmcgYm94IGluIHdvcmxkIHNwYWNlXG4gICAgdmVjMiBiYm94Q2VudGVyID0gKGNlbnRlcl9ibCArIGNlbnRlcl9iciArIGNlbnRlcl90bCArIGNlbnRlcl90cikgKiAwLjI1O1xuICAgIHZlYzIgYmJveEhhbGZTaXplID0gdmVjMigke0ZJWEVEX1NQQUNJTkd9ICogMC41KTtcblxuICAgIC8vIENhbGN1bGF0ZSB3b3JsZC1zcGFjZSByYWRpaVxuICAgIGZsb2F0IHdvcmxkUmFkaXVzQSA9IHVfcmFkaXVzQSAqIHVfZ3JpZFNwYWNpbmc7XG4gICAgZmxvYXQgd29ybGRSYWRpdXNCID0gdV9yYWRpdXNCICogdV9ncmlkU3BhY2luZztcblxuICAgIGZsb2F0IGZpbmFsU2RmID0gMWU2O1xuXG4gICAgLy8gLS0tIERpYWdvbmFsIFxcXFwgKFRMIHRvIEJSKSBDb25uZWN0b3IgLS0tXG4gICAgaWYgKHN0YXRlX3RsID09IDEuMCAmJiBzdGF0ZV9iciA9PSAxLjAgJiYgaW50ZW5kZWRDb25uZWN0b3IgPT0gMS4wKSB7XG4gICAgICAvLyBDcmVhdGUgY29ubmVjdG9yIHBhdGhcbiAgICAgIGZsb2F0IHNkZl9jYXBzdWxlX3RsX2JyID0gc2RDYXBzdWxlKGZyYWdXb3JsZFBvcywgY2VudGVyX3RsLCBjZW50ZXJfYnIsIHdvcmxkUmFkaXVzQik7XG4gICAgICBcbiAgICAgIC8vIE11c3QgYmUgb3V0c2lkZSB0aGUgb3V0ZXIgY2lyY2xlcyBvZiBUUiBhbmQgQkxcbiAgICAgIGZsb2F0IHNkZl9vdXRzaWRlX3RyX291dGVyID0gc2RDaXJjbGUoZnJhZ1dvcmxkUG9zIC0gY2VudGVyX3RyLCB3b3JsZFJhZGl1c0EpO1xuICAgICAgZmxvYXQgc2RmX291dHNpZGVfYmxfb3V0ZXIgPSBzZENpcmNsZShmcmFnV29ybGRQb3MgLSBjZW50ZXJfYmwsIHdvcmxkUmFkaXVzQSk7XG4gICAgICBcbiAgICAgIC8vIENvbWJpbmUgYWxsIGNvbnN0cmFpbnRzXG4gICAgICBmbG9hdCBzZGZfZGlhZzEgPSBzZGZfY2Fwc3VsZV90bF9icjtcbiAgICAgIHNkZl9kaWFnMSA9IG1heChzZGZfZGlhZzEsIC1zZGZfb3V0c2lkZV90cl9vdXRlcik7XG4gICAgICBzZGZfZGlhZzEgPSBtYXgoc2RmX2RpYWcxLCAtc2RmX291dHNpZGVfYmxfb3V0ZXIpO1xuXG4gICAgICBmaW5hbFNkZiA9IG1pbihmaW5hbFNkZiwgc2RmX2RpYWcxKTtcbiAgICB9XG5cbiAgICAvLyAtLS0gRGlhZ29uYWwgLyAoQkwgdG8gVFIpIENvbm5lY3RvciAtLS1cbiAgICBpZiAoc3RhdGVfYmwgPT0gMS4wICYmIHN0YXRlX3RyID09IDEuMCAmJiBpbnRlbmRlZENvbm5lY3RvciA9PSAyLjApIHtcbiAgICAgIC8vIENyZWF0ZSBjb25uZWN0b3IgcGF0aFxuICAgICAgZmxvYXQgc2RmX2NhcHN1bGVfYmxfdHIgPSBzZENhcHN1bGUoZnJhZ1dvcmxkUG9zLCBjZW50ZXJfYmwsIGNlbnRlcl90ciwgd29ybGRSYWRpdXNCKTtcbiAgICAgIFxuICAgICAgLy8gTXVzdCBiZSBvdXRzaWRlIHRoZSBvdXRlciBjaXJjbGVzIG9mIFRMIGFuZCBCUlxuICAgICAgZmxvYXQgc2RmX291dHNpZGVfdGxfb3V0ZXIgPSBzZENpcmNsZShmcmFnV29ybGRQb3MgLSBjZW50ZXJfdGwsIHdvcmxkUmFkaXVzQSk7XG4gICAgICBmbG9hdCBzZGZfb3V0c2lkZV9icl9vdXRlciA9IHNkQ2lyY2xlKGZyYWdXb3JsZFBvcyAtIGNlbnRlcl9iciwgd29ybGRSYWRpdXNBKTtcbiAgICAgIFxuICAgICAgLy8gQ29tYmluZSBhbGwgY29uc3RyYWludHNcbiAgICAgIGZsb2F0IHNkZl9kaWFnMiA9IHNkZl9jYXBzdWxlX2JsX3RyO1xuICAgICAgc2RmX2RpYWcyID0gbWF4KHNkZl9kaWFnMiwgLXNkZl9vdXRzaWRlX3RsX291dGVyKTtcbiAgICAgIHNkZl9kaWFnMiA9IG1heChzZGZfZGlhZzIsIC1zZGZfb3V0c2lkZV9icl9vdXRlcik7XG5cbiAgICAgIGZpbmFsU2RmID0gbWluKGZpbmFsU2RmLCBzZGZfZGlhZzIpO1xuICAgIH1cblxuICAgIC8vIC0tLSBIb3Jpem9udGFsIChCTCB0byBCUikgQ29ubmVjdG9yIC0tLVxuICAgIGlmIChzdGF0ZV9ibCA9PSAxLjAgJiYgc3RhdGVfYnIgPT0gMS4wICYmIGludGVuZGVkQ29ubmVjdG9yID09IDQuMCkge1xuICAgICAgZmxvYXQgc2RmX2hfYm90dG9tID0gc2RDYXBzdWxlKGZyYWdXb3JsZFBvcywgY2VudGVyX2JsLCBjZW50ZXJfYnIsIHdvcmxkUmFkaXVzQik7XG4gICAgICBmaW5hbFNkZiA9IG1pbihmaW5hbFNkZiwgc2RmX2hfYm90dG9tKTtcbiAgICB9XG5cbiAgICAvLyAtLS0gSG9yaXpvbnRhbCAoVEwgdG8gVFIpIENvbm5lY3RvciAtLS1cbiAgICBpZiAoc3RhdGVfdGwgPT0gMS4wICYmIHN0YXRlX3RyID09IDEuMCAmJiBpbnRlbmRlZENvbm5lY3RvciA9PSAzLjApIHtcbiAgICAgIGZsb2F0IHNkZl9oX3RvcCA9IHNkQ2Fwc3VsZShmcmFnV29ybGRQb3MsIGNlbnRlcl90bCwgY2VudGVyX3RyLCB3b3JsZFJhZGl1c0IpO1xuICAgICAgZmluYWxTZGYgPSBtaW4oZmluYWxTZGYsIHNkZl9oX3RvcCk7XG4gICAgfVxuXG4gICAgLy8gLS0tIEZpbmFsIE91dHB1dCB3aXRoIEFudGktYWxpYXNpbmcgLS0tXG4gICAgaWYgKGZpbmFsU2RmIDwgMC4wKSB7XG4gICAgICBmbG9hdCBzbW9vdGhGYWN0b3IgPSBmd2lkdGgoZmluYWxTZGYpICogMC44O1xuICAgICAgZmxvYXQgYWxwaGEgPSBzbW9vdGhzdGVwKHNtb290aEZhY3RvciwgLXNtb290aEZhY3RvciwgZmluYWxTZGYpO1xuICAgICAgXG4gICAgICBpZiAoYWxwaGEgPiAwLjAxKSB7XG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgYWxwaGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGlzY2FyZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGlzY2FyZDtcbiAgICB9XG4gIH1cbmA7XG5cbi8vIENyZWF0ZSB0aGUgc2hhZGVyIG1hdGVyaWFsXG5jb25zdCBDb25uZWN0b3JNYXRlcmlhbCA9IHNoYWRlck1hdGVyaWFsKFxuICB7XG4gICAgdV9zdGF0ZVRleHR1cmU6IG51bGwsIFxuICAgIHVfaW50ZW5kZWRDb25uZWN0b3JUZXh0dXJlOiBudWxsLFxuICAgIHVfZ3JpZERpbWVuc2lvbnM6IG5ldyBUSFJFRS5WZWN0b3IyKDEwLCAxMCksXG4gICAgdV90ZXh0dXJlUmVzb2x1dGlvbjogbmV3IFRIUkVFLlZlY3RvcjIoMTAsIDEwKSxcbiAgICB1X3JhZGl1c0E6IEJBU0VfUkFESVVTX0EsXG4gICAgdV9yYWRpdXNCOiBCQVNFX1JBRElVU19CLFxuICAgIHVfZ3JpZFNwYWNpbmc6IEJBU0VfR1JJRF9TUEFDSU5HLFxuICAgIC8vIFdvcmxkIHNwYWNlIHVuaWZvcm1zXG4gICAgdV9jZW50ZXJPZmZzZXQ6IG5ldyBUSFJFRS5WZWN0b3IyKDAsIDApLFxuICAgIHVfcGxhbmVTaXplOiBuZXcgVEhSRUUuVmVjdG9yMigxMCwgMTApLFxuICB9LFxuICB2ZXJ0ZXhTaGFkZXIsXG4gIGZyYWdtZW50U2hhZGVyXG4pO1xuXG4vLyBFeHRlbmQgUjNGXG5leHRlbmQoeyBDb25uZWN0b3JNYXRlcmlhbCB9KTtcblxuLy8gRGVmaW5lIFR5cGVTY3JpcHQgdHlwZSBmb3IgSlNYIHVzYWdlXG5kZWNsYXJlIGdsb2JhbCB7XG4gIG5hbWVzcGFjZSBKU1gge1xuICAgIGludGVyZmFjZSBJbnRyaW5zaWNFbGVtZW50cyB7XG4gICAgICBjb25uZWN0b3JNYXRlcmlhbDogYW55OyBcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29ubmVjdG9yTWF0ZXJpYWw7XG4vLyBEZWZpbmUgY29uc3RhbnRzIG1hdGNoaW5nIEdyaWRTY2VuZSBmb3IgZGVmYXVsdHMgKG9wdGlvbmFsLCBidXQgaGVscHMgSURFKVxuLy8gTW92ZWQgdG8gdG9wIC0gUmVtb3ZpbmcgdGhlc2UgY29tbWVudGVkIG91dCB2ZXJzaW9uc1xuLy8gY29uc3QgQkFTRV9HUklEX1NQQUNJTkcgPSAxLjA7XG4vLyBjb25zdCBCQVNFX1JBRElVU19BID0gMC41O1xuLy8gY29uc3QgQkFTRV9SQURJVVNfQiA9IDAuNDsgXG4iXSwibmFtZXMiOlsiVEhSRUUiLCJzaGFkZXJNYXRlcmlhbCIsImV4dGVuZCIsIkJBU0VfR1JJRF9TUEFDSU5HIiwiQkFTRV9SQURJVVNfQSIsIkJBU0VfUkFESVVTX0IiLCJGSVhFRF9TUEFDSU5HIiwiQ09OTkVDVE9SX05PTkUiLCJDT05ORUNUT1JfRElBR19UTF9CUiIsIkNPTk5FQ1RPUl9ESUFHX0JMX1RSIiwiQ09OTkVDVE9SX0hPUklaX0NNRCIsInZlcnRleFNoYWRlciIsImZyYWdtZW50U2hhZGVyIiwiQ29ubmVjdG9yTWF0ZXJpYWwiLCJ1X3N0YXRlVGV4dHVyZSIsInVfaW50ZW5kZWRDb25uZWN0b3JUZXh0dXJlIiwidV9ncmlkRGltZW5zaW9ucyIsIlZlY3RvcjIiLCJ1X3RleHR1cmVSZXNvbHV0aW9uIiwidV9yYWRpdXNBIiwidV9yYWRpdXNCIiwidV9ncmlkU3BhY2luZyIsInVfY2VudGVyT2Zmc2V0IiwidV9wbGFuZVNpemUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/ConnectorMaterial.tsx\n");

/***/ }),

/***/ "./components/GridScene.tsx":
/*!**********************************!*\
  !*** ./components/GridScene.tsx ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var leva__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! leva */ \"leva\");\n/* harmony import */ var leva__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(leva__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @react-three/fiber */ \"@react-three/fiber\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_react_three_fiber__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _CircleMaterial__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./CircleMaterial */ \"./components/CircleMaterial.tsx\");\n/* harmony import */ var _ConnectorMaterial__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ConnectorMaterial */ \"./components/ConnectorMaterial.tsx\");\n/* harmony import */ var _CmdHorizConnectorMaterial__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./CmdHorizConnectorMaterial */ \"./components/CmdHorizConnectorMaterial.tsx\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./constants */ \"./components/constants.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([three__WEBPACK_IMPORTED_MODULE_2__, _CircleMaterial__WEBPACK_IMPORTED_MODULE_5__, _ConnectorMaterial__WEBPACK_IMPORTED_MODULE_6__, _CmdHorizConnectorMaterial__WEBPACK_IMPORTED_MODULE_7__]);\n([three__WEBPACK_IMPORTED_MODULE_2__, _CircleMaterial__WEBPACK_IMPORTED_MODULE_5__, _ConnectorMaterial__WEBPACK_IMPORTED_MODULE_6__, _CmdHorizConnectorMaterial__WEBPACK_IMPORTED_MODULE_7__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n\n\n\n\n// Stats import commented out - not critical for functionality\n// import Stats from 'three/addons/libs/stats.module';\n\n// === Feature 1: Grid Data & Configuration ===\n// Constants for base geometry - REMOVED, now imported\n// const BASE_RADIUS_A = 0.5; // Outer radius\n// const BASE_RADIUS_B = 0.4; // Inner radius\n// const FIXED_SPACING = BASE_RADIUS_A + BASE_RADIUS_B; // 0.9\nconst BASE_GRID_SPACING = 1.0; // Keep for reference if needed\n// Helper Functions\nconst getIndex = (row, col, gridWidth)=>{\n    return row * gridWidth + col;\n};\nconst getCoords = (index, gridWidth)=>{\n    const row = Math.floor(index / gridWidth);\n    const col = index % gridWidth;\n    return {\n        row,\n        col\n    };\n};\n// Modified to use fixed spacing\nconst getCenterOffset = (gridWidth, gridHeight, spacing)=>{\n    const totalWidth = (gridWidth - 1) * spacing;\n    const totalHeight = (gridHeight - 1) * spacing;\n    return new three__WEBPACK_IMPORTED_MODULE_2__.Vector2(-totalWidth / 2, -totalHeight / 2);\n};\n// Modified to use fixed spacing\nconst getWorldPosition = (row, col, gridWidth, gridHeight, spacing, centerOffset)=>{\n    const x = col * spacing + centerOffset.x;\n    const y = row * spacing + centerOffset.y;\n    return {\n        x,\n        y\n    };\n};\n// === GridScene Component ===\n// Dummy object for matrix calculations\nconst dummy = new three__WEBPACK_IMPORTED_MODULE_2__.Object3D();\nconst tempMatrix = new three__WEBPACK_IMPORTED_MODULE_2__.Matrix4();\nconst tempVec = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n// New: Helper for horizontal cmd-click connector key generation\nconst getHorizCmdConnectorKey = (x, y)=>`hcmd:${x},${y}`;\n// Helper to get the key for a 2x2 cell group\nconst getCellGroupKey = (cellX, cellY)=>`${cellX},${cellY}`;\n// --- End Adjacency List Structure ---\nconst GridScene = ()=>{\n    // Get the set function directly from useControls\n    const [controls, setLevaControl] = (0,leva__WEBPACK_IMPORTED_MODULE_3__.useControls)(\"Grid\", ()=>({\n            GRID_WIDTH: {\n                value: 10,\n                min: 2,\n                max: 100,\n                step: 1\n            },\n            GRID_HEIGHT: {\n                value: 10,\n                min: 2,\n                max: 100,\n                step: 1\n            },\n            visualScale: {\n                value: 1.0,\n                min: 0.1,\n                max: 5,\n                step: 0.1,\n                label: \"Visual Scale\"\n            },\n            // Use button functions that don't reference the component functions directly\n            \"Save/Load\": (0,leva__WEBPACK_IMPORTED_MODULE_3__.folder)({\n                saveState: (0,leva__WEBPACK_IMPORTED_MODULE_3__.button)(()=>{\n                    console.log(\"Save button clicked\");\n                    // Get the CURRENT state at the moment the button is clicked\n                    const currentControls = {\n                        ...controls\n                    }; // Make a fresh copy of the controls object\n                    console.log(`Current controls dimensions: ${currentControls.GRID_WIDTH}x${currentControls.GRID_HEIGHT}`);\n                    // Get the current activation state directly from the buffer attribute\n                    let currentActivation;\n                    if (activationAttributeRef.current && activationAttributeRef.current.array) {\n                        currentActivation = activationAttributeRef.current.array;\n                        console.log(\"- Using activation state from buffer attribute\");\n                    } else {\n                        currentActivation = activationState;\n                        console.log(\"- Using activation state from React state (fallback)\");\n                    }\n                    // Use the ref values which should have the most up-to-date state\n                    const currentIntendedConnectors = JSON.parse(JSON.stringify(intendedConnectorsRef.current || {}));\n                    const currentCmdHorizConnectors = JSON.parse(JSON.stringify(cmdHorizConnectorsRef.current || {}));\n                    console.log(\"Ref values for connectors:\", {\n                        intended: currentIntendedConnectors,\n                        cmdHoriz: currentCmdHorizConnectors\n                    });\n                    // Save using direct values with current dimensions\n                    saveGridStateWithDirectValues(currentActivation, currentIntendedConnectors, currentCmdHorizConnectors, currentControls.GRID_WIDTH, currentControls.GRID_HEIGHT);\n                }),\n                loadState: (0,leva__WEBPACK_IMPORTED_MODULE_3__.button)(()=>{\n                    console.log(\"Load requested\");\n                    const jsonInput = prompt(\"Paste Grid State JSON:\");\n                    if (!jsonInput) {\n                        console.log(\"Load cancelled.\");\n                        return;\n                    }\n                    try {\n                        const data = JSON.parse(jsonInput);\n                        console.log(\"Parsed JSON data:\", data);\n                        // Instead of calling the loadGridState function, process the data directly\n                        // Validate basic structure\n                        if (typeof data.gridWidth !== \"number\" || typeof data.gridHeight !== \"number\" || !Array.isArray(data.nodes) || !Array.isArray(data.edges)) {\n                            throw new Error(\"Invalid JSON structure.\");\n                        }\n                        console.log(\"Grid dimensions to be set:\", data.gridWidth, \"x\", data.gridHeight);\n                        console.log(\"Nodes to load:\", data.nodes.length);\n                        console.log(\"Edges to load:\", data.edges.length);\n                        // --- Use the captured setLevaControl function ---\n                        setLevaControl({\n                            GRID_WIDTH: data.gridWidth,\n                            GRID_HEIGHT: data.gridHeight\n                        });\n                        // --- Process Nodes and Edges ---\n                        setTimeout(()=>{\n                            // Use data.gridWidth/Height here as controls might not have updated yet\n                            const newTotalCircles = data.gridWidth * data.gridHeight;\n                            const newActivationState = new Float32Array(newTotalCircles).fill(0.0);\n                            console.log(\"Setting active nodes...\");\n                            data.nodes.forEach((node)=>{\n                                if (node.x >= 0 && node.x < data.gridWidth && node.y >= 0 && node.y < data.gridHeight) {\n                                    const index = getIndex(node.y, node.x, data.gridWidth);\n                                    newActivationState[index] = 1.0;\n                                    console.log(`Activating node at (${node.x}, ${node.y}), index: ${index}`);\n                                } else {\n                                    console.warn(`Node out of bounds ignored: (${node.x}, ${node.y})`);\n                                }\n                            });\n                            const newIntendedConnectors = {};\n                            const newCmdHorizConnectors = {};\n                            console.log(\"Processing edges...\");\n                            data.edges.forEach((edge)=>{\n                                console.log(\"Processing edge:\", edge);\n                                let connectorType = _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_NONE;\n                                let isValid = false;\n                                switch(edge.type){\n                                    case \"diag_tl_br\":\n                                        connectorType = _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_DIAG_TL_BR;\n                                        isValid = edge.x >= 0 && edge.x < data.gridWidth - 1 && edge.y >= 0 && edge.y < data.gridHeight - 1;\n                                        break;\n                                    case \"diag_bl_tr\":\n                                        connectorType = _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_DIAG_BL_TR;\n                                        isValid = edge.x >= 0 && edge.x < data.gridWidth - 1 && edge.y >= 0 && edge.y < data.gridHeight - 1;\n                                        break;\n                                    case \"horiz_t\":\n                                        connectorType = _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_HORIZ_T;\n                                        isValid = edge.x >= 0 && edge.x < data.gridWidth - 1 && edge.y >= 0 && edge.y < data.gridHeight - 1;\n                                        break;\n                                    case \"horiz_b\":\n                                        connectorType = _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_HORIZ_B;\n                                        isValid = edge.x >= 0 && edge.x < data.gridWidth - 1 && edge.y >= 0 && edge.y < data.gridHeight - 1;\n                                        break;\n                                    case \"cmd_horiz\":\n                                        // This type updates a different state object\n                                        isValid = edge.x >= 0 && edge.x < data.gridWidth - 1 && edge.y >= 0 && edge.y < data.gridHeight;\n                                        if (isValid) {\n                                            const key = getHorizCmdConnectorKey(edge.x, edge.y);\n                                            newCmdHorizConnectors[key] = 1;\n                                            console.log(`Added cmd_horiz connector at (${edge.x}, ${edge.y}) with key ${key}`);\n                                        }\n                                        break;\n                                    default:\n                                        console.warn(`Unknown edge type ignored: ${edge.type}`);\n                                }\n                                // Assign to intendedConnectors *after* the switch, if valid and applicable\n                                if (isValid && edge.type !== \"cmd_horiz\" && connectorType !== _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_NONE) {\n                                    const key = getCellGroupKey(edge.x, edge.y);\n                                    newIntendedConnectors[key] = connectorType;\n                                    console.log(`Added ${edge.type} connector at (${edge.x}, ${edge.y}) with key ${key} and type value ${connectorType}`);\n                                }\n                                if (!isValid) {\n                                    console.warn(`Edge out of bounds or invalid ignored:`, edge);\n                                }\n                            });\n                            console.log(\"Setting activation state with\", Object.values(newActivationState).filter((v)=>v === 1.0).length, \"active nodes\");\n                            setActivationState(newActivationState);\n                            console.log(\"Setting intended connectors:\", Object.keys(newIntendedConnectors).length, \"connectors\");\n                            setIntendedConnectors(newIntendedConnectors);\n                            // Update the ref as well\n                            intendedConnectorsRef.current = {\n                                ...newIntendedConnectors\n                            };\n                            console.log(\"Setting cmd-horiz connectors:\", Object.keys(newCmdHorizConnectors).length, \"connectors\");\n                            setCmdHorizConnectors(newCmdHorizConnectors);\n                            // Update the ref as well\n                            cmdHorizConnectorsRef.current = {\n                                ...newCmdHorizConnectors\n                            };\n                            console.log(\"Grid state loaded successfully.\");\n                            // Verify the loaded state after a short delay\n                            setTimeout(()=>{\n                                console.log(\"Verification of loaded state:\");\n                                console.log(\"- Active nodes:\", Object.values(activationState).filter((v)=>v === 1.0).length);\n                                console.log(\"- Intended connectors:\", Object.entries(intendedConnectors).filter(([_, v])=>v !== _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_NONE).length);\n                                console.log(\"- Cmd-horiz connectors:\", Object.entries(cmdHorizConnectors).filter(([_, v])=>v === 1).length);\n                            }, 200);\n                        }, 100);\n                    } catch (error) {\n                        console.error(\"Failed to parse or process JSON:\", error);\n                        alert(`Error: ${error instanceof Error ? error.message : String(error)}`);\n                    }\n                })\n            })\n        }));\n    // Derived values calculation - use 'controls' now\n    const { TOTAL_CIRCLES, centerOffset, planeWidth, planeHeight } = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        const total = controls.GRID_WIDTH * controls.GRID_HEIGHT;\n        const offset = getCenterOffset(controls.GRID_WIDTH, controls.GRID_HEIGHT, _constants__WEBPACK_IMPORTED_MODULE_8__.FIXED_SPACING);\n        const width = (controls.GRID_WIDTH > 1 ? (controls.GRID_WIDTH - 1) * _constants__WEBPACK_IMPORTED_MODULE_8__.FIXED_SPACING : 0) + controls.visualScale * _constants__WEBPACK_IMPORTED_MODULE_8__.BASE_RADIUS_A * 2;\n        const height = (controls.GRID_HEIGHT > 1 ? (controls.GRID_HEIGHT - 1) * _constants__WEBPACK_IMPORTED_MODULE_8__.FIXED_SPACING : 0) + controls.visualScale * _constants__WEBPACK_IMPORTED_MODULE_8__.BASE_RADIUS_A * 2;\n        return {\n            TOTAL_CIRCLES: total,\n            centerOffset: offset,\n            planeWidth: width,\n            planeHeight: height\n        };\n    }, [\n        controls.GRID_WIDTH,\n        controls.GRID_HEIGHT,\n        controls.visualScale\n    ]); // Update dependencies\n    // Refs for mesh and material\n    const meshRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const materialRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null); // Use 'any' or specific type for CircleMaterial\n    const activationAttributeRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const connectorMaterialRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null); // Ref for connector material\n    const cmdHorizMaterialRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // Refs to track current state\n    const intendedConnectorsRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)({});\n    const cmdHorizConnectorsRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)({});\n    // === Feature 3: Circle Activation State ===\n    const [activationState, setActivationState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(()=>new Float32Array(TOTAL_CIRCLES).fill(0.0) // 0.0 inactive, 1.0 active\n    );\n    // New: Add horizontal cmd-click connector state\n    const [cmdHorizConnectors, setCmdHorizConnectors] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    // === Feature 8: Connector Interaction State and Helpers (Moved UP) ===\n    const [intendedConnectors, setIntendedConnectors] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    // Helper to get the intended connector for a 2x2 cell group (Moved UP)\n    const getIntendedConnector = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((cellX, cellY)=>{\n        if (cellX < 0 || cellX >= controls.GRID_WIDTH - 1 || cellY < 0 || cellY >= controls.GRID_HEIGHT - 1) {\n            return _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_NONE;\n        }\n        const key = getCellGroupKey(cellX, cellY);\n        return intendedConnectors[key] || _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_NONE;\n    }, [\n        intendedConnectors,\n        controls.GRID_WIDTH,\n        controls.GRID_HEIGHT\n    ]);\n    // State needs to be reset if TOTAL_CIRCLES changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        console.log(\"Resetting activation state due to grid size change\");\n        setActivationState(new Float32Array(TOTAL_CIRCLES).fill(0.0));\n        setIntendedConnectors({}); // Also reset intended connectors\n        setCmdHorizConnectors({}); // Also reset cmd-horiz connectors\n        // Also reset the refs\n        intendedConnectorsRef.current = {};\n        cmdHorizConnectorsRef.current = {};\n    }, [\n        TOTAL_CIRCLES\n    ]);\n    // Update buffer attribute when state changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (activationAttributeRef.current) {\n            activationAttributeRef.current.array = activationState;\n            activationAttributeRef.current.needsUpdate = true;\n        // console.log('Updated activation buffer attribute.'); // Less noisy log\n        }\n    }, [\n        activationState\n    ]);\n    // === Feature 2: Static Circle Rendering ===\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!meshRef.current) return;\n        // Calculate and set instance matrices\n        for(let index = 0; index < TOTAL_CIRCLES; index++){\n            const { row, col } = getCoords(index, controls.GRID_WIDTH);\n            const { x, y } = getWorldPosition(row, col, controls.GRID_WIDTH, controls.GRID_HEIGHT, _constants__WEBPACK_IMPORTED_MODULE_8__.FIXED_SPACING, centerOffset);\n            dummy.position.set(x, y, 0); // Z=0 for circles\n            // Retrieve existing scale/rotation before setting position to avoid overwriting scale effect\n            const currentMatrix = new three__WEBPACK_IMPORTED_MODULE_2__.Matrix4();\n            meshRef.current.getMatrixAt(index, currentMatrix);\n            const position = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n            const quaternion = new three__WEBPACK_IMPORTED_MODULE_2__.Quaternion();\n            const scaleVec = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n            currentMatrix.decompose(position, quaternion, scaleVec);\n            // Update only position\n            position.set(x, y, 0);\n            dummy.matrix.compose(position, quaternion, scaleVec); // Recompose with original scale/rotation\n            meshRef.current.setMatrixAt(index, dummy.matrix);\n        }\n        meshRef.current.instanceMatrix.needsUpdate = true;\n    // console.log(`Updated ${TOTAL_CIRCLES} instance matrices (position).`);\n    }, [\n        controls.GRID_WIDTH,\n        controls.GRID_HEIGHT,\n        _constants__WEBPACK_IMPORTED_MODULE_8__.FIXED_SPACING,\n        TOTAL_CIRCLES,\n        centerOffset\n    ]);\n    // Update shader uniforms when scaled radii change\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (materialRef.current) {\n            // Shader expects radii relative to plane size (0.0 to 0.5 range if plane is size 1)\n            // Let's use plane size 1 and scale radii to 0.0-0.5 range for shader.\n            materialRef.current.uniforms.u_radiusA.value = _constants__WEBPACK_IMPORTED_MODULE_8__.BASE_RADIUS_A; // Use base radius relative to plane size 1\n            materialRef.current.uniforms.u_radiusB.value = _constants__WEBPACK_IMPORTED_MODULE_8__.BASE_RADIUS_B; // Use base radius relative to plane size 1\n            // Scale the whole instance instead to match spacing\n            console.log(`Updated material radii uniforms: A=${_constants__WEBPACK_IMPORTED_MODULE_8__.BASE_RADIUS_A}, B=${_constants__WEBPACK_IMPORTED_MODULE_8__.BASE_RADIUS_B}`);\n        }\n    }, []); // Depend on scaled radii, though using base for uniform now\n    // Adjust instance scale based on spacing\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!meshRef.current) return;\n        const scale = controls.visualScale; // Use the leva control value for scale\n        console.log(`Updating instance scales to: ${scale.toFixed(2)}`);\n        for(let index = 0; index < TOTAL_CIRCLES; index++){\n            meshRef.current.getMatrixAt(index, tempMatrix);\n            const position = tempVec.setFromMatrixPosition(tempMatrix);\n            const quaternion = new three__WEBPACK_IMPORTED_MODULE_2__.Quaternion().setFromRotationMatrix(tempMatrix);\n            // Update only scale\n            const scaleVec = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3().set(scale, scale, 1);\n            tempMatrix.compose(position, quaternion, scaleVec);\n            meshRef.current.setMatrixAt(index, tempMatrix);\n        }\n        meshRef.current.instanceMatrix.needsUpdate = true;\n    }, [\n        controls.visualScale,\n        TOTAL_CIRCLES\n    ]); // Depends on scale control and count\n    // === Feature 4: Circle Interaction (Now uses helpers defined above) ===\n    const handleCircleClick = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((event)=>{\n        event.stopPropagation();\n        if (event.instanceId === undefined || !meshRef.current) return;\n        const index = event.instanceId;\n        const { row: y, col: x } = getCoords(index, controls.GRID_WIDTH);\n        console.log(\"Circle clicked:\", {\n            index,\n            x,\n            y,\n            isCmdClick: event.metaKey || event.ctrlKey,\n            point: event.point,\n            currentState: activationState[index]\n        });\n        // Get the center of the clicked instance\n        meshRef.current.getMatrixAt(index, tempMatrix);\n        const instanceCenter = tempVec.setFromMatrixPosition(tempMatrix);\n        // Calculate distance from click point to instance center\n        const distFromCenter = event.point.distanceTo(instanceCenter);\n        // Get the CURRENT world-space inner radius\n        const currentInnerRadius = _constants__WEBPACK_IMPORTED_MODULE_8__.BASE_RADIUS_B * controls.visualScale;\n        console.log(\"Click details:\", {\n            distFromCenter,\n            currentInnerRadius,\n            isInside: distFromCenter <= currentInnerRadius\n        });\n        // Check if click is inside the inner circle\n        if (distFromCenter <= currentInnerRadius) {\n            // Check if this is a cmd/ctrl click\n            if (event.metaKey || event.ctrlKey) {\n                // Check conditions for horizontal connector\n                const rightIndex = getIndex(y, x + 1, controls.GRID_WIDTH);\n                const canConnectBase = x < controls.GRID_WIDTH - 1 && activationState[index] === 1.0 && activationState[rightIndex] === 1.0;\n                // --- NEW: Check for blocking diagonal connectors ---\n                const connectorBelow = getIntendedConnector(x, y - 1);\n                const connectorAdjacent = getIntendedConnector(x, y);\n                const isBlockedByDiagonal = connectorBelow === _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_DIAG_TL_BR || connectorBelow === _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_DIAG_BL_TR || connectorAdjacent === _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_DIAG_TL_BR || connectorAdjacent === _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_DIAG_BL_TR;\n                // --- End NEW check ---\n                console.log(\"Processing cmd-click on circle:\", {\n                    x,\n                    y,\n                    rightIndex,\n                    leftActive: activationState[index] === 1.0,\n                    rightActive: x < controls.GRID_WIDTH - 1 ? activationState[rightIndex] === 1.0 : false,\n                    canConnectBase,\n                    isBlockedByDiagonal,\n                    connectorBelow,\n                    connectorAdjacent\n                });\n                // Only allow toggle if base conditions met AND not blocked by diagonal\n                if (canConnectBase && !isBlockedByDiagonal) {\n                    const connectorKey = getHorizCmdConnectorKey(x, y);\n                    console.log(\"Toggling horizontal connector (allowed):\", {\n                        key: connectorKey\n                    });\n                    setCmdHorizConnectors((prev)=>{\n                        const newValue = prev[connectorKey] ? 0 : 1;\n                        const newState = {\n                            ...prev,\n                            [connectorKey]: newValue\n                        };\n                        // Update the ref to track the latest state\n                        cmdHorizConnectorsRef.current = newState;\n                        console.log(\"Updated cmd-horiz connector state:\", {\n                            key: connectorKey,\n                            newValue,\n                            allConnectors: newState,\n                            keys: Object.keys(newState),\n                            activeConnectors: Object.entries(newState).filter(([_, v])=>v === 1)\n                        });\n                        return newState;\n                    });\n                    return; // Exit after handling cmd-click\n                } else {\n                    console.log(\"Cmd-click horizontal connector blocked or base conditions not met.\");\n                }\n                // If blocked or can't connect, fall through to regular click? \n                // Or maybe do nothing on cmd-click if blocked? Let's do nothing for now.\n                return; // Explicitly do nothing more if cmd-click was blocked or invalid\n            }\n            // Regular click behavior (toggle activation) - only runs if not a handled cmd-click\n            console.log(\"Toggling circle activation (regular click)\");\n            setActivationState((current)=>{\n                const newState = new Float32Array(current);\n                newState[index] = newState[index] === 1.0 ? 0.0 : 1.0;\n                console.log(\"New activation state for circle:\", {\n                    index,\n                    oldValue: current[index],\n                    newValue: newState[index]\n                });\n                return newState;\n            });\n        }\n    }, [\n        meshRef,\n        setActivationState,\n        controls.GRID_WIDTH,\n        controls.visualScale,\n        setCmdHorizConnectors,\n        cmdHorizConnectors,\n        intendedConnectors,\n        controls.GRID_HEIGHT\n    ]); // Dependencies are correct now\n    // === Feature 5: State Data Texture ===\n    const stateTexture = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        console.log(`Creating state texture: ${controls.GRID_WIDTH}x${controls.GRID_HEIGHT}`);\n        const texture = new three__WEBPACK_IMPORTED_MODULE_2__.DataTexture(new Float32Array(TOTAL_CIRCLES).fill(0.0), controls.GRID_WIDTH, controls.GRID_HEIGHT, three__WEBPACK_IMPORTED_MODULE_2__.RedFormat, three__WEBPACK_IMPORTED_MODULE_2__.FloatType);\n        texture.minFilter = three__WEBPACK_IMPORTED_MODULE_2__.NearestFilter; // Crucial: No interpolation\n        texture.magFilter = three__WEBPACK_IMPORTED_MODULE_2__.NearestFilter;\n        texture.needsUpdate = true; // Initial update needed\n        return texture;\n    }, [\n        controls.GRID_WIDTH,\n        controls.GRID_HEIGHT,\n        TOTAL_CIRCLES\n    ]); // Recreate texture if grid dimensions change\n    // Update texture data when activationState changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (stateTexture && activationState.length === stateTexture.image.data.length) {\n            stateTexture.image.data.set(activationState); // Update texture data directly\n            stateTexture.needsUpdate = true; // Mark for GPU upload\n            console.log(\"Updated state texture data.\");\n        } else {\n            console.warn(\"Skipping texture update: Mismatch between state array and texture size or texture not ready.\");\n        }\n    }, [\n        activationState,\n        stateTexture\n    ]); // Depend on activation state and the texture itself\n    // === Feature 8: Connector Plane Interaction (Moved DOWN, uses helpers defined above) ===\n    const handleConnectorClick = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((event)=>{\n        event.stopPropagation();\n        console.log(\"Connector plane clicked:\", {\n            point: event.point,\n            isCmdClick: event.metaKey || event.ctrlKey\n        });\n        // Get the click point in world space\n        const clickPoint = event.point;\n        // First, check if the click is on a circle\n        // Determine which grid cell this point is closest to\n        const gridX = Math.round((clickPoint.x - centerOffset.x) / _constants__WEBPACK_IMPORTED_MODULE_8__.FIXED_SPACING);\n        const gridY = Math.round((clickPoint.y - centerOffset.y) / _constants__WEBPACK_IMPORTED_MODULE_8__.FIXED_SPACING);\n        // Check if this cell is within grid bounds\n        if (gridX >= 0 && gridX < controls.GRID_WIDTH && gridY >= 0 && gridY < controls.GRID_HEIGHT) {\n            // Calculate the cell center in world space\n            const cellCenter = getWorldPosition(gridY, gridX, controls.GRID_WIDTH, controls.GRID_HEIGHT, _constants__WEBPACK_IMPORTED_MODULE_8__.FIXED_SPACING, centerOffset);\n            // Calculate distance from click to cell center\n            const distFromCenter = Math.sqrt(Math.pow(clickPoint.x - cellCenter.x, 2) + Math.pow(clickPoint.y - cellCenter.y, 2));\n            // Check if click is inside the inner circle\n            const currentInnerRadius = _constants__WEBPACK_IMPORTED_MODULE_8__.BASE_RADIUS_B * controls.visualScale;\n            if (distFromCenter <= currentInnerRadius) {\n                // This is a click on a circle - toggle its activation state\n                const index = getIndex(gridY, gridX, controls.GRID_WIDTH);\n                // If this is a cmd/ctrl click and there's an active circle to the right\n                if ((event.metaKey || event.ctrlKey) && gridX < controls.GRID_WIDTH - 1) {\n                    const rightIndex = getIndex(gridY, gridX + 1, controls.GRID_WIDTH);\n                    const leftActive = activationState[index] === 1.0;\n                    const rightActive = activationState[rightIndex] === 1.0;\n                    const canConnectBase = leftActive && rightActive;\n                    // --- NEW: Check for blocking diagonal connectors ---\n                    const connectorBelow = getIntendedConnector(gridX, gridY - 1);\n                    const connectorAdjacent = getIntendedConnector(gridX, gridY);\n                    const isBlockedByDiagonal = connectorBelow === _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_DIAG_TL_BR || connectorBelow === _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_DIAG_BL_TR || connectorAdjacent === _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_DIAG_TL_BR || connectorAdjacent === _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_DIAG_BL_TR;\n                    // --- End NEW check ---\n                    console.log(\"Processing cmd-click (via plane on circle):\", {\n                        x: gridX,\n                        y: gridY,\n                        leftActive,\n                        rightActive,\n                        canConnectBase,\n                        isBlockedByDiagonal,\n                        connectorBelow,\n                        connectorAdjacent\n                    });\n                    // Only allow toggle if base conditions met AND not blocked by diagonal\n                    if (canConnectBase && !isBlockedByDiagonal) {\n                        const connectorKey = getHorizCmdConnectorKey(gridX, gridY);\n                        console.log(\"Toggling cmd-horiz connector (allowed):\", {\n                            key: connectorKey\n                        });\n                        setCmdHorizConnectors((prev)=>{\n                            const newConnectors = {\n                                ...prev\n                            };\n                            newConnectors[connectorKey] = prev[connectorKey] ? 0 : 1;\n                            // Update the ref to track the latest state\n                            cmdHorizConnectorsRef.current = newConnectors;\n                            console.log(\"Updated cmd-horiz connector state (via plane):\", {\n                                key: connectorKey,\n                                newValue: newConnectors[connectorKey],\n                                allConnectors: newConnectors,\n                                keys: Object.keys(newConnectors),\n                                activeConnectors: Object.entries(newConnectors).filter(([_, v])=>v === 1)\n                            });\n                            return newConnectors;\n                        });\n                        return; // Exit after handling cmd-click\n                    } else {\n                        console.log(\"Cmd-click horizontal connector blocked or base conditions not met.\");\n                    }\n                    // If blocked or can't connect, fall through to regular click? Let's do nothing more.\n                    return; // Explicitly do nothing more if cmd-click was blocked or invalid\n                }\n                // Regular click behavior (toggle activation) - only runs if not a handled cmd-click\n                console.log(\"Toggling circle activation (regular click on plane)\");\n                setActivationState((current)=>{\n                    const newState = new Float32Array(current);\n                    newState[index] = newState[index] === 1.0 ? 0.0 : 1.0;\n                    return newState;\n                });\n                console.log(`Toggling circle at (${gridX},${gridY})`);\n                return;\n            }\n        }\n        // If we get here, the click wasn't on a circle, so treat it as a connector click\n        // Determine which grid cell (bottom-left of a 2x2 group) this point is closest to\n        const groupX = Math.floor((clickPoint.x - centerOffset.x) / _constants__WEBPACK_IMPORTED_MODULE_8__.FIXED_SPACING);\n        const groupY = Math.floor((clickPoint.y - centerOffset.y) / _constants__WEBPACK_IMPORTED_MODULE_8__.FIXED_SPACING);\n        // Get the indices of the four cells in the 2x2 group\n        const blIndex = getIndex(groupY, groupX, controls.GRID_WIDTH);\n        const brIndex = getIndex(groupY, groupX + 1, controls.GRID_WIDTH);\n        const tlIndex = getIndex(groupY + 1, groupX, controls.GRID_WIDTH);\n        const trIndex = getIndex(groupY + 1, groupX + 1, controls.GRID_WIDTH);\n        // Check which cells are within grid bounds\n        const isValidGroup = groupX >= 0 && groupX < controls.GRID_WIDTH - 1 && groupY >= 0 && groupY < controls.GRID_HEIGHT - 1;\n        if (!isValidGroup) return;\n        // Get activation states for the four cells\n        const blActive = activationState[blIndex] === 1.0;\n        const brActive = activationState[brIndex] === 1.0;\n        const tlActive = activationState[tlIndex] === 1.0;\n        const trActive = activationState[trIndex] === 1.0;\n        // Get the world positions of the cell centers\n        const blPos = getWorldPosition(groupY, groupX, controls.GRID_WIDTH, controls.GRID_HEIGHT, _constants__WEBPACK_IMPORTED_MODULE_8__.FIXED_SPACING, centerOffset);\n        const brPos = getWorldPosition(groupY, groupX + 1, controls.GRID_WIDTH, controls.GRID_HEIGHT, _constants__WEBPACK_IMPORTED_MODULE_8__.FIXED_SPACING, centerOffset);\n        const tlPos = getWorldPosition(groupY + 1, groupX, controls.GRID_WIDTH, controls.GRID_HEIGHT, _constants__WEBPACK_IMPORTED_MODULE_8__.FIXED_SPACING, centerOffset);\n        const trPos = getWorldPosition(groupY + 1, groupX + 1, controls.GRID_WIDTH, controls.GRID_HEIGHT, _constants__WEBPACK_IMPORTED_MODULE_8__.FIXED_SPACING, centerOffset);\n        // Calculate the center of the 2x2 group\n        const centerX = (blPos.x + brPos.x + tlPos.x + trPos.x) / 4;\n        const centerY = (blPos.y + brPos.y + tlPos.y + trPos.y) / 4;\n        // Calculate distance from click to center of 2x2 group\n        const distToCenter = Math.sqrt(Math.pow(clickPoint.x - centerX, 2) + Math.pow(clickPoint.y - centerY, 2));\n        // Check if the click is in the center zone (30% of cell spacing)\n        const isCenterClick = distToCenter < _constants__WEBPACK_IMPORTED_MODULE_8__.FIXED_SPACING * 0.3 * controls.visualScale;\n        // Get the possible diagonal connectors\n        const canUseDiagTLBR = tlActive && brActive;\n        const canUseDiagBLTR = blActive && trActive;\n        const hasDiagonalOptions = canUseDiagTLBR || canUseDiagBLTR;\n        // Get current intended connector\n        const currentConnector = getIntendedConnector(groupX, groupY);\n        const groupKey = getCellGroupKey(groupX, groupY);\n        // --- NEW: Check for blocking horizontal connectors ---\n        const hasHorizCmdBelow = cmdHorizConnectors[getHorizCmdConnectorKey(groupX, groupY)] === 1;\n        const hasHorizCmdAbove = cmdHorizConnectors[getHorizCmdConnectorKey(groupX, groupY + 1)] === 1;\n        const isBlockedByHoriz = hasHorizCmdBelow || hasHorizCmdAbove;\n        // --- End NEW Check ---\n        let newConnector = _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_NONE; // Initialize potential new state\n        let potentialConnectorType = _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_NONE; // Store the type determined by click logic\n        // If clicked in the center and diagonal connectors are available, cycle through them\n        if (isCenterClick && hasDiagonalOptions) {\n            if (canUseDiagTLBR && canUseDiagBLTR) {\n                // Both diagonals are available, cycle through the options: NONE -> TL-BR -> BL-TR -> NONE\n                if (currentConnector === _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_NONE) {\n                    potentialConnectorType = _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_DIAG_TL_BR;\n                } else if (currentConnector === _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_DIAG_TL_BR) {\n                    potentialConnectorType = _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_DIAG_BL_TR;\n                } else {\n                    potentialConnectorType = _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_NONE;\n                }\n            } else if (canUseDiagTLBR) {\n                // Only TL-BR diagonal is available, toggle it\n                potentialConnectorType = currentConnector === _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_DIAG_TL_BR ? _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_NONE : _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_DIAG_TL_BR;\n            } else {\n                // Only BL-TR diagonal is available, toggle it\n                potentialConnectorType = currentConnector === _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_DIAG_BL_TR ? _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_NONE : _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_DIAG_BL_TR;\n            }\n        } else if (!isCenterClick) {\n            // For clicks outside the center, determine which diagonal was clicked (if any)\n            let clickedType = _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_NONE;\n            // Calculate distances from click to each diagonal\n            const distToBLTR = Math.abs((clickPoint.x - blPos.x) * (trPos.y - blPos.y) - (clickPoint.y - blPos.y) * (trPos.x - blPos.x)) / Math.sqrt(Math.pow(trPos.x - blPos.x, 2) + Math.pow(trPos.y - blPos.y, 2));\n            const distToTLBR = Math.abs((clickPoint.x - tlPos.x) * (brPos.y - tlPos.y) - (clickPoint.y - tlPos.y) * (brPos.x - tlPos.x)) / Math.sqrt(Math.pow(brPos.x - tlPos.x, 2) + Math.pow(brPos.y - tlPos.y, 2));\n            if (distToBLTR < distToTLBR) {\n                // Closer to BL-TR diagonal (/)\n                if (canUseDiagBLTR) {\n                    clickedType = _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_DIAG_BL_TR;\n                }\n            } else {\n                // Closer to TL-BR diagonal (\\)\n                if (canUseDiagTLBR) {\n                    clickedType = _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_DIAG_TL_BR;\n                }\n            }\n            // Toggle logic - if the clicked connector is already active, turn it off\n            // Otherwise, turn on the clicked one\n            if (currentConnector === clickedType) {\n                potentialConnectorType = _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_NONE; // Toggle off\n            } else if (clickedType !== _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_NONE) {\n                potentialConnectorType = clickedType; // Toggle on new connector\n            }\n        }\n        // --- Apply Blocking Logic ---\n        if (isBlockedByHoriz && (potentialConnectorType === _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_DIAG_TL_BR || potentialConnectorType === _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_DIAG_BL_TR)) {\n            newConnector = _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_NONE; // Force to NONE if blocked by horizontal\n            console.log(`Diagonal connector blocked by existing horizontal connector at group (${groupX},${groupY})`);\n        } else {\n            newConnector = potentialConnectorType; // Otherwise, use the type determined by click logic\n        }\n        // --- End Blocking Logic ---\n        // Update the intended connector state\n        setIntendedConnectors((prev)=>{\n            console.log(`Connector update at (${groupX},${groupY}): previous=${prev[groupKey]} -> new=${newConnector}`);\n            const updated = {\n                ...prev,\n                [groupKey]: newConnector\n            };\n            // Update the ref to track the latest state\n            intendedConnectorsRef.current = updated;\n            // Log the change that was made\n            if (prev[groupKey] !== newConnector) {\n                if (newConnector === _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_NONE) {\n                    console.log(`Removed connector at (${groupX},${groupY})`);\n                } else {\n                    const typeStr = newConnector === _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_DIAG_TL_BR ? \"DIAG_TL_BR (\\\\)\" : newConnector === _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_DIAG_BL_TR ? \"DIAG_BL_TR (/)\" : newConnector === _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_HORIZ_T ? \"HORIZ_T\" : newConnector === _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_HORIZ_B ? \"HORIZ_B\" : `unknown (${newConnector})`;\n                    console.log(`Added ${typeStr} connector at (${groupX},${groupY})`);\n                    // Log updated connector state to help with debugging\n                    console.log(\"New connector state:\", updated);\n                    console.log(\"Connector keys:\", Object.keys(updated));\n                    console.log(\"Non-zero connectors:\", Object.entries(updated).filter(([_, v])=>v !== _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_NONE));\n                }\n            }\n            return updated;\n        });\n        console.log(`Clicked cell group (${groupX},${groupY}), setting connector to ${newConnector}`);\n    }, [\n        controls.GRID_WIDTH,\n        controls.GRID_HEIGHT,\n        _constants__WEBPACK_IMPORTED_MODULE_8__.FIXED_SPACING,\n        centerOffset,\n        activationState,\n        intendedConnectors,\n        controls.visualScale,\n        setCmdHorizConnectors,\n        cmdHorizConnectors\n    ]); // Dependencies are correct now\n    // Reset connector intent when a circle is deactivated\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        // Check all cell groups\n        const newIntendedConnectors = {\n            ...intendedConnectors\n        };\n        const newCmdHorizConnectors = {\n            ...cmdHorizConnectors\n        };\n        let hasChanges = false;\n        let hasCmdHorizChanges = false;\n        // First check regular connectors\n        for(const key in intendedConnectors){\n            const connector = intendedConnectors[key];\n            if (connector === _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_NONE) continue;\n            // Parse x,y from key\n            const [x, y] = key.split(\",\").map(Number);\n            // Get the indices of the four cells\n            const blIndex = getIndex(y, x, controls.GRID_WIDTH);\n            const brIndex = getIndex(y, x + 1, controls.GRID_WIDTH);\n            const tlIndex = getIndex(y + 1, x, controls.GRID_WIDTH);\n            const trIndex = getIndex(y + 1, x + 1, controls.GRID_WIDTH);\n            // Get activation states\n            const blActive = activationState[blIndex] === 1.0;\n            const brActive = activationState[brIndex] === 1.0;\n            const tlActive = activationState[tlIndex] === 1.0;\n            const trActive = activationState[trIndex] === 1.0;\n            // Check if the connector is still valid\n            let isValid = true;\n            switch(connector){\n                case _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_DIAG_TL_BR:\n                    isValid = tlActive && brActive;\n                    break;\n                case _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_DIAG_BL_TR:\n                    isValid = blActive && trActive;\n                    break;\n                case _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_HORIZ_T:\n                    isValid = tlActive && trActive;\n                    break;\n                case _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_HORIZ_B:\n                    isValid = blActive && brActive;\n                    break;\n            }\n            if (!isValid) {\n                newIntendedConnectors[key] = _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_NONE;\n                hasChanges = true;\n            }\n        }\n        // Now check cmd-click horizontal connectors\n        for(const key in cmdHorizConnectors){\n            if (cmdHorizConnectors[key] === 0) continue;\n            // Parse x,y from key (remove 'hcmd:' prefix)\n            const [x, y] = key.substring(5).split(\",\").map(Number);\n            // Get indices for left and right circles\n            const leftIndex = getIndex(y, x, controls.GRID_WIDTH);\n            const rightIndex = getIndex(y, x + 1, controls.GRID_WIDTH);\n            // Check if both circles are still active\n            const leftActive = activationState[leftIndex] === 1.0;\n            const rightActive = activationState[rightIndex] === 1.0;\n            if (!leftActive || !rightActive) {\n                newCmdHorizConnectors[key] = 0;\n                hasCmdHorizChanges = true;\n            }\n        }\n        if (hasChanges) {\n            setIntendedConnectors(newIntendedConnectors);\n        }\n        if (hasCmdHorizChanges) {\n            setCmdHorizConnectors(newCmdHorizConnectors);\n        }\n    }, [\n        activationState,\n        controls.GRID_WIDTH,\n        intendedConnectors,\n        cmdHorizConnectors\n    ]);\n    // Create a data texture for intended connectors\n    const intendedConnectorTexture = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        console.log(`Creating intended connector texture: ${controls.GRID_WIDTH - 1}x${controls.GRID_HEIGHT - 1}`);\n        // Texture has one pixel per 2x2 cell group (grid cells minus 1 in each dimension)\n        const width = Math.max(1, controls.GRID_WIDTH - 1);\n        const height = Math.max(1, controls.GRID_HEIGHT - 1);\n        const texture = new three__WEBPACK_IMPORTED_MODULE_2__.DataTexture(new Float32Array(width * height).fill(0.0), width, height, three__WEBPACK_IMPORTED_MODULE_2__.RedFormat, three__WEBPACK_IMPORTED_MODULE_2__.FloatType);\n        texture.minFilter = three__WEBPACK_IMPORTED_MODULE_2__.NearestFilter;\n        texture.magFilter = three__WEBPACK_IMPORTED_MODULE_2__.NearestFilter;\n        texture.needsUpdate = true;\n        return texture;\n    }, [\n        controls.GRID_WIDTH,\n        controls.GRID_HEIGHT\n    ]);\n    // Update the intended connector texture when state changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const width = Math.max(1, controls.GRID_WIDTH - 1);\n        const data = new Float32Array(width * Math.max(1, controls.GRID_HEIGHT - 1));\n        for(let y = 0; y < controls.GRID_HEIGHT - 1; y++){\n            for(let x = 0; x < controls.GRID_WIDTH - 1; x++){\n                const index = y * width + x;\n                const connector = getIntendedConnector(x, y);\n                data[index] = connector;\n            }\n        }\n        if (intendedConnectorTexture && data.length === intendedConnectorTexture.image.data.length) {\n            intendedConnectorTexture.image.data.set(data);\n            intendedConnectorTexture.needsUpdate = true;\n        }\n    }, [\n        intendedConnectors,\n        controls.GRID_WIDTH,\n        controls.GRID_HEIGHT,\n        intendedConnectorTexture\n    ]);\n    // Create horizontal cmd-click connector texture\n    const cmdHorizConnectorTexture = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        console.log(`Creating cmd-click horizontal connector texture: ${controls.GRID_WIDTH - 1}x${controls.GRID_HEIGHT}`);\n        // Texture has one pixel per horizontal connection possibility\n        const width = Math.max(1, controls.GRID_WIDTH - 1);\n        const height = controls.GRID_HEIGHT;\n        const texture = new three__WEBPACK_IMPORTED_MODULE_2__.DataTexture(new Float32Array(width * height).fill(0.0), width, height, three__WEBPACK_IMPORTED_MODULE_2__.RedFormat, three__WEBPACK_IMPORTED_MODULE_2__.FloatType);\n        texture.minFilter = three__WEBPACK_IMPORTED_MODULE_2__.NearestFilter;\n        texture.magFilter = three__WEBPACK_IMPORTED_MODULE_2__.NearestFilter;\n        texture.needsUpdate = true;\n        return texture;\n    }, [\n        controls.GRID_WIDTH,\n        controls.GRID_HEIGHT\n    ]);\n    // Update the cmd-click horizontal connector texture when state changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const width = Math.max(1, controls.GRID_WIDTH - 1);\n        const data = new Float32Array(width * controls.GRID_HEIGHT);\n        console.log(\"Updating cmd-horiz connector texture:\", {\n            width,\n            height: controls.GRID_HEIGHT,\n            connectors: cmdHorizConnectors\n        });\n        for(let y = 0; y < controls.GRID_HEIGHT; y++){\n            for(let x = 0; x < width; x++){\n                const key = getHorizCmdConnectorKey(x, y);\n                const value = cmdHorizConnectors[key] || 0;\n                data[y * width + x] = value;\n                if (value > 0) {\n                    console.log(\"Found active connector:\", {\n                        x,\n                        y,\n                        key,\n                        value\n                    });\n                }\n            }\n        }\n        if (cmdHorizConnectorTexture && data.length === cmdHorizConnectorTexture.image.data.length) {\n            cmdHorizConnectorTexture.image.data.set(data);\n            cmdHorizConnectorTexture.needsUpdate = true;\n            console.log(\"Updated cmd-horiz connector texture data\");\n        } else {\n            console.warn(\"Skipping cmd-horiz texture update: size mismatch or texture not ready\", {\n                textureSize: cmdHorizConnectorTexture?.image.data.length,\n                dataSize: data.length\n            });\n        }\n    }, [\n        cmdHorizConnectors,\n        controls.GRID_WIDTH,\n        controls.GRID_HEIGHT,\n        cmdHorizConnectorTexture\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!meshRef.current) return;\n        // Enable frustum culling\n        meshRef.current.frustumCulled = true;\n        // Update bounding sphere for better culling\n        if (meshRef.current.geometry) {\n            meshRef.current.geometry.computeBoundingSphere();\n            if (meshRef.current.geometry.boundingSphere) {\n                meshRef.current.geometry.boundingSphere.radius *= Math.max(controls.visualScale, 1.0);\n            }\n        }\n    }, [\n        controls.visualScale\n    ]);\n    // --- Performance Monitoring Setup ---\n    const statsRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null); // Use useRef to hold the instance\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        // Stats is disabled for now due to import issues\n        // Initialize Stats.js on component mount\n        /*\n    statsRef.current = new Stats();\n    statsRef.current.showPanel(0); // 0: fps, 1: ms, 2: mb, 3+: custom\n    document.body.appendChild(statsRef.current.dom);\n    */ // Cleanup function to remove Stats.js on unmount\n        return ()=>{\n            if (statsRef.current) {\n                document.body.removeChild(statsRef.current.dom);\n                statsRef.current = null; // Clear the ref\n            }\n        };\n    }, []); // Empty dependency array ensures this runs only once on mount/unmount\n    // Frame update logic (including stats)\n    (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.useFrame)((state)=>{\n        if (statsRef.current) {\n            statsRef.current.update(); // Update FPS counter\n        }\n    // Optional: Log frame time periodically\n    // if (state.clock.elapsedTime % 5 < state.clock.getDelta()) { // Check every 5s\n    //   console.log('Frame time:', state.clock.getDelta() * 1000, 'ms');\n    // }\n    });\n    // Save with direct values\n    const saveGridStateWithDirectValues = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((currentActivation, directIntendedConnectors, directCmdHorizConnectors, gridWidth, gridHeight)=>{\n        console.log(\"========== SAVE DIAGNOSTICS START ==========\");\n        console.log(\"Starting direct save grid state with data:\");\n        console.log(`Current grid dimensions: ${gridWidth} x ${gridHeight}`);\n        // Log the state details\n        console.log(\"- Current activation state has length:\", currentActivation.length);\n        console.log(\"- Active nodes count:\", Array.from(currentActivation).filter((val)=>val === 1.0).length);\n        // Log the raw state for debugging\n        console.log(\"RAW intendedConnectors:\", directIntendedConnectors);\n        console.log(\"RAW cmdHorizConnectors:\", directCmdHorizConnectors);\n        // Make deep copies to ensure we don't mutate the original objects\n        const intendedConnectorsCopy = JSON.parse(JSON.stringify(directIntendedConnectors));\n        const cmdHorizConnectorsCopy = JSON.parse(JSON.stringify(directCmdHorizConnectors));\n        // DEBUG: Log the intended connectors in detail\n        console.log(\"- Intended connectors (direct) keys:\", Object.keys(intendedConnectorsCopy));\n        console.log(\"- Intended connectors (direct) count:\", Object.keys(intendedConnectorsCopy).length);\n        // Check if connectors have actual values or are just empty objects\n        const nonZeroIntendedConnectors = Object.entries(intendedConnectorsCopy).filter(([key, value])=>value !== _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_NONE);\n        console.log(\"- Non-zero intended connectors:\", nonZeroIntendedConnectors.length);\n        console.log(\"- Non-zero intended connectors data:\", nonZeroIntendedConnectors);\n        // DEBUG: Log the cmd horiz connectors in detail\n        console.log(\"- Cmd horiz connectors (direct) keys:\", Object.keys(cmdHorizConnectorsCopy));\n        console.log(\"- Cmd horiz connectors count:\", Object.keys(cmdHorizConnectorsCopy).length);\n        // Check if cmd horiz connectors have actual values or are just empty objects\n        const activeHorizConnectors = Object.entries(cmdHorizConnectorsCopy).filter(([key, value])=>value === 1);\n        console.log(\"- Active horiz connectors:\", activeHorizConnectors.length);\n        console.log(\"- Active horiz connectors data:\", activeHorizConnectors);\n        // Find all active nodes\n        const nodes = [];\n        // Ensure loop uses the correct length based on actual activation array,\n        // but coordinate calculation uses passed dimensions\n        const expectedLength = gridWidth * gridHeight;\n        if (currentActivation.length !== expectedLength) {\n            console.warn(`Activation array length (${currentActivation.length}) doesn't match expected (${expectedLength}) based on passed dimensions! Using array length for loop, but coordinates might be wrong.`);\n        }\n        for(let i = 0; i < currentActivation.length; i++){\n            if (currentActivation[i] === 1.0) {\n                // Use passed gridWidth for coordinate calculation\n                const row = Math.floor(i / gridWidth);\n                const col = i % gridWidth;\n                // Add bounds check just in case activation array length mismatches\n                if (col >= 0 && col < gridWidth && row >= 0 && row < gridHeight) {\n                    nodes.push({\n                        x: col,\n                        y: row\n                    });\n                    console.log(`Found active node at (${col}, ${row})`);\n                } else {\n                    console.warn(`Calculated node coords (${col}, ${row}) for index ${i} are out of bounds for passed dimensions ${gridWidth}x${gridHeight}. Skipping.`);\n                }\n            }\n        }\n        console.log(`Total active nodes found: ${nodes.length}`);\n        // Find all edges - connectors between active nodes\n        const edges = [];\n        // Process intended connectors (diagonals, etc.)\n        console.log(\"Processing intended connectors...\");\n        // Instead of iterating through all positions, directly iterate over the keys in the connectors object\n        for (const key of Object.keys(intendedConnectorsCopy)){\n            const type = intendedConnectorsCopy[key];\n            if (type === undefined || type === _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_NONE) {\n                continue;\n            }\n            // Extract x,y from the key (which is in format \"x,y\")\n            const [x, y] = key.split(\",\").map(Number);\n            // Check if extracted coordinates are valid for the current grid dimensions\n            if (x < 0 || x >= gridWidth - 1 || y < 0 || y >= gridHeight - 1) {\n                console.warn(`Connector at (${x},${y}) is out of bounds for current grid size (${gridWidth}x${gridHeight}), skipping.`);\n                continue;\n            }\n            console.log(`Found connector at (${x},${y}) with key ${key}, type=${type}`);\n            // Map the numeric connector type to the string type for the JSON\n            let edgeType = null;\n            switch(type){\n                case _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_DIAG_TL_BR:\n                    edgeType = \"diag_tl_br\";\n                    console.log(`Converting CONNECTOR_DIAG_TL_BR (${_constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_DIAG_TL_BR}) to 'diag_tl_br'`);\n                    break;\n                case _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_DIAG_BL_TR:\n                    edgeType = \"diag_bl_tr\";\n                    console.log(`Converting CONNECTOR_DIAG_BL_TR (${_constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_DIAG_BL_TR}) to 'diag_bl_tr'`);\n                    break;\n                case _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_HORIZ_T:\n                    edgeType = \"horiz_t\";\n                    console.log(`Converting CONNECTOR_HORIZ_T (${_constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_HORIZ_T}) to 'horiz_t'`);\n                    break;\n                case _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_HORIZ_B:\n                    edgeType = \"horiz_b\";\n                    console.log(`Converting CONNECTOR_HORIZ_B (${_constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_HORIZ_B}) to 'horiz_b'`);\n                    break;\n                default:\n                    console.warn(`Unknown connector type ignored: ${type}`);\n            }\n            if (edgeType) {\n                edges.push({\n                    type: edgeType,\n                    x,\n                    y\n                });\n                console.log(`Added ${edgeType} connector at (${x}, ${y}) to edges array`);\n            }\n        }\n        // Process cmd-horizontal connectors\n        console.log(\"Processing cmd-horizontal connectors...\");\n        // Instead of iterating through all positions, directly iterate over the keys in the cmdHorizConnectors object\n        for (const key of Object.keys(cmdHorizConnectorsCopy)){\n            const value = cmdHorizConnectorsCopy[key];\n            if (value !== 1) {\n                continue;\n            }\n            // Extract x,y from the key (format is \"hcmd:x,y\")\n            const [x, y] = key.substring(5).split(\",\").map(Number);\n            // Check if extracted coordinates are valid for the current grid dimensions\n            if (x < 0 || x >= gridWidth - 1 || y < 0 || y >= gridHeight) {\n                console.warn(`CMD-horiz connector at (${x},${y}) is out of bounds for current grid size (${gridWidth}x${gridHeight}), skipping.`);\n                continue;\n            }\n            edges.push({\n                type: \"cmd_horiz\",\n                x,\n                y\n            });\n            console.log(`Added cmd_horiz connector at (${x}, ${y}) to edges array`);\n        }\n        console.log(`Total edges found: ${edges.length}`);\n        // Create the final JSON data structure\n        const data = {\n            gridWidth,\n            gridHeight,\n            nodes,\n            edges\n        };\n        // Create JSON string\n        const dataStr = JSON.stringify(data, null, 2);\n        console.log(\"Grid State JSON:\", dataStr);\n        console.log(\"========== SAVE DIAGNOSTICS END ==========\");\n        // Trigger download\n        const blob = new Blob([\n            dataStr\n        ], {\n            type: \"application/json\"\n        });\n        const url = URL.createObjectURL(blob);\n        const a = document.createElement(\"a\");\n        a.href = url;\n        a.download = `grid_state_${gridWidth}x${gridHeight}.json`;\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n        URL.revokeObjectURL(url);\n    }, []);\n    // --- Save Grid State Function ---\n    const saveGridState = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        console.log(\"Starting save grid state with data:\");\n        // Get the current activation state directly from the buffer attribute\n        // which is the most up-to-date source of truth\n        let currentActivation;\n        if (activationAttributeRef.current && activationAttributeRef.current.array) {\n            currentActivation = activationAttributeRef.current.array;\n            console.log(\"- Using activation state from buffer attribute\");\n        } else {\n            currentActivation = activationState;\n            console.log(\"- Using activation state from React state (fallback)\");\n        }\n        // Use the ref values which should be in sync with state\n        const currentIntendedConnectors = JSON.parse(JSON.stringify(intendedConnectorsRef.current || {}));\n        const currentCmdHorizConnectors = JSON.parse(JSON.stringify(cmdHorizConnectorsRef.current || {}));\n        // Debug current state\n        console.log(\"Current intended connectors before save:\", currentIntendedConnectors);\n        console.log(\"Keys in intended connectors:\", Object.keys(currentIntendedConnectors));\n        console.log(\"Active intended connectors:\", Object.entries(currentIntendedConnectors).filter(([_, v])=>v !== _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_NONE));\n        console.log(\"Current cmd horiz connectors before save:\", currentCmdHorizConnectors);\n        console.log(\"Active cmd horiz connectors:\", Object.entries(currentCmdHorizConnectors).filter(([_, v])=>v === 1));\n        console.log(\"Using direct save method to ensure up-to-date state capture\");\n        saveGridStateWithDirectValues(currentActivation, currentIntendedConnectors, currentCmdHorizConnectors, controls.GRID_WIDTH, controls.GRID_HEIGHT);\n    }, [\n        controls,\n        activationState,\n        activationAttributeRef\n    ]);\n    // Debug function to create a test pattern similar to what's in the image\n    const createTestPattern = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        console.log(\"========== TEST PATTERN CREATION START ==========\");\n        console.log(\"Creating test pattern\");\n        // Create a new activation state array\n        const newActivationState = new Float32Array(TOTAL_CIRCLES).fill(0.0);\n        // Activate nodes in a pattern similar to the image\n        // The pattern shows a vertical line with some horizontal connectors and diagonal branches\n        const pattern = [\n            // Vertical central column (top to bottom)\n            {\n                x: 5,\n                y: 2\n            },\n            {\n                x: 5,\n                y: 3\n            },\n            {\n                x: 5,\n                y: 4\n            },\n            {\n                x: 5,\n                y: 5\n            },\n            {\n                x: 5,\n                y: 6\n            },\n            {\n                x: 5,\n                y: 7\n            },\n            // Horizontal connection in the middle row\n            {\n                x: 4,\n                y: 4\n            },\n            {\n                x: 6,\n                y: 4\n            },\n            // Diagonal cluster at bottom\n            {\n                x: 4,\n                y: 6\n            },\n            {\n                x: 6,\n                y: 6\n            },\n            // Diagonal node at top\n            {\n                x: 6,\n                y: 3\n            }\n        ];\n        // Set active nodes\n        pattern.forEach(({ x, y })=>{\n            if (x >= 0 && x < controls.GRID_WIDTH && y >= 0 && y < controls.GRID_HEIGHT) {\n                const index = getIndex(y, x, controls.GRID_WIDTH);\n                newActivationState[index] = 1.0;\n                console.log(`Setting active node at (${x}, ${y}), index: ${index}`);\n            }\n        });\n        // Create connectors\n        const newIntendedConnectors = {\n            // Diagonal connections - they use bottom-left coordinates of the 2x2 group\n            \"5,2\": _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_DIAG_BL_TR,\n            \"4,5\": _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_DIAG_BL_TR,\n            \"5,5\": _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_DIAG_TL_BR // Diagonal from (5,6) to (6,5) - bottom right\n        };\n        // Create cmd-horiz connectors - these connect dots horizontally with cmd-click\n        const newCmdHorizConnectors = {\n            // Middle row horizontal connector\n            [\"hcmd:4,4\"]: 1 // Horizontal connector from (4,4) to (5,4)\n        };\n        // Log details of the test pattern\n        console.log(\"Test pattern details:\");\n        console.log(\"- Total active nodes:\", pattern.length);\n        // Log diagonal connector details \n        Object.entries(newIntendedConnectors).forEach(([key, value])=>{\n            const type = value === _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_DIAG_BL_TR ? \"diagonal BL-TR (/)\" : value === _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_DIAG_TL_BR ? \"diagonal TL-BR (\\\\)\" : `unknown type ${value}`;\n            console.log(`- Diagonal connector at ${key}: ${type} (value: ${value})`);\n        });\n        // Log cmd-horiz connector details\n        Object.entries(newCmdHorizConnectors).forEach(([key, value])=>{\n            if (value === 1) {\n                console.log(`- Cmd-horiz connector at ${key.substring(5)}: active`);\n            }\n        });\n        // Set states\n        console.log(\"Setting activation state, intended connectors, and cmd-horiz connectors...\");\n        setActivationState(newActivationState);\n        setIntendedConnectors(newIntendedConnectors);\n        setCmdHorizConnectors(newCmdHorizConnectors);\n        console.log(\"Test pattern created\");\n        // Add check after small delay to verify state was updated\n        setTimeout(()=>{\n            console.log(\"Verification of state update:\");\n            console.log(\"- intendedConnectors:\", intendedConnectors);\n            console.log(\"- nonzero intendedConnectors:\", Object.entries(intendedConnectors).filter(([_, v])=>v !== _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_NONE));\n            console.log(\"- cmdHorizConnectors:\", cmdHorizConnectors);\n            console.log(\"- active cmdHorizConnectors:\", Object.entries(cmdHorizConnectors).filter(([_, v])=>v === 1));\n            // Check if our expectation matches reality\n            const allConnectorsMatch = Object.keys(newIntendedConnectors).length === Object.entries(intendedConnectors).filter(([_, v])=>v !== _constants__WEBPACK_IMPORTED_MODULE_8__.CONNECTOR_NONE).length && Object.keys(newCmdHorizConnectors).filter((k)=>newCmdHorizConnectors[k] === 1).length === Object.entries(cmdHorizConnectors).filter(([_, v])=>v === 1).length;\n            console.log(\"All connectors set correctly:\", allConnectorsMatch ? \"YES\" : \"NO\");\n        }, 100);\n        // Automatically trigger custom save after a delay\n        setTimeout(()=>{\n            console.log(\"========== AUTO-SAVE TEST PATTERN START ==========\");\n            console.log(\"Auto-saving test pattern with direct reference to new states...\");\n            // Get the CURRENT state at the moment of auto-save\n            const currentControls = {\n                ...controls\n            }; // Make a fresh copy of the controls object\n            console.log(`Current controls dimensions: ${currentControls.GRID_WIDTH}x${currentControls.GRID_HEIGHT}`);\n            // Get the current activation state directly from the buffer attribute\n            let currentActivation;\n            if (activationAttributeRef.current && activationAttributeRef.current.array) {\n                currentActivation = activationAttributeRef.current.array;\n                console.log(\"- Using activation state from buffer attribute\");\n            } else {\n                currentActivation = activationState;\n                console.log(\"- Using activation state from React state (fallback)\");\n            }\n            // Use the ref values which should have the most up-to-date state\n            const currentIntendedConnectors = JSON.parse(JSON.stringify(intendedConnectorsRef.current || {}));\n            const currentCmdHorizConnectors = JSON.parse(JSON.stringify(cmdHorizConnectorsRef.current || {}));\n            console.log(\"Ref values for connectors:\", {\n                intended: currentIntendedConnectors,\n                cmdHoriz: currentCmdHorizConnectors\n            });\n            // Save using direct values with current dimensions\n            saveGridStateWithDirectValues(currentActivation, currentIntendedConnectors, currentCmdHorizConnectors, currentControls.GRID_WIDTH, currentControls.GRID_HEIGHT);\n            console.log(\"========== AUTO-SAVE TEST PATTERN END ==========\");\n        }, 500); // 500ms delay should be sufficient\n        console.log(\"========== TEST PATTERN CREATION END ==========\");\n    }, [\n        TOTAL_CIRCLES,\n        controls,\n        setActivationState,\n        setIntendedConnectors,\n        setCmdHorizConnectors,\n        intendedConnectors,\n        cmdHorizConnectors\n    ]);\n    // Debug function to clear everything\n    const clearAll = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        console.log(\"Clearing all state\");\n        setActivationState(new Float32Array(TOTAL_CIRCLES).fill(0.0));\n        setIntendedConnectors({});\n        setCmdHorizConnectors({});\n        // Also clear the refs\n        intendedConnectorsRef.current = {};\n        cmdHorizConnectorsRef.current = {};\n    }, [\n        TOTAL_CIRCLES,\n        setActivationState,\n        setIntendedConnectors,\n        setCmdHorizConnectors\n    ]);\n    // Now that we've defined the debug functions, add the debug controls\n    (0,leva__WEBPACK_IMPORTED_MODULE_3__.useControls)(\"Debug\", ()=>({\n            createTestPattern: (0,leva__WEBPACK_IMPORTED_MODULE_3__.button)(()=>createTestPattern()),\n            clearAll: (0,leva__WEBPACK_IMPORTED_MODULE_3__.button)(()=>clearAll()),\n            directSave: (0,leva__WEBPACK_IMPORTED_MODULE_3__.button)(()=>{\n                console.log(\"Direct save triggered manually\");\n                // Get the CURRENT state at the moment the button is clicked\n                const currentControls = {\n                    ...controls\n                }; // Make a fresh copy of the controls object\n                console.log(`Current controls dimensions: ${currentControls.GRID_WIDTH}x${currentControls.GRID_HEIGHT}`);\n                // Get the current activation state directly from the buffer attribute\n                let currentActivation;\n                if (activationAttributeRef.current && activationAttributeRef.current.array) {\n                    currentActivation = activationAttributeRef.current.array;\n                    console.log(\"- Using activation state from buffer attribute\");\n                } else {\n                    currentActivation = activationState;\n                    console.log(\"- Using activation state from React state (fallback)\");\n                }\n                // Use the ref values which should have the most up-to-date state\n                const currentIntendedConnectors = JSON.parse(JSON.stringify(intendedConnectorsRef.current || {}));\n                const currentCmdHorizConnectors = JSON.parse(JSON.stringify(cmdHorizConnectorsRef.current || {}));\n                console.log(\"Ref values for connectors:\", {\n                    intended: currentIntendedConnectors,\n                    cmdHoriz: currentCmdHorizConnectors\n                });\n                // Save using direct values with current dimensions\n                saveGridStateWithDirectValues(currentActivation, currentIntendedConnectors, currentCmdHorizConnectors, currentControls.GRID_WIDTH, currentControls.GRID_HEIGHT);\n            })\n        }));\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"group\", {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"instancedMesh\", {\n                ref: meshRef,\n                args: [\n                    undefined,\n                    undefined,\n                    TOTAL_CIRCLES\n                ],\n                onClick: handleCircleClick,\n                position: [\n                    0,\n                    0,\n                    -0.1\n                ],\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"planeGeometry\", {\n                        args: [\n                            1,\n                            1\n                        ],\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"instancedBufferAttribute\", {\n                            ref: activationAttributeRef,\n                            attach: \"attributes-a_activated\",\n                            args: [\n                                activationState,\n                                1\n                            ],\n                            usage: three__WEBPACK_IMPORTED_MODULE_2__.DynamicDrawUsage\n                        }, void 0, false, {\n                            fileName: \"/Users/ian/cursor_projects/webGL_meta/components/GridScene.tsx\",\n                            lineNumber: 1421,\n                            columnNumber: 11\n                        }, undefined)\n                    }, void 0, false, {\n                        fileName: \"/Users/ian/cursor_projects/webGL_meta/components/GridScene.tsx\",\n                        lineNumber: 1419,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"circleMaterial\", {\n                        ref: materialRef,\n                        transparent: true\n                    }, _CircleMaterial__WEBPACK_IMPORTED_MODULE_5__[\"default\"].key, false, {\n                        fileName: \"/Users/ian/cursor_projects/webGL_meta/components/GridScene.tsx\",\n                        lineNumber: 1428,\n                        columnNumber: 9\n                    }, undefined)\n                ]\n            }, `circles-${TOTAL_CIRCLES}`, true, {\n                fileName: \"/Users/ian/cursor_projects/webGL_meta/components/GridScene.tsx\",\n                lineNumber: 1411,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"mesh\", {\n                position: [\n                    0,\n                    0,\n                    0.1\n                ],\n                onClick: handleConnectorClick,\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"planeGeometry\", {\n                        args: [\n                            planeWidth,\n                            planeHeight\n                        ]\n                    }, void 0, false, {\n                        fileName: \"/Users/ian/cursor_projects/webGL_meta/components/GridScene.tsx\",\n                        lineNumber: 1441,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"connectorMaterial\", {\n                        ref: connectorMaterialRef,\n                        transparent: true,\n                        side: three__WEBPACK_IMPORTED_MODULE_2__.DoubleSide,\n                        // Pass required uniforms (cmdHoriz texture removed)\n                        u_stateTexture: stateTexture,\n                        u_intendedConnectorTexture: intendedConnectorTexture,\n                        // u_cmdHorizConnectorTexture removed\n                        u_gridDimensions: [\n                            controls.GRID_WIDTH,\n                            controls.GRID_HEIGHT\n                        ],\n                        u_textureResolution: [\n                            controls.GRID_WIDTH,\n                            controls.GRID_HEIGHT\n                        ],\n                        u_radiusA: _constants__WEBPACK_IMPORTED_MODULE_8__.BASE_RADIUS_A,\n                        u_radiusB: _constants__WEBPACK_IMPORTED_MODULE_8__.BASE_RADIUS_B,\n                        u_gridSpacing: controls.visualScale,\n                        u_centerOffset: [\n                            centerOffset.x,\n                            centerOffset.y\n                        ],\n                        u_planeSize: [\n                            planeWidth,\n                            planeHeight\n                        ]\n                    }, _ConnectorMaterial__WEBPACK_IMPORTED_MODULE_6__[\"default\"].key, false, {\n                        fileName: \"/Users/ian/cursor_projects/webGL_meta/components/GridScene.tsx\",\n                        lineNumber: 1442,\n                        columnNumber: 9\n                    }, undefined)\n                ]\n            }, `connector-plane-${controls.GRID_WIDTH}-${controls.GRID_HEIGHT}-${controls.visualScale}`, true, {\n                fileName: \"/Users/ian/cursor_projects/webGL_meta/components/GridScene.tsx\",\n                lineNumber: 1436,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"mesh\", {\n                position: [\n                    0,\n                    0,\n                    0.2\n                ],\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"planeGeometry\", {\n                        args: [\n                            planeWidth,\n                            planeHeight\n                        ]\n                    }, void 0, false, {\n                        fileName: \"/Users/ian/cursor_projects/webGL_meta/components/GridScene.tsx\",\n                        lineNumber: 1468,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"cmdHorizConnectorMaterial\", {\n                        ref: cmdHorizMaterialRef,\n                        transparent: true,\n                        side: three__WEBPACK_IMPORTED_MODULE_2__.DoubleSide,\n                        // Pass necessary uniforms for this specific material\n                        u_stateTexture: stateTexture,\n                        u_cmdHorizConnectorTexture: cmdHorizConnectorTexture,\n                        u_gridDimensions: [\n                            controls.GRID_WIDTH,\n                            controls.GRID_HEIGHT\n                        ],\n                        u_textureResolution: [\n                            controls.GRID_WIDTH,\n                            controls.GRID_HEIGHT\n                        ],\n                        u_radiusA: _constants__WEBPACK_IMPORTED_MODULE_8__.BASE_RADIUS_A,\n                        u_radiusB: _constants__WEBPACK_IMPORTED_MODULE_8__.BASE_RADIUS_B,\n                        u_gridSpacing: controls.visualScale,\n                        u_fixedSpacing: _constants__WEBPACK_IMPORTED_MODULE_8__.FIXED_SPACING,\n                        u_centerOffset: [\n                            centerOffset.x,\n                            centerOffset.y\n                        ],\n                        u_planeSize: [\n                            planeWidth,\n                            planeHeight\n                        ]\n                    }, _CmdHorizConnectorMaterial__WEBPACK_IMPORTED_MODULE_7__[\"default\"].key, false, {\n                        fileName: \"/Users/ian/cursor_projects/webGL_meta/components/GridScene.tsx\",\n                        lineNumber: 1469,\n                        columnNumber: 9\n                    }, undefined)\n                ]\n            }, `cmd-horiz-connector-plane-${controls.GRID_WIDTH}-${controls.GRID_HEIGHT}-${controls.visualScale}`, true, {\n                fileName: \"/Users/ian/cursor_projects/webGL_meta/components/GridScene.tsx\",\n                lineNumber: 1462,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/ian/cursor_projects/webGL_meta/components/GridScene.tsx\",\n        lineNumber: 1410,\n        columnNumber: 5\n    }, undefined);\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GridScene);\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RixTQUFTTyxXQUFXLENBQUMsQ0FBQyxFQUFFUCxTQUFTUSxXQUFXLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7QUEwQi9HO0FBRUEsaUVBQWVULFNBQVNBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWJnbC1kb3QtZ3JpZC1tdnAvLi9jb21wb25lbnRzL0dyaWRTY2VuZS50c3g/MGRjYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlTWVtbywgdXNlUmVmLCB1c2VFZmZlY3QsIHVzZVN0YXRlLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcbmltcG9ydCB7IHVzZUNvbnRyb2xzLCBidXR0b24sIGZvbGRlciB9IGZyb20gJ2xldmEnO1xuaW1wb3J0IHsgdXNlRnJhbWUgfSBmcm9tICdAcmVhY3QtdGhyZWUvZmliZXInO1xuaW1wb3J0IENpcmNsZU1hdGVyaWFsIGZyb20gJy4vQ2lyY2xlTWF0ZXJpYWwnO1xuaW1wb3J0IENvbm5lY3Rvck1hdGVyaWFsIGZyb20gJy4vQ29ubmVjdG9yTWF0ZXJpYWwnO1xuaW1wb3J0IENtZEhvcml6Q29ubmVjdG9yTWF0ZXJpYWwgZnJvbSAnLi9DbWRIb3JpekNvbm5lY3Rvck1hdGVyaWFsJztcbi8vIFN0YXRzIGltcG9ydCBjb21tZW50ZWQgb3V0IC0gbm90IGNyaXRpY2FsIGZvciBmdW5jdGlvbmFsaXR5XG4vLyBpbXBvcnQgU3RhdHMgZnJvbSAndGhyZWUvYWRkb25zL2xpYnMvc3RhdHMubW9kdWxlJztcbmltcG9ydCB7IFxuICBGSVhFRF9TUEFDSU5HLCBcbiAgQkFTRV9SQURJVVNfQSwgXG4gIEJBU0VfUkFESVVTX0IsXG4gIENPTk5FQ1RPUl9OT05FLFxuICBDT05ORUNUT1JfRElBR19UTF9CUixcbiAgQ09OTkVDVE9SX0RJQUdfQkxfVFIsXG4gIENPTk5FQ1RPUl9IT1JJWl9ULFxuICBDT05ORUNUT1JfSE9SSVpfQixcbiAgQ09OTkVDVE9SX0hPUklaX0NNRFxufSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbi8vID09PSBGZWF0dXJlIDE6IEdyaWQgRGF0YSAmIENvbmZpZ3VyYXRpb24gPT09XG5cbi8vIENvbnN0YW50cyBmb3IgYmFzZSBnZW9tZXRyeSAtIFJFTU9WRUQsIG5vdyBpbXBvcnRlZFxuLy8gY29uc3QgQkFTRV9SQURJVVNfQSA9IDAuNTsgLy8gT3V0ZXIgcmFkaXVzXG4vLyBjb25zdCBCQVNFX1JBRElVU19CID0gMC40OyAvLyBJbm5lciByYWRpdXNcbi8vIGNvbnN0IEZJWEVEX1NQQUNJTkcgPSBCQVNFX1JBRElVU19BICsgQkFTRV9SQURJVVNfQjsgLy8gMC45XG5cbmNvbnN0IEJBU0VfR1JJRF9TUEFDSU5HID0gMS4wOyAvLyBLZWVwIGZvciByZWZlcmVuY2UgaWYgbmVlZGVkXG5cbi8vIEhlbHBlciBGdW5jdGlvbnNcbmNvbnN0IGdldEluZGV4ID0gKHJvdzogbnVtYmVyLCBjb2w6IG51bWJlciwgZ3JpZFdpZHRoOiBudW1iZXIpOiBudW1iZXIgPT4ge1xuICByZXR1cm4gcm93ICogZ3JpZFdpZHRoICsgY29sO1xufTtcblxuY29uc3QgZ2V0Q29vcmRzID0gKGluZGV4OiBudW1iZXIsIGdyaWRXaWR0aDogbnVtYmVyKTogeyByb3c6IG51bWJlcjsgY29sOiBudW1iZXIgfSA9PiB7XG4gIGNvbnN0IHJvdyA9IE1hdGguZmxvb3IoaW5kZXggLyBncmlkV2lkdGgpO1xuICBjb25zdCBjb2wgPSBpbmRleCAlIGdyaWRXaWR0aDtcbiAgcmV0dXJuIHsgcm93LCBjb2wgfTtcbn07XG5cbi8vIE1vZGlmaWVkIHRvIHVzZSBmaXhlZCBzcGFjaW5nXG5jb25zdCBnZXRDZW50ZXJPZmZzZXQgPSAoZ3JpZFdpZHRoOiBudW1iZXIsIGdyaWRIZWlnaHQ6IG51bWJlciwgc3BhY2luZzogbnVtYmVyKTogVEhSRUUuVmVjdG9yMiA9PiB7XG4gIGNvbnN0IHRvdGFsV2lkdGggPSAoZ3JpZFdpZHRoIC0gMSkgKiBzcGFjaW5nO1xuICBjb25zdCB0b3RhbEhlaWdodCA9IChncmlkSGVpZ2h0IC0gMSkgKiBzcGFjaW5nO1xuICByZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjIoLXRvdGFsV2lkdGggLyAyLCAtdG90YWxIZWlnaHQgLyAyKTtcbn07XG5cbi8vIE1vZGlmaWVkIHRvIHVzZSBmaXhlZCBzcGFjaW5nXG5jb25zdCBnZXRXb3JsZFBvc2l0aW9uID0gKFxuICByb3c6IG51bWJlcixcbiAgY29sOiBudW1iZXIsXG4gIGdyaWRXaWR0aDogbnVtYmVyLCAvLyBLZWVwIGdyaWQgZGltZW5zaW9ucyBmb3Igb2Zmc2V0IGNhbGN1bGF0aW9uIGlmIG5lZWRlZFxuICBncmlkSGVpZ2h0OiBudW1iZXIsXG4gIHNwYWNpbmc6IG51bWJlciwgLy8gVGhpcyB3aWxsIGJlIEZJWEVEX1NQQUNJTkdcbiAgY2VudGVyT2Zmc2V0OiBUSFJFRS5WZWN0b3IyXG4pOiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH0gPT4ge1xuICBjb25zdCB4ID0gY29sICogc3BhY2luZyArIGNlbnRlck9mZnNldC54O1xuICBjb25zdCB5ID0gcm93ICogc3BhY2luZyArIGNlbnRlck9mZnNldC55O1xuICByZXR1cm4geyB4LCB5IH07XG59O1xuXG4vLyA9PT0gR3JpZFNjZW5lIENvbXBvbmVudCA9PT1cblxuLy8gRHVtbXkgb2JqZWN0IGZvciBtYXRyaXggY2FsY3VsYXRpb25zXG5jb25zdCBkdW1teSA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xuY29uc3QgdGVtcE1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5jb25zdCB0ZW1wVmVjID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuLy8gTmV3OiBIZWxwZXIgZm9yIGhvcml6b250YWwgY21kLWNsaWNrIGNvbm5lY3RvciBrZXkgZ2VuZXJhdGlvblxuY29uc3QgZ2V0SG9yaXpDbWRDb25uZWN0b3JLZXkgPSAoeDogbnVtYmVyLCB5OiBudW1iZXIpID0+IGBoY21kOiR7eH0sJHt5fWA7XG5cbi8vIEhlbHBlciB0byBnZXQgdGhlIGtleSBmb3IgYSAyeDIgY2VsbCBncm91cFxuY29uc3QgZ2V0Q2VsbEdyb3VwS2V5ID0gKGNlbGxYOiBudW1iZXIsIGNlbGxZOiBudW1iZXIpID0+IGAke2NlbGxYfSwke2NlbGxZfWA7XG5cbi8vIC0tLSBBZGphY2VuY3kgTGlzdCBTdHJ1Y3R1cmUgRGVmaW5pdGlvbiAtLS1cbmludGVyZmFjZSBHcmlkTm9kZSB7XG4gIHg6IG51bWJlcjtcbiAgeTogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgR3JpZEVkZ2Uge1xuICB0eXBlOiAnZGlhZ190bF9icicgfCAnZGlhZ19ibF90cicgfCAnaG9yaXpfdCcgfCAnaG9yaXpfYicgfCAnY21kX2hvcml6JztcbiAgeDogbnVtYmVyOyAvLyB4LWNvb3JkIG9mIHRoZSBvcmlnaW4gY2VsbC9jaXJjbGUgZm9yIHRoZSBjb25uZWN0b3JcbiAgeTogbnVtYmVyOyAvLyB5LWNvb3JkIG9mIHRoZSBvcmlnaW4gY2VsbC9jaXJjbGUgZm9yIHRoZSBjb25uZWN0b3Jcbn1cblxuaW50ZXJmYWNlIEFkamFjZW5jeUxpc3REYXRhIHtcbiAgZ3JpZFdpZHRoOiBudW1iZXI7XG4gIGdyaWRIZWlnaHQ6IG51bWJlcjtcbiAgbm9kZXM6IEdyaWROb2RlW107XG4gIGVkZ2VzOiBHcmlkRWRnZVtdO1xufVxuLy8gLS0tIEVuZCBBZGphY2VuY3kgTGlzdCBTdHJ1Y3R1cmUgLS0tXG5cbmNvbnN0IEdyaWRTY2VuZSA9ICgpID0+IHtcbiAgLy8gR2V0IHRoZSBzZXQgZnVuY3Rpb24gZGlyZWN0bHkgZnJvbSB1c2VDb250cm9sc1xuICBjb25zdCBbY29udHJvbHMsIHNldExldmFDb250cm9sXSA9IHVzZUNvbnRyb2xzKCdHcmlkJywgKCkgPT4gKHtcbiAgICBHUklEX1dJRFRIOiB7IHZhbHVlOiAxMCwgbWluOiAyLCBtYXg6IDEwMCwgc3RlcDogMSB9LFxuICAgIEdSSURfSEVJR0hUOiB7IHZhbHVlOiAxMCwgbWluOiAyLCBtYXg6IDEwMCwgc3RlcDogMSB9LFxuICAgIHZpc3VhbFNjYWxlOiB7XG4gICAgICB2YWx1ZTogMS4wLFxuICAgICAgbWluOiAwLjEsXG4gICAgICBtYXg6IDUsXG4gICAgICBzdGVwOiAwLjEsXG4gICAgICBsYWJlbDogJ1Zpc3VhbCBTY2FsZSdcbiAgICB9LFxuICAgIC8vIFVzZSBidXR0b24gZnVuY3Rpb25zIHRoYXQgZG9uJ3QgcmVmZXJlbmNlIHRoZSBjb21wb25lbnQgZnVuY3Rpb25zIGRpcmVjdGx5XG4gICAgJ1NhdmUvTG9hZCc6IGZvbGRlcih7XG4gICAgICAgIHNhdmVTdGF0ZTogYnV0dG9uKCgpID0+IHsgXG4gICAgICAgICAgY29uc29sZS5sb2coXCJTYXZlIGJ1dHRvbiBjbGlja2VkXCIpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEdldCB0aGUgQ1VSUkVOVCBzdGF0ZSBhdCB0aGUgbW9tZW50IHRoZSBidXR0b24gaXMgY2xpY2tlZFxuICAgICAgICAgIGNvbnN0IGN1cnJlbnRDb250cm9scyA9IHsgLi4uY29udHJvbHMgfTsgLy8gTWFrZSBhIGZyZXNoIGNvcHkgb2YgdGhlIGNvbnRyb2xzIG9iamVjdFxuICAgICAgICAgIGNvbnNvbGUubG9nKGBDdXJyZW50IGNvbnRyb2xzIGRpbWVuc2lvbnM6ICR7Y3VycmVudENvbnRyb2xzLkdSSURfV0lEVEh9eCR7Y3VycmVudENvbnRyb2xzLkdSSURfSEVJR0hUfWApO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEdldCB0aGUgY3VycmVudCBhY3RpdmF0aW9uIHN0YXRlIGRpcmVjdGx5IGZyb20gdGhlIGJ1ZmZlciBhdHRyaWJ1dGVcbiAgICAgICAgICBsZXQgY3VycmVudEFjdGl2YXRpb246IEZsb2F0MzJBcnJheTtcbiAgICAgICAgICBpZiAoYWN0aXZhdGlvbkF0dHJpYnV0ZVJlZi5jdXJyZW50ICYmIGFjdGl2YXRpb25BdHRyaWJ1dGVSZWYuY3VycmVudC5hcnJheSkge1xuICAgICAgICAgICAgY3VycmVudEFjdGl2YXRpb24gPSBhY3RpdmF0aW9uQXR0cmlidXRlUmVmLmN1cnJlbnQuYXJyYXkgYXMgRmxvYXQzMkFycmF5O1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCItIFVzaW5nIGFjdGl2YXRpb24gc3RhdGUgZnJvbSBidWZmZXIgYXR0cmlidXRlXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXJyZW50QWN0aXZhdGlvbiA9IGFjdGl2YXRpb25TdGF0ZTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiLSBVc2luZyBhY3RpdmF0aW9uIHN0YXRlIGZyb20gUmVhY3Qgc3RhdGUgKGZhbGxiYWNrKVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVXNlIHRoZSByZWYgdmFsdWVzIHdoaWNoIHNob3VsZCBoYXZlIHRoZSBtb3N0IHVwLXRvLWRhdGUgc3RhdGVcbiAgICAgICAgICBjb25zdCBjdXJyZW50SW50ZW5kZWRDb25uZWN0b3JzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShpbnRlbmRlZENvbm5lY3RvcnNSZWYuY3VycmVudCB8fCB7fSkpO1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRDbWRIb3JpekNvbm5lY3RvcnMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGNtZEhvcml6Q29ubmVjdG9yc1JlZi5jdXJyZW50IHx8IHt9KSk7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc29sZS5sb2coXCJSZWYgdmFsdWVzIGZvciBjb25uZWN0b3JzOlwiLCB7XG4gICAgICAgICAgICBpbnRlbmRlZDogY3VycmVudEludGVuZGVkQ29ubmVjdG9ycyxcbiAgICAgICAgICAgIGNtZEhvcml6OiBjdXJyZW50Q21kSG9yaXpDb25uZWN0b3JzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gU2F2ZSB1c2luZyBkaXJlY3QgdmFsdWVzIHdpdGggY3VycmVudCBkaW1lbnNpb25zXG4gICAgICAgICAgc2F2ZUdyaWRTdGF0ZVdpdGhEaXJlY3RWYWx1ZXMoXG4gICAgICAgICAgICBjdXJyZW50QWN0aXZhdGlvbixcbiAgICAgICAgICAgIGN1cnJlbnRJbnRlbmRlZENvbm5lY3RvcnMsXG4gICAgICAgICAgICBjdXJyZW50Q21kSG9yaXpDb25uZWN0b3JzLFxuICAgICAgICAgICAgY3VycmVudENvbnRyb2xzLkdSSURfV0lEVEgsXG4gICAgICAgICAgICBjdXJyZW50Q29udHJvbHMuR1JJRF9IRUlHSFRcbiAgICAgICAgICApO1xuICAgICAgICB9KSxcbiAgICAgICAgbG9hZFN0YXRlOiBidXR0b24oKCkgPT4geyBcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIkxvYWQgcmVxdWVzdGVkXCIpO1xuICAgICAgICAgIGNvbnN0IGpzb25JbnB1dCA9IHByb21wdChcIlBhc3RlIEdyaWQgU3RhdGUgSlNPTjpcIik7XG4gICAgICAgICAgaWYgKCFqc29uSW5wdXQpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJMb2FkIGNhbmNlbGxlZC5cIik7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgZGF0YTogQWRqYWNlbmN5TGlzdERhdGEgPSBKU09OLnBhcnNlKGpzb25JbnB1dCk7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUGFyc2VkIEpTT04gZGF0YTpcIiwgZGF0YSk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBJbnN0ZWFkIG9mIGNhbGxpbmcgdGhlIGxvYWRHcmlkU3RhdGUgZnVuY3Rpb24sIHByb2Nlc3MgdGhlIGRhdGEgZGlyZWN0bHlcbiAgICAgICAgICAgICAgLy8gVmFsaWRhdGUgYmFzaWMgc3RydWN0dXJlXG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgIHR5cGVvZiBkYXRhLmdyaWRXaWR0aCAhPT0gJ251bWJlcicgfHxcbiAgICAgICAgICAgICAgICAgIHR5cGVvZiBkYXRhLmdyaWRIZWlnaHQgIT09ICdudW1iZXInIHx8XG4gICAgICAgICAgICAgICAgICAhQXJyYXkuaXNBcnJheShkYXRhLm5vZGVzKSB8fFxuICAgICAgICAgICAgICAgICAgIUFycmF5LmlzQXJyYXkoZGF0YS5lZGdlcylcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIEpTT04gc3RydWN0dXJlLlwiKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiR3JpZCBkaW1lbnNpb25zIHRvIGJlIHNldDpcIiwgZGF0YS5ncmlkV2lkdGgsIFwieFwiLCBkYXRhLmdyaWRIZWlnaHQpO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIk5vZGVzIHRvIGxvYWQ6XCIsIGRhdGEubm9kZXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJFZGdlcyB0byBsb2FkOlwiLCBkYXRhLmVkZ2VzLmxlbmd0aCk7XG5cbiAgICAgICAgICAgICAgLy8gLS0tIFVzZSB0aGUgY2FwdHVyZWQgc2V0TGV2YUNvbnRyb2wgZnVuY3Rpb24gLS0tXG4gICAgICAgICAgICAgIHNldExldmFDb250cm9sKHsgR1JJRF9XSURUSDogZGF0YS5ncmlkV2lkdGgsIEdSSURfSEVJR0hUOiBkYXRhLmdyaWRIZWlnaHQgfSk7XG5cbiAgICAgICAgICAgICAgLy8gLS0tIFByb2Nlc3MgTm9kZXMgYW5kIEVkZ2VzIC0tLVxuICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgIC8vIFVzZSBkYXRhLmdyaWRXaWR0aC9IZWlnaHQgaGVyZSBhcyBjb250cm9scyBtaWdodCBub3QgaGF2ZSB1cGRhdGVkIHlldFxuICAgICAgICAgICAgICAgICAgY29uc3QgbmV3VG90YWxDaXJjbGVzID0gZGF0YS5ncmlkV2lkdGggKiBkYXRhLmdyaWRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICBjb25zdCBuZXdBY3RpdmF0aW9uU3RhdGUgPSBuZXcgRmxvYXQzMkFycmF5KG5ld1RvdGFsQ2lyY2xlcykuZmlsbCgwLjApO1xuICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlNldHRpbmcgYWN0aXZlIG5vZGVzLi4uXCIpO1xuICAgICAgICAgICAgICAgICAgZGF0YS5ub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnggPj0gMCAmJiBub2RlLnggPCBkYXRhLmdyaWRXaWR0aCAmJiBub2RlLnkgPj0gMCAmJiBub2RlLnkgPCBkYXRhLmdyaWRIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBnZXRJbmRleChub2RlLnksIG5vZGUueCwgZGF0YS5ncmlkV2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdBY3RpdmF0aW9uU3RhdGVbaW5kZXhdID0gMS4wO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgQWN0aXZhdGluZyBub2RlIGF0ICgke25vZGUueH0sICR7bm9kZS55fSksIGluZGV4OiAke2luZGV4fWApO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgTm9kZSBvdXQgb2YgYm91bmRzIGlnbm9yZWQ6ICgke25vZGUueH0sICR7bm9kZS55fSlgKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgY29uc3QgbmV3SW50ZW5kZWRDb25uZWN0b3JzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge307XG4gICAgICAgICAgICAgICAgICBjb25zdCBuZXdDbWRIb3JpekNvbm5lY3RvcnM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fTtcblxuICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJQcm9jZXNzaW5nIGVkZ2VzLi4uXCIpO1xuICAgICAgICAgICAgICAgICAgZGF0YS5lZGdlcy5mb3JFYWNoKGVkZ2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlByb2Nlc3NpbmcgZWRnZTpcIiwgZWRnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgIGxldCBjb25uZWN0b3JUeXBlOiBudW1iZXIgPSBDT05ORUNUT1JfTk9ORTtcbiAgICAgICAgICAgICAgICAgICAgICAgbGV0IGlzVmFsaWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGVkZ2UudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdkaWFnX3RsX2JyJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3RvclR5cGUgPSBDT05ORUNUT1JfRElBR19UTF9CUjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzVmFsaWQgPSBlZGdlLnggPj0gMCAmJiBlZGdlLnggPCBkYXRhLmdyaWRXaWR0aCAtIDEgJiYgZWRnZS55ID49IDAgJiYgZWRnZS55IDwgZGF0YS5ncmlkSGVpZ2h0IC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdkaWFnX2JsX3RyJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3RvclR5cGUgPSBDT05ORUNUT1JfRElBR19CTF9UUjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzVmFsaWQgPSBlZGdlLnggPj0gMCAmJiBlZGdlLnggPCBkYXRhLmdyaWRXaWR0aCAtIDEgJiYgZWRnZS55ID49IDAgJiYgZWRnZS55IDwgZGF0YS5ncmlkSGVpZ2h0IC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdob3Jpel90JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3RvclR5cGUgPSBDT05ORUNUT1JfSE9SSVpfVDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzVmFsaWQgPSBlZGdlLnggPj0gMCAmJiBlZGdlLnggPCBkYXRhLmdyaWRXaWR0aCAtIDEgJiYgZWRnZS55ID49IDAgJiYgZWRnZS55IDwgZGF0YS5ncmlkSGVpZ2h0IC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdob3Jpel9iJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3RvclR5cGUgPSBDT05ORUNUT1JfSE9SSVpfQjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzVmFsaWQgPSBlZGdlLnggPj0gMCAmJiBlZGdlLnggPCBkYXRhLmdyaWRXaWR0aCAtIDEgJiYgZWRnZS55ID49IDAgJiYgZWRnZS55IDwgZGF0YS5ncmlkSGVpZ2h0IC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjbWRfaG9yaXonOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyB0eXBlIHVwZGF0ZXMgYSBkaWZmZXJlbnQgc3RhdGUgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkID0gZWRnZS54ID49IDAgJiYgZWRnZS54IDwgZGF0YS5ncmlkV2lkdGggLSAxICYmIGVkZ2UueSA+PSAwICYmIGVkZ2UueSA8IGRhdGEuZ3JpZEhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gZ2V0SG9yaXpDbWRDb25uZWN0b3JLZXkoZWRnZS54LCBlZGdlLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NtZEhvcml6Q29ubmVjdG9yc1trZXldID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgQWRkZWQgY21kX2hvcml6IGNvbm5lY3RvciBhdCAoJHtlZGdlLnh9LCAke2VkZ2UueX0pIHdpdGgga2V5ICR7a2V5fWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFVua25vd24gZWRnZSB0eXBlIGlnbm9yZWQ6ICR7ZWRnZS50eXBlfWApO1xuICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgLy8gQXNzaWduIHRvIGludGVuZGVkQ29ubmVjdG9ycyAqYWZ0ZXIqIHRoZSBzd2l0Y2gsIGlmIHZhbGlkIGFuZCBhcHBsaWNhYmxlXG4gICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkICYmIGVkZ2UudHlwZSAhPT0gJ2NtZF9ob3JpeicgJiYgY29ubmVjdG9yVHlwZSAhPT0gQ09OTkVDVE9SX05PTkUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBnZXRDZWxsR3JvdXBLZXkoZWRnZS54LCBlZGdlLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0ludGVuZGVkQ29ubmVjdG9yc1trZXldID0gY29ubmVjdG9yVHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgQWRkZWQgJHtlZGdlLnR5cGV9IGNvbm5lY3RvciBhdCAoJHtlZGdlLnh9LCAke2VkZ2UueX0pIHdpdGgga2V5ICR7a2V5fSBhbmQgdHlwZSB2YWx1ZSAke2Nvbm5lY3RvclR5cGV9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgRWRnZSBvdXQgb2YgYm91bmRzIG9yIGludmFsaWQgaWdub3JlZDpgLCBlZGdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU2V0dGluZyBhY3RpdmF0aW9uIHN0YXRlIHdpdGhcIiwgT2JqZWN0LnZhbHVlcyhuZXdBY3RpdmF0aW9uU3RhdGUpLmZpbHRlcih2ID0+IHYgPT09IDEuMCkubGVuZ3RoLCBcImFjdGl2ZSBub2Rlc1wiKTtcbiAgICAgICAgICAgICAgICAgIHNldEFjdGl2YXRpb25TdGF0ZShuZXdBY3RpdmF0aW9uU3RhdGUpO1xuICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlNldHRpbmcgaW50ZW5kZWQgY29ubmVjdG9yczpcIiwgT2JqZWN0LmtleXMobmV3SW50ZW5kZWRDb25uZWN0b3JzKS5sZW5ndGgsIFwiY29ubmVjdG9yc1wiKTtcbiAgICAgICAgICAgICAgICAgIHNldEludGVuZGVkQ29ubmVjdG9ycyhuZXdJbnRlbmRlZENvbm5lY3RvcnMpO1xuICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSByZWYgYXMgd2VsbFxuICAgICAgICAgICAgICAgICAgaW50ZW5kZWRDb25uZWN0b3JzUmVmLmN1cnJlbnQgPSB7IC4uLm5ld0ludGVuZGVkQ29ubmVjdG9ycyB9O1xuICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlNldHRpbmcgY21kLWhvcml6IGNvbm5lY3RvcnM6XCIsIE9iamVjdC5rZXlzKG5ld0NtZEhvcml6Q29ubmVjdG9ycykubGVuZ3RoLCBcImNvbm5lY3RvcnNcIik7XG4gICAgICAgICAgICAgICAgICBzZXRDbWRIb3JpekNvbm5lY3RvcnMobmV3Q21kSG9yaXpDb25uZWN0b3JzKTtcbiAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcmVmIGFzIHdlbGxcbiAgICAgICAgICAgICAgICAgIGNtZEhvcml6Q29ubmVjdG9yc1JlZi5jdXJyZW50ID0geyAuLi5uZXdDbWRIb3JpekNvbm5lY3RvcnMgfTtcblxuICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJHcmlkIHN0YXRlIGxvYWRlZCBzdWNjZXNzZnVsbHkuXCIpO1xuICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAvLyBWZXJpZnkgdGhlIGxvYWRlZCBzdGF0ZSBhZnRlciBhIHNob3J0IGRlbGF5XG4gICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlZlcmlmaWNhdGlvbiBvZiBsb2FkZWQgc3RhdGU6XCIpO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiLSBBY3RpdmUgbm9kZXM6XCIsIE9iamVjdC52YWx1ZXMoYWN0aXZhdGlvblN0YXRlKS5maWx0ZXIodiA9PiB2ID09PSAxLjApLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCItIEludGVuZGVkIGNvbm5lY3RvcnM6XCIsIE9iamVjdC5lbnRyaWVzKGludGVuZGVkQ29ubmVjdG9ycykuZmlsdGVyKChbXywgdl0pID0+IHYgIT09IENPTk5FQ1RPUl9OT05FKS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiLSBDbWQtaG9yaXogY29ubmVjdG9yczpcIiwgT2JqZWN0LmVudHJpZXMoY21kSG9yaXpDb25uZWN0b3JzKS5maWx0ZXIoKFtfLCB2XSkgPT4gdiA9PT0gMSkubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgIH0sIDIwMCk7XG4gICAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBwYXJzZSBvciBwcm9jZXNzIEpTT046XCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgYWxlcnQoYEVycm9yOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfSlcbiAgfSkpO1xuXG4gIC8vIERlcml2ZWQgdmFsdWVzIGNhbGN1bGF0aW9uIC0gdXNlICdjb250cm9scycgbm93XG4gIGNvbnN0IHsgVE9UQUxfQ0lSQ0xFUywgY2VudGVyT2Zmc2V0LCBwbGFuZVdpZHRoLCBwbGFuZUhlaWdodCB9ID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICBjb25zdCB0b3RhbCA9IGNvbnRyb2xzLkdSSURfV0lEVEggKiBjb250cm9scy5HUklEX0hFSUdIVDtcbiAgICAgIGNvbnN0IG9mZnNldCA9IGdldENlbnRlck9mZnNldChjb250cm9scy5HUklEX1dJRFRILCBjb250cm9scy5HUklEX0hFSUdIVCwgRklYRURfU1BBQ0lORyk7XG4gICAgICBjb25zdCB3aWR0aCA9IChjb250cm9scy5HUklEX1dJRFRIID4gMSA/IChjb250cm9scy5HUklEX1dJRFRIIC0gMSkgKiBGSVhFRF9TUEFDSU5HIDogMCkgKyAoY29udHJvbHMudmlzdWFsU2NhbGUgKiBCQVNFX1JBRElVU19BICogMik7XG4gICAgICBjb25zdCBoZWlnaHQgPSAoY29udHJvbHMuR1JJRF9IRUlHSFQgPiAxID8gKGNvbnRyb2xzLkdSSURfSEVJR0hUIC0gMSkgKiBGSVhFRF9TUEFDSU5HIDogMCkgKyAoY29udHJvbHMudmlzdWFsU2NhbGUgKiBCQVNFX1JBRElVU19BICogMik7XG4gICAgICByZXR1cm4geyBUT1RBTF9DSVJDTEVTOiB0b3RhbCwgY2VudGVyT2Zmc2V0OiBvZmZzZXQsIHBsYW5lV2lkdGg6IHdpZHRoLCBwbGFuZUhlaWdodDogaGVpZ2h0IH07XG4gIH0sIFtjb250cm9scy5HUklEX1dJRFRILCBjb250cm9scy5HUklEX0hFSUdIVCwgY29udHJvbHMudmlzdWFsU2NhbGVdKTsgLy8gVXBkYXRlIGRlcGVuZGVuY2llc1xuXG4gIC8vIFJlZnMgZm9yIG1lc2ggYW5kIG1hdGVyaWFsXG4gIGNvbnN0IG1lc2hSZWYgPSB1c2VSZWY8VEhSRUUuSW5zdGFuY2VkTWVzaD4obnVsbCEpO1xuICBjb25zdCBtYXRlcmlhbFJlZiA9IHVzZVJlZjxhbnk+KG51bGwhKTsgLy8gVXNlICdhbnknIG9yIHNwZWNpZmljIHR5cGUgZm9yIENpcmNsZU1hdGVyaWFsXG4gIGNvbnN0IGFjdGl2YXRpb25BdHRyaWJ1dGVSZWYgPSB1c2VSZWY8VEhSRUUuSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlPihudWxsISk7XG4gIGNvbnN0IGNvbm5lY3Rvck1hdGVyaWFsUmVmID0gdXNlUmVmPGFueT4obnVsbCEpOyAvLyBSZWYgZm9yIGNvbm5lY3RvciBtYXRlcmlhbFxuICBjb25zdCBjbWRIb3Jpek1hdGVyaWFsUmVmID0gdXNlUmVmPGFueT4obnVsbCk7XG4gIFxuICAvLyBSZWZzIHRvIHRyYWNrIGN1cnJlbnQgc3RhdGVcbiAgY29uc3QgaW50ZW5kZWRDb25uZWN0b3JzUmVmID0gdXNlUmVmPFJlY29yZDxzdHJpbmcsIG51bWJlcj4+KHt9KTtcbiAgY29uc3QgY21kSG9yaXpDb25uZWN0b3JzUmVmID0gdXNlUmVmPFJlY29yZDxzdHJpbmcsIG51bWJlcj4+KHt9KTtcblxuICAvLyA9PT0gRmVhdHVyZSAzOiBDaXJjbGUgQWN0aXZhdGlvbiBTdGF0ZSA9PT1cbiAgY29uc3QgW2FjdGl2YXRpb25TdGF0ZSwgc2V0QWN0aXZhdGlvblN0YXRlXSA9IHVzZVN0YXRlPEZsb2F0MzJBcnJheT4oKCkgPT4gXG4gICAgbmV3IEZsb2F0MzJBcnJheShUT1RBTF9DSVJDTEVTKS5maWxsKDAuMCkgLy8gMC4wIGluYWN0aXZlLCAxLjAgYWN0aXZlXG4gICk7XG5cbiAgLy8gTmV3OiBBZGQgaG9yaXpvbnRhbCBjbWQtY2xpY2sgY29ubmVjdG9yIHN0YXRlXG4gIGNvbnN0IFtjbWRIb3JpekNvbm5lY3RvcnMsIHNldENtZEhvcml6Q29ubmVjdG9yc10gPSB1c2VTdGF0ZTxSZWNvcmQ8c3RyaW5nLCBudW1iZXI+Pih7fSk7XG5cbiAgLy8gPT09IEZlYXR1cmUgODogQ29ubmVjdG9yIEludGVyYWN0aW9uIFN0YXRlIGFuZCBIZWxwZXJzIChNb3ZlZCBVUCkgPT09XG4gIGNvbnN0IFtpbnRlbmRlZENvbm5lY3RvcnMsIHNldEludGVuZGVkQ29ubmVjdG9yc10gPSB1c2VTdGF0ZTxSZWNvcmQ8c3RyaW5nLCBudW1iZXI+Pih7fSk7XG5cbiAgLy8gSGVscGVyIHRvIGdldCB0aGUgaW50ZW5kZWQgY29ubmVjdG9yIGZvciBhIDJ4MiBjZWxsIGdyb3VwIChNb3ZlZCBVUClcbiAgY29uc3QgZ2V0SW50ZW5kZWRDb25uZWN0b3IgPSB1c2VDYWxsYmFjaygoY2VsbFg6IG51bWJlciwgY2VsbFk6IG51bWJlcikgPT4ge1xuICAgIGlmIChjZWxsWCA8IDAgfHwgY2VsbFggPj0gY29udHJvbHMuR1JJRF9XSURUSCAtIDEgfHwgY2VsbFkgPCAwIHx8IGNlbGxZID49IGNvbnRyb2xzLkdSSURfSEVJR0hUIC0gMSkge1xuICAgICAgICByZXR1cm4gQ09OTkVDVE9SX05PTkU7XG4gICAgfVxuICAgIGNvbnN0IGtleSA9IGdldENlbGxHcm91cEtleShjZWxsWCwgY2VsbFkpO1xuICAgIHJldHVybiBpbnRlbmRlZENvbm5lY3RvcnNba2V5XSB8fCBDT05ORUNUT1JfTk9ORTtcbiAgfSwgW2ludGVuZGVkQ29ubmVjdG9ycywgY29udHJvbHMuR1JJRF9XSURUSCwgY29udHJvbHMuR1JJRF9IRUlHSFRdKTtcblxuICAvLyBTdGF0ZSBuZWVkcyB0byBiZSByZXNldCBpZiBUT1RBTF9DSVJDTEVTIGNoYW5nZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zb2xlLmxvZygnUmVzZXR0aW5nIGFjdGl2YXRpb24gc3RhdGUgZHVlIHRvIGdyaWQgc2l6ZSBjaGFuZ2UnKTtcbiAgICBzZXRBY3RpdmF0aW9uU3RhdGUobmV3IEZsb2F0MzJBcnJheShUT1RBTF9DSVJDTEVTKS5maWxsKDAuMCkpO1xuICAgIHNldEludGVuZGVkQ29ubmVjdG9ycyh7fSk7IC8vIEFsc28gcmVzZXQgaW50ZW5kZWQgY29ubmVjdG9yc1xuICAgIHNldENtZEhvcml6Q29ubmVjdG9ycyh7fSk7IC8vIEFsc28gcmVzZXQgY21kLWhvcml6IGNvbm5lY3RvcnNcbiAgICBcbiAgICAvLyBBbHNvIHJlc2V0IHRoZSByZWZzXG4gICAgaW50ZW5kZWRDb25uZWN0b3JzUmVmLmN1cnJlbnQgPSB7fTtcbiAgICBjbWRIb3JpekNvbm5lY3RvcnNSZWYuY3VycmVudCA9IHt9O1xuICB9LCBbVE9UQUxfQ0lSQ0xFU10pO1xuXG4gIC8vIFVwZGF0ZSBidWZmZXIgYXR0cmlidXRlIHdoZW4gc3RhdGUgY2hhbmdlc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChhY3RpdmF0aW9uQXR0cmlidXRlUmVmLmN1cnJlbnQpIHtcbiAgICAgIGFjdGl2YXRpb25BdHRyaWJ1dGVSZWYuY3VycmVudC5hcnJheSA9IGFjdGl2YXRpb25TdGF0ZTtcbiAgICAgIGFjdGl2YXRpb25BdHRyaWJ1dGVSZWYuY3VycmVudC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAvLyBjb25zb2xlLmxvZygnVXBkYXRlZCBhY3RpdmF0aW9uIGJ1ZmZlciBhdHRyaWJ1dGUuJyk7IC8vIExlc3Mgbm9pc3kgbG9nXG4gICAgfVxuICB9LCBbYWN0aXZhdGlvblN0YXRlXSk7XG5cbiAgLy8gPT09IEZlYXR1cmUgMjogU3RhdGljIENpcmNsZSBSZW5kZXJpbmcgPT09XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFtZXNoUmVmLmN1cnJlbnQpIHJldHVybjtcblxuICAgIC8vIENhbGN1bGF0ZSBhbmQgc2V0IGluc3RhbmNlIG1hdHJpY2VzXG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IFRPVEFMX0NJUkNMRVM7IGluZGV4KyspIHtcbiAgICAgIGNvbnN0IHsgcm93LCBjb2wgfSA9IGdldENvb3JkcyhpbmRleCwgY29udHJvbHMuR1JJRF9XSURUSCk7XG4gICAgICBjb25zdCB7IHgsIHkgfSA9IGdldFdvcmxkUG9zaXRpb24oXG4gICAgICAgIHJvdyxcbiAgICAgICAgY29sLFxuICAgICAgICBjb250cm9scy5HUklEX1dJRFRILFxuICAgICAgICBjb250cm9scy5HUklEX0hFSUdIVCxcbiAgICAgICAgRklYRURfU1BBQ0lORyxcbiAgICAgICAgY2VudGVyT2Zmc2V0XG4gICAgICApO1xuICAgICAgZHVtbXkucG9zaXRpb24uc2V0KHgsIHksIDApOyAvLyBaPTAgZm9yIGNpcmNsZXNcbiAgICAgICAvLyBSZXRyaWV2ZSBleGlzdGluZyBzY2FsZS9yb3RhdGlvbiBiZWZvcmUgc2V0dGluZyBwb3NpdGlvbiB0byBhdm9pZCBvdmVyd3JpdGluZyBzY2FsZSBlZmZlY3RcbiAgICAgIGNvbnN0IGN1cnJlbnRNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuICAgICAgbWVzaFJlZi5jdXJyZW50LmdldE1hdHJpeEF0KGluZGV4LCBjdXJyZW50TWF0cml4KTtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgIGNvbnN0IHF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuICAgICAgY29uc3Qgc2NhbGVWZWMgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgY3VycmVudE1hdHJpeC5kZWNvbXBvc2UocG9zaXRpb24sIHF1YXRlcm5pb24sIHNjYWxlVmVjKTtcbiAgICAgIC8vIFVwZGF0ZSBvbmx5IHBvc2l0aW9uXG4gICAgICBwb3NpdGlvbi5zZXQoeCwgeSwgMCk7XG4gICAgICBkdW1teS5tYXRyaXguY29tcG9zZShwb3NpdGlvbiwgcXVhdGVybmlvbiwgc2NhbGVWZWMpOyAvLyBSZWNvbXBvc2Ugd2l0aCBvcmlnaW5hbCBzY2FsZS9yb3RhdGlvblxuICAgICAgbWVzaFJlZi5jdXJyZW50LnNldE1hdHJpeEF0KGluZGV4LCBkdW1teS5tYXRyaXgpO1xuICAgIH1cbiAgICBtZXNoUmVmLmN1cnJlbnQuaW5zdGFuY2VNYXRyaXgubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgLy8gY29uc29sZS5sb2coYFVwZGF0ZWQgJHtUT1RBTF9DSVJDTEVTfSBpbnN0YW5jZSBtYXRyaWNlcyAocG9zaXRpb24pLmApO1xuXG4gIH0sIFtjb250cm9scy5HUklEX1dJRFRILCBjb250cm9scy5HUklEX0hFSUdIVCwgRklYRURfU1BBQ0lORywgVE9UQUxfQ0lSQ0xFUywgY2VudGVyT2Zmc2V0XSk7XG5cbiAgLy8gVXBkYXRlIHNoYWRlciB1bmlmb3JtcyB3aGVuIHNjYWxlZCByYWRpaSBjaGFuZ2VcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAobWF0ZXJpYWxSZWYuY3VycmVudCkge1xuICAgICAgLy8gU2hhZGVyIGV4cGVjdHMgcmFkaWkgcmVsYXRpdmUgdG8gcGxhbmUgc2l6ZSAoMC4wIHRvIDAuNSByYW5nZSBpZiBwbGFuZSBpcyBzaXplIDEpXG4gICAgICAvLyBMZXQncyB1c2UgcGxhbmUgc2l6ZSAxIGFuZCBzY2FsZSByYWRpaSB0byAwLjAtMC41IHJhbmdlIGZvciBzaGFkZXIuXG4gICAgICBtYXRlcmlhbFJlZi5jdXJyZW50LnVuaWZvcm1zLnVfcmFkaXVzQS52YWx1ZSA9IEJBU0VfUkFESVVTX0E7IC8vIFVzZSBiYXNlIHJhZGl1cyByZWxhdGl2ZSB0byBwbGFuZSBzaXplIDFcbiAgICAgIG1hdGVyaWFsUmVmLmN1cnJlbnQudW5pZm9ybXMudV9yYWRpdXNCLnZhbHVlID0gQkFTRV9SQURJVVNfQjsgLy8gVXNlIGJhc2UgcmFkaXVzIHJlbGF0aXZlIHRvIHBsYW5lIHNpemUgMVxuICAgICAgLy8gU2NhbGUgdGhlIHdob2xlIGluc3RhbmNlIGluc3RlYWQgdG8gbWF0Y2ggc3BhY2luZ1xuICAgICAgIGNvbnNvbGUubG9nKGBVcGRhdGVkIG1hdGVyaWFsIHJhZGlpIHVuaWZvcm1zOiBBPSR7QkFTRV9SQURJVVNfQX0sIEI9JHtCQVNFX1JBRElVU19CfWApO1xuICAgIH1cbiAgfSwgW10pOyAvLyBEZXBlbmQgb24gc2NhbGVkIHJhZGlpLCB0aG91Z2ggdXNpbmcgYmFzZSBmb3IgdW5pZm9ybSBub3dcblxuIC8vIEFkanVzdCBpbnN0YW5jZSBzY2FsZSBiYXNlZCBvbiBzcGFjaW5nXG4gdXNlRWZmZWN0KCgpID0+IHtcbiAgaWYgKCFtZXNoUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgY29uc3Qgc2NhbGUgPSBjb250cm9scy52aXN1YWxTY2FsZTsgLy8gVXNlIHRoZSBsZXZhIGNvbnRyb2wgdmFsdWUgZm9yIHNjYWxlXG4gIGNvbnNvbGUubG9nKGBVcGRhdGluZyBpbnN0YW5jZSBzY2FsZXMgdG86ICR7c2NhbGUudG9GaXhlZCgyKX1gKTtcbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IFRPVEFMX0NJUkNMRVM7IGluZGV4KyspIHtcbiAgICAgIG1lc2hSZWYuY3VycmVudC5nZXRNYXRyaXhBdChpbmRleCwgdGVtcE1hdHJpeCk7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IHRlbXBWZWMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHRlbXBNYXRyaXgpO1xuICAgICAgY29uc3QgcXVhdGVybmlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCkuc2V0RnJvbVJvdGF0aW9uTWF0cml4KHRlbXBNYXRyaXgpO1xuICAgICAgLy8gVXBkYXRlIG9ubHkgc2NhbGVcbiAgICAgIGNvbnN0IHNjYWxlVmVjID0gbmV3IFRIUkVFLlZlY3RvcjMoKS5zZXQoc2NhbGUsIHNjYWxlLCAxKTtcbiAgICAgIFxuICAgICAgdGVtcE1hdHJpeC5jb21wb3NlKHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCBzY2FsZVZlYyk7XG4gICAgICBtZXNoUmVmLmN1cnJlbnQuc2V0TWF0cml4QXQoaW5kZXgsIHRlbXBNYXRyaXgpO1xuICB9XG4gIG1lc2hSZWYuY3VycmVudC5pbnN0YW5jZU1hdHJpeC5uZWVkc1VwZGF0ZSA9IHRydWU7XG59LCBbY29udHJvbHMudmlzdWFsU2NhbGUsIFRPVEFMX0NJUkNMRVNdKTsgLy8gRGVwZW5kcyBvbiBzY2FsZSBjb250cm9sIGFuZCBjb3VudFxuXG4gIC8vID09PSBGZWF0dXJlIDQ6IENpcmNsZSBJbnRlcmFjdGlvbiAoTm93IHVzZXMgaGVscGVycyBkZWZpbmVkIGFib3ZlKSA9PT1cbiAgY29uc3QgaGFuZGxlQ2lyY2xlQ2xpY2sgPSB1c2VDYWxsYmFjaygoZXZlbnQ6IGFueSkgPT4ge1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGlmIChldmVudC5pbnN0YW5jZUlkID09PSB1bmRlZmluZWQgfHwgIW1lc2hSZWYuY3VycmVudCkgcmV0dXJuO1xuXG4gICAgY29uc3QgaW5kZXggPSBldmVudC5pbnN0YW5jZUlkO1xuICAgIGNvbnN0IHsgcm93OiB5LCBjb2w6IHggfSA9IGdldENvb3JkcyhpbmRleCwgY29udHJvbHMuR1JJRF9XSURUSCk7XG4gICAgXG4gICAgY29uc29sZS5sb2coJ0NpcmNsZSBjbGlja2VkOicsIHtcbiAgICAgIGluZGV4LFxuICAgICAgeCwgeSxcbiAgICAgIGlzQ21kQ2xpY2s6IGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuY3RybEtleSxcbiAgICAgIHBvaW50OiBldmVudC5wb2ludCxcbiAgICAgIGN1cnJlbnRTdGF0ZTogYWN0aXZhdGlvblN0YXRlW2luZGV4XVxuICAgIH0pO1xuXG4gICAgLy8gR2V0IHRoZSBjZW50ZXIgb2YgdGhlIGNsaWNrZWQgaW5zdGFuY2VcbiAgICBtZXNoUmVmLmN1cnJlbnQuZ2V0TWF0cml4QXQoaW5kZXgsIHRlbXBNYXRyaXgpO1xuICAgIGNvbnN0IGluc3RhbmNlQ2VudGVyID0gdGVtcFZlYy5zZXRGcm9tTWF0cml4UG9zaXRpb24odGVtcE1hdHJpeCk7XG5cbiAgICAvLyBDYWxjdWxhdGUgZGlzdGFuY2UgZnJvbSBjbGljayBwb2ludCB0byBpbnN0YW5jZSBjZW50ZXJcbiAgICBjb25zdCBkaXN0RnJvbUNlbnRlciA9IGV2ZW50LnBvaW50LmRpc3RhbmNlVG8oaW5zdGFuY2VDZW50ZXIpO1xuXG4gICAgLy8gR2V0IHRoZSBDVVJSRU5UIHdvcmxkLXNwYWNlIGlubmVyIHJhZGl1c1xuICAgIGNvbnN0IGN1cnJlbnRJbm5lclJhZGl1cyA9IEJBU0VfUkFESVVTX0IgKiBjb250cm9scy52aXN1YWxTY2FsZTsgXG5cbiAgICBjb25zb2xlLmxvZygnQ2xpY2sgZGV0YWlsczonLCB7XG4gICAgICBkaXN0RnJvbUNlbnRlcixcbiAgICAgIGN1cnJlbnRJbm5lclJhZGl1cyxcbiAgICAgIGlzSW5zaWRlOiBkaXN0RnJvbUNlbnRlciA8PSBjdXJyZW50SW5uZXJSYWRpdXNcbiAgICB9KTtcblxuICAgIC8vIENoZWNrIGlmIGNsaWNrIGlzIGluc2lkZSB0aGUgaW5uZXIgY2lyY2xlXG4gICAgaWYgKGRpc3RGcm9tQ2VudGVyIDw9IGN1cnJlbnRJbm5lclJhZGl1cykge1xuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIGNtZC9jdHJsIGNsaWNrXG4gICAgICBpZiAoZXZlbnQubWV0YUtleSB8fCBldmVudC5jdHJsS2V5KSB7XG4gICAgICAgIC8vIENoZWNrIGNvbmRpdGlvbnMgZm9yIGhvcml6b250YWwgY29ubmVjdG9yXG4gICAgICAgIGNvbnN0IHJpZ2h0SW5kZXggPSBnZXRJbmRleCh5LCB4ICsgMSwgY29udHJvbHMuR1JJRF9XSURUSCk7XG4gICAgICAgIGNvbnN0IGNhbkNvbm5lY3RCYXNlID0geCA8IGNvbnRyb2xzLkdSSURfV0lEVEggLSAxICYmIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2YXRpb25TdGF0ZVtpbmRleF0gPT09IDEuMCAmJiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmF0aW9uU3RhdGVbcmlnaHRJbmRleF0gPT09IDEuMDtcblxuICAgICAgICAvLyAtLS0gTkVXOiBDaGVjayBmb3IgYmxvY2tpbmcgZGlhZ29uYWwgY29ubmVjdG9ycyAtLS1cbiAgICAgICAgY29uc3QgY29ubmVjdG9yQmVsb3cgPSBnZXRJbnRlbmRlZENvbm5lY3Rvcih4LCB5IC0gMSk7XG4gICAgICAgIGNvbnN0IGNvbm5lY3RvckFkamFjZW50ID0gZ2V0SW50ZW5kZWRDb25uZWN0b3IoeCwgeSk7XG4gICAgICAgIGNvbnN0IGlzQmxvY2tlZEJ5RGlhZ29uYWwgPSBcbiAgICAgICAgICAoY29ubmVjdG9yQmVsb3cgPT09IENPTk5FQ1RPUl9ESUFHX1RMX0JSIHx8IGNvbm5lY3RvckJlbG93ID09PSBDT05ORUNUT1JfRElBR19CTF9UUikgfHxcbiAgICAgICAgICAoY29ubmVjdG9yQWRqYWNlbnQgPT09IENPTk5FQ1RPUl9ESUFHX1RMX0JSIHx8IGNvbm5lY3RvckFkamFjZW50ID09PSBDT05ORUNUT1JfRElBR19CTF9UUik7XG4gICAgICAgIC8vIC0tLSBFbmQgTkVXIGNoZWNrIC0tLVxuXG4gICAgICAgIGNvbnNvbGUubG9nKCdQcm9jZXNzaW5nIGNtZC1jbGljayBvbiBjaXJjbGU6Jywge1xuICAgICAgICAgIHgsIHksXG4gICAgICAgICAgcmlnaHRJbmRleCxcbiAgICAgICAgICBsZWZ0QWN0aXZlOiBhY3RpdmF0aW9uU3RhdGVbaW5kZXhdID09PSAxLjAsXG4gICAgICAgICAgcmlnaHRBY3RpdmU6IHggPCBjb250cm9scy5HUklEX1dJRFRIIC0gMSA/IGFjdGl2YXRpb25TdGF0ZVtyaWdodEluZGV4XSA9PT0gMS4wIDogZmFsc2UsXG4gICAgICAgICAgY2FuQ29ubmVjdEJhc2UsXG4gICAgICAgICAgaXNCbG9ja2VkQnlEaWFnb25hbCwgLy8gTG9nIHRoZSBibG9ja2luZyBzdGF0dXNcbiAgICAgICAgICBjb25uZWN0b3JCZWxvdyxcbiAgICAgICAgICBjb25uZWN0b3JBZGphY2VudFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBPbmx5IGFsbG93IHRvZ2dsZSBpZiBiYXNlIGNvbmRpdGlvbnMgbWV0IEFORCBub3QgYmxvY2tlZCBieSBkaWFnb25hbFxuICAgICAgICBpZiAoY2FuQ29ubmVjdEJhc2UgJiYgIWlzQmxvY2tlZEJ5RGlhZ29uYWwpIHsgXG4gICAgICAgICAgY29uc3QgY29ubmVjdG9yS2V5ID0gZ2V0SG9yaXpDbWRDb25uZWN0b3JLZXkoeCwgeSk7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1RvZ2dsaW5nIGhvcml6b250YWwgY29ubmVjdG9yIChhbGxvd2VkKTonLCB7IGtleTogY29ubmVjdG9yS2V5IH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIHNldENtZEhvcml6Q29ubmVjdG9ycyhwcmV2ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gcHJldltjb25uZWN0b3JLZXldID8gMCA6IDE7XG4gICAgICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IHsgLi4ucHJldiwgW2Nvbm5lY3RvcktleV06IG5ld1ZhbHVlIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcmVmIHRvIHRyYWNrIHRoZSBsYXRlc3Qgc3RhdGVcbiAgICAgICAgICAgIGNtZEhvcml6Q29ubmVjdG9yc1JlZi5jdXJyZW50ID0gbmV3U3RhdGU7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdVcGRhdGVkIGNtZC1ob3JpeiBjb25uZWN0b3Igc3RhdGU6JywgeyBcbiAgICAgICAgICAgICAga2V5OiBjb25uZWN0b3JLZXksIFxuICAgICAgICAgICAgICBuZXdWYWx1ZSwgXG4gICAgICAgICAgICAgIGFsbENvbm5lY3RvcnM6IG5ld1N0YXRlLFxuICAgICAgICAgICAgICBrZXlzOiBPYmplY3Qua2V5cyhuZXdTdGF0ZSksXG4gICAgICAgICAgICAgIGFjdGl2ZUNvbm5lY3RvcnM6IE9iamVjdC5lbnRyaWVzKG5ld1N0YXRlKS5maWx0ZXIoKFtfLCB2XSkgPT4gdiA9PT0gMSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIHJldHVybjsgLy8gRXhpdCBhZnRlciBoYW5kbGluZyBjbWQtY2xpY2tcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgY29uc29sZS5sb2coJ0NtZC1jbGljayBob3Jpem9udGFsIGNvbm5lY3RvciBibG9ja2VkIG9yIGJhc2UgY29uZGl0aW9ucyBub3QgbWV0LicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGJsb2NrZWQgb3IgY2FuJ3QgY29ubmVjdCwgZmFsbCB0aHJvdWdoIHRvIHJlZ3VsYXIgY2xpY2s/IFxuICAgICAgICAvLyBPciBtYXliZSBkbyBub3RoaW5nIG9uIGNtZC1jbGljayBpZiBibG9ja2VkPyBMZXQncyBkbyBub3RoaW5nIGZvciBub3cuXG4gICAgICAgIHJldHVybjsgLy8gRXhwbGljaXRseSBkbyBub3RoaW5nIG1vcmUgaWYgY21kLWNsaWNrIHdhcyBibG9ja2VkIG9yIGludmFsaWRcbiAgICAgIH1cblxuICAgICAgLy8gUmVndWxhciBjbGljayBiZWhhdmlvciAodG9nZ2xlIGFjdGl2YXRpb24pIC0gb25seSBydW5zIGlmIG5vdCBhIGhhbmRsZWQgY21kLWNsaWNrXG4gICAgICBjb25zb2xlLmxvZygnVG9nZ2xpbmcgY2lyY2xlIGFjdGl2YXRpb24gKHJlZ3VsYXIgY2xpY2spJyk7XG4gICAgICBzZXRBY3RpdmF0aW9uU3RhdGUoY3VycmVudCA9PiB7XG4gICAgICAgIGNvbnN0IG5ld1N0YXRlID0gbmV3IEZsb2F0MzJBcnJheShjdXJyZW50KTtcbiAgICAgICAgbmV3U3RhdGVbaW5kZXhdID0gbmV3U3RhdGVbaW5kZXhdID09PSAxLjAgPyAwLjAgOiAxLjA7XG4gICAgICAgIGNvbnNvbGUubG9nKCdOZXcgYWN0aXZhdGlvbiBzdGF0ZSBmb3IgY2lyY2xlOicsIHtcbiAgICAgICAgICBpbmRleCxcbiAgICAgICAgICBvbGRWYWx1ZTogY3VycmVudFtpbmRleF0sXG4gICAgICAgICAgbmV3VmFsdWU6IG5ld1N0YXRlW2luZGV4XVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCBbbWVzaFJlZiwgc2V0QWN0aXZhdGlvblN0YXRlLCBjb250cm9scy5HUklEX1dJRFRILCBjb250cm9scy52aXN1YWxTY2FsZSwgc2V0Q21kSG9yaXpDb25uZWN0b3JzLCBjbWRIb3JpekNvbm5lY3RvcnMsIGludGVuZGVkQ29ubmVjdG9ycywgY29udHJvbHMuR1JJRF9IRUlHSFRdKTsgLy8gRGVwZW5kZW5jaWVzIGFyZSBjb3JyZWN0IG5vd1xuXG4gIC8vID09PSBGZWF0dXJlIDU6IFN0YXRlIERhdGEgVGV4dHVyZSA9PT1cbiAgY29uc3Qgc3RhdGVUZXh0dXJlID0gdXNlTWVtbygoKSA9PiB7XG4gICAgY29uc29sZS5sb2coYENyZWF0aW5nIHN0YXRlIHRleHR1cmU6ICR7Y29udHJvbHMuR1JJRF9XSURUSH14JHtjb250cm9scy5HUklEX0hFSUdIVH1gKTtcbiAgICBjb25zdCB0ZXh0dXJlID0gbmV3IFRIUkVFLkRhdGFUZXh0dXJlKFxuICAgICAgbmV3IEZsb2F0MzJBcnJheShUT1RBTF9DSVJDTEVTKS5maWxsKDAuMCksIC8vIEluaXRpYWwgZGF0YSBidWZmZXJcbiAgICAgIGNvbnRyb2xzLkdSSURfV0lEVEgsXG4gICAgICBjb250cm9scy5HUklEX0hFSUdIVCxcbiAgICAgIFRIUkVFLlJlZEZvcm1hdCwgLy8gU3RvcmUgYWN0aXZhdGlvbiAoMC4wIG9yIDEuMCkgaW4gUmVkIGNoYW5uZWxcbiAgICAgIFRIUkVFLkZsb2F0VHlwZVxuICAgICk7XG4gICAgdGV4dHVyZS5taW5GaWx0ZXIgPSBUSFJFRS5OZWFyZXN0RmlsdGVyOyAvLyBDcnVjaWFsOiBObyBpbnRlcnBvbGF0aW9uXG4gICAgdGV4dHVyZS5tYWdGaWx0ZXIgPSBUSFJFRS5OZWFyZXN0RmlsdGVyO1xuICAgIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlOyAvLyBJbml0aWFsIHVwZGF0ZSBuZWVkZWRcbiAgICByZXR1cm4gdGV4dHVyZTtcbiAgfSwgW2NvbnRyb2xzLkdSSURfV0lEVEgsIGNvbnRyb2xzLkdSSURfSEVJR0hULCBUT1RBTF9DSVJDTEVTXSk7IC8vIFJlY3JlYXRlIHRleHR1cmUgaWYgZ3JpZCBkaW1lbnNpb25zIGNoYW5nZVxuXG4gIC8vIFVwZGF0ZSB0ZXh0dXJlIGRhdGEgd2hlbiBhY3RpdmF0aW9uU3RhdGUgY2hhbmdlc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChzdGF0ZVRleHR1cmUgJiYgYWN0aXZhdGlvblN0YXRlLmxlbmd0aCA9PT0gc3RhdGVUZXh0dXJlLmltYWdlLmRhdGEubGVuZ3RoKSB7XG4gICAgICBzdGF0ZVRleHR1cmUuaW1hZ2UuZGF0YS5zZXQoYWN0aXZhdGlvblN0YXRlKTsgLy8gVXBkYXRlIHRleHR1cmUgZGF0YSBkaXJlY3RseVxuICAgICAgc3RhdGVUZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTsgLy8gTWFyayBmb3IgR1BVIHVwbG9hZFxuICAgICAgY29uc29sZS5sb2coJ1VwZGF0ZWQgc3RhdGUgdGV4dHVyZSBkYXRhLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1NraXBwaW5nIHRleHR1cmUgdXBkYXRlOiBNaXNtYXRjaCBiZXR3ZWVuIHN0YXRlIGFycmF5IGFuZCB0ZXh0dXJlIHNpemUgb3IgdGV4dHVyZSBub3QgcmVhZHkuJyk7XG4gICAgfVxuICB9LCBbYWN0aXZhdGlvblN0YXRlLCBzdGF0ZVRleHR1cmVdKTsgLy8gRGVwZW5kIG9uIGFjdGl2YXRpb24gc3RhdGUgYW5kIHRoZSB0ZXh0dXJlIGl0c2VsZlxuXG4gIC8vID09PSBGZWF0dXJlIDg6IENvbm5lY3RvciBQbGFuZSBJbnRlcmFjdGlvbiAoTW92ZWQgRE9XTiwgdXNlcyBoZWxwZXJzIGRlZmluZWQgYWJvdmUpID09PVxuICBjb25zdCBoYW5kbGVDb25uZWN0b3JDbGljayA9IHVzZUNhbGxiYWNrKChldmVudDogYW55KSA9PiB7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgY29uc29sZS5sb2coJ0Nvbm5lY3RvciBwbGFuZSBjbGlja2VkOicsIHtcbiAgICAgIHBvaW50OiBldmVudC5wb2ludCxcbiAgICAgIGlzQ21kQ2xpY2s6IGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuY3RybEtleVxuICAgIH0pO1xuICAgIFxuICAgIC8vIEdldCB0aGUgY2xpY2sgcG9pbnQgaW4gd29ybGQgc3BhY2VcbiAgICBjb25zdCBjbGlja1BvaW50ID0gZXZlbnQucG9pbnQ7XG4gICAgXG4gICAgLy8gRmlyc3QsIGNoZWNrIGlmIHRoZSBjbGljayBpcyBvbiBhIGNpcmNsZVxuICAgIC8vIERldGVybWluZSB3aGljaCBncmlkIGNlbGwgdGhpcyBwb2ludCBpcyBjbG9zZXN0IHRvXG4gICAgY29uc3QgZ3JpZFggPSBNYXRoLnJvdW5kKChjbGlja1BvaW50LnggLSBjZW50ZXJPZmZzZXQueCkgLyBGSVhFRF9TUEFDSU5HKTtcbiAgICBjb25zdCBncmlkWSA9IE1hdGgucm91bmQoKGNsaWNrUG9pbnQueSAtIGNlbnRlck9mZnNldC55KSAvIEZJWEVEX1NQQUNJTkcpO1xuICAgIFxuICAgIC8vIENoZWNrIGlmIHRoaXMgY2VsbCBpcyB3aXRoaW4gZ3JpZCBib3VuZHNcbiAgICBpZiAoZ3JpZFggPj0gMCAmJiBncmlkWCA8IGNvbnRyb2xzLkdSSURfV0lEVEggJiYgZ3JpZFkgPj0gMCAmJiBncmlkWSA8IGNvbnRyb2xzLkdSSURfSEVJR0hUKSB7XG4gICAgICAvLyBDYWxjdWxhdGUgdGhlIGNlbGwgY2VudGVyIGluIHdvcmxkIHNwYWNlXG4gICAgICBjb25zdCBjZWxsQ2VudGVyID0gZ2V0V29ybGRQb3NpdGlvbihncmlkWSwgZ3JpZFgsIGNvbnRyb2xzLkdSSURfV0lEVEgsIGNvbnRyb2xzLkdSSURfSEVJR0hULCBGSVhFRF9TUEFDSU5HLCBjZW50ZXJPZmZzZXQpO1xuICAgICAgXG4gICAgICAvLyBDYWxjdWxhdGUgZGlzdGFuY2UgZnJvbSBjbGljayB0byBjZWxsIGNlbnRlclxuICAgICAgY29uc3QgZGlzdEZyb21DZW50ZXIgPSBNYXRoLnNxcnQoXG4gICAgICAgIE1hdGgucG93KGNsaWNrUG9pbnQueCAtIGNlbGxDZW50ZXIueCwgMikgKyBcbiAgICAgICAgTWF0aC5wb3coY2xpY2tQb2ludC55IC0gY2VsbENlbnRlci55LCAyKVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgY2xpY2sgaXMgaW5zaWRlIHRoZSBpbm5lciBjaXJjbGVcbiAgICAgIGNvbnN0IGN1cnJlbnRJbm5lclJhZGl1cyA9IEJBU0VfUkFESVVTX0IgKiBjb250cm9scy52aXN1YWxTY2FsZTtcbiAgICAgIGlmIChkaXN0RnJvbUNlbnRlciA8PSBjdXJyZW50SW5uZXJSYWRpdXMpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIGNsaWNrIG9uIGEgY2lyY2xlIC0gdG9nZ2xlIGl0cyBhY3RpdmF0aW9uIHN0YXRlXG4gICAgICAgIGNvbnN0IGluZGV4ID0gZ2V0SW5kZXgoZ3JpZFksIGdyaWRYLCBjb250cm9scy5HUklEX1dJRFRIKTtcblxuICAgICAgICAvLyBJZiB0aGlzIGlzIGEgY21kL2N0cmwgY2xpY2sgYW5kIHRoZXJlJ3MgYW4gYWN0aXZlIGNpcmNsZSB0byB0aGUgcmlnaHRcbiAgICAgICAgaWYgKChldmVudC5tZXRhS2V5IHx8IGV2ZW50LmN0cmxLZXkpICYmIGdyaWRYIDwgY29udHJvbHMuR1JJRF9XSURUSCAtIDEpIHtcbiAgICAgICAgICBjb25zdCByaWdodEluZGV4ID0gZ2V0SW5kZXgoZ3JpZFksIGdyaWRYICsgMSwgY29udHJvbHMuR1JJRF9XSURUSCk7XG4gICAgICAgICAgY29uc3QgbGVmdEFjdGl2ZSA9IGFjdGl2YXRpb25TdGF0ZVtpbmRleF0gPT09IDEuMDtcbiAgICAgICAgICBjb25zdCByaWdodEFjdGl2ZSA9IGFjdGl2YXRpb25TdGF0ZVtyaWdodEluZGV4XSA9PT0gMS4wO1xuICAgICAgICAgIGNvbnN0IGNhbkNvbm5lY3RCYXNlID0gbGVmdEFjdGl2ZSAmJiByaWdodEFjdGl2ZTtcblxuICAgICAgICAgIC8vIC0tLSBORVc6IENoZWNrIGZvciBibG9ja2luZyBkaWFnb25hbCBjb25uZWN0b3JzIC0tLVxuICAgICAgICAgIGNvbnN0IGNvbm5lY3RvckJlbG93ID0gZ2V0SW50ZW5kZWRDb25uZWN0b3IoZ3JpZFgsIGdyaWRZIC0gMSk7XG4gICAgICAgICAgY29uc3QgY29ubmVjdG9yQWRqYWNlbnQgPSBnZXRJbnRlbmRlZENvbm5lY3RvcihncmlkWCwgZ3JpZFkpO1xuICAgICAgICAgIGNvbnN0IGlzQmxvY2tlZEJ5RGlhZ29uYWwgPSBcbiAgICAgICAgICAgIChjb25uZWN0b3JCZWxvdyA9PT0gQ09OTkVDVE9SX0RJQUdfVExfQlIgfHwgY29ubmVjdG9yQmVsb3cgPT09IENPTk5FQ1RPUl9ESUFHX0JMX1RSKSB8fFxuICAgICAgICAgICAgKGNvbm5lY3RvckFkamFjZW50ID09PSBDT05ORUNUT1JfRElBR19UTF9CUiB8fCBjb25uZWN0b3JBZGphY2VudCA9PT0gQ09OTkVDVE9SX0RJQUdfQkxfVFIpO1xuICAgICAgICAgIC8vIC0tLSBFbmQgTkVXIGNoZWNrIC0tLVxuXG4gICAgICAgICAgY29uc29sZS5sb2coJ1Byb2Nlc3NpbmcgY21kLWNsaWNrICh2aWEgcGxhbmUgb24gY2lyY2xlKTonLCB7XG4gICAgICAgICAgICB4OiBncmlkWCwgeTogZ3JpZFksXG4gICAgICAgICAgICBsZWZ0QWN0aXZlLCByaWdodEFjdGl2ZSxcbiAgICAgICAgICAgIGNhbkNvbm5lY3RCYXNlLCBpc0Jsb2NrZWRCeURpYWdvbmFsLFxuICAgICAgICAgICAgY29ubmVjdG9yQmVsb3csIGNvbm5lY3RvckFkamFjZW50XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBPbmx5IGFsbG93IHRvZ2dsZSBpZiBiYXNlIGNvbmRpdGlvbnMgbWV0IEFORCBub3QgYmxvY2tlZCBieSBkaWFnb25hbFxuICAgICAgICAgIGlmIChjYW5Db25uZWN0QmFzZSAmJiAhaXNCbG9ja2VkQnlEaWFnb25hbCkge1xuICAgICAgICAgICAgY29uc3QgY29ubmVjdG9yS2V5ID0gZ2V0SG9yaXpDbWRDb25uZWN0b3JLZXkoZ3JpZFgsIGdyaWRZKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdUb2dnbGluZyBjbWQtaG9yaXogY29ubmVjdG9yIChhbGxvd2VkKTonLCB7IGtleTogY29ubmVjdG9yS2V5IH0pO1xuICAgICAgICAgICAgc2V0Q21kSG9yaXpDb25uZWN0b3JzKHByZXYgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBuZXdDb25uZWN0b3JzID0geyAuLi5wcmV2IH07XG4gICAgICAgICAgICAgIG5ld0Nvbm5lY3RvcnNbY29ubmVjdG9yS2V5XSA9IHByZXZbY29ubmVjdG9yS2V5XSA/IDAgOiAxO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSByZWYgdG8gdHJhY2sgdGhlIGxhdGVzdCBzdGF0ZVxuICAgICAgICAgICAgICBjbWRIb3JpekNvbm5lY3RvcnNSZWYuY3VycmVudCA9IG5ld0Nvbm5lY3RvcnM7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVXBkYXRlZCBjbWQtaG9yaXogY29ubmVjdG9yIHN0YXRlICh2aWEgcGxhbmUpOicsIHsgXG4gICAgICAgICAgICAgICAga2V5OiBjb25uZWN0b3JLZXksIFxuICAgICAgICAgICAgICAgIG5ld1ZhbHVlOiBuZXdDb25uZWN0b3JzW2Nvbm5lY3RvcktleV0sIFxuICAgICAgICAgICAgICAgIGFsbENvbm5lY3RvcnM6IG5ld0Nvbm5lY3RvcnMsXG4gICAgICAgICAgICAgICAga2V5czogT2JqZWN0LmtleXMobmV3Q29ubmVjdG9ycyksXG4gICAgICAgICAgICAgICAgYWN0aXZlQ29ubmVjdG9yczogT2JqZWN0LmVudHJpZXMobmV3Q29ubmVjdG9ycykuZmlsdGVyKChbXywgdl0pID0+IHYgPT09IDEpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXR1cm4gbmV3Q29ubmVjdG9ycztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBFeGl0IGFmdGVyIGhhbmRsaW5nIGNtZC1jbGlja1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgY29uc29sZS5sb2coJ0NtZC1jbGljayBob3Jpem9udGFsIGNvbm5lY3RvciBibG9ja2VkIG9yIGJhc2UgY29uZGl0aW9ucyBub3QgbWV0LicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBJZiBibG9ja2VkIG9yIGNhbid0IGNvbm5lY3QsIGZhbGwgdGhyb3VnaCB0byByZWd1bGFyIGNsaWNrPyBMZXQncyBkbyBub3RoaW5nIG1vcmUuXG4gICAgICAgICAgcmV0dXJuOyAvLyBFeHBsaWNpdGx5IGRvIG5vdGhpbmcgbW9yZSBpZiBjbWQtY2xpY2sgd2FzIGJsb2NrZWQgb3IgaW52YWxpZFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVndWxhciBjbGljayBiZWhhdmlvciAodG9nZ2xlIGFjdGl2YXRpb24pIC0gb25seSBydW5zIGlmIG5vdCBhIGhhbmRsZWQgY21kLWNsaWNrXG4gICAgICAgIGNvbnNvbGUubG9nKCdUb2dnbGluZyBjaXJjbGUgYWN0aXZhdGlvbiAocmVndWxhciBjbGljayBvbiBwbGFuZSknKTtcbiAgICAgICAgc2V0QWN0aXZhdGlvblN0YXRlKGN1cnJlbnQgPT4ge1xuICAgICAgICAgIGNvbnN0IG5ld1N0YXRlID0gbmV3IEZsb2F0MzJBcnJheShjdXJyZW50KTtcbiAgICAgICAgICBuZXdTdGF0ZVtpbmRleF0gPSBuZXdTdGF0ZVtpbmRleF0gPT09IDEuMCA/IDAuMCA6IDEuMDtcbiAgICAgICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zb2xlLmxvZyhgVG9nZ2xpbmcgY2lyY2xlIGF0ICgke2dyaWRYfSwke2dyaWRZfSlgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBJZiB3ZSBnZXQgaGVyZSwgdGhlIGNsaWNrIHdhc24ndCBvbiBhIGNpcmNsZSwgc28gdHJlYXQgaXQgYXMgYSBjb25uZWN0b3IgY2xpY2tcbiAgICAvLyBEZXRlcm1pbmUgd2hpY2ggZ3JpZCBjZWxsIChib3R0b20tbGVmdCBvZiBhIDJ4MiBncm91cCkgdGhpcyBwb2ludCBpcyBjbG9zZXN0IHRvXG4gICAgY29uc3QgZ3JvdXBYID0gTWF0aC5mbG9vcigoY2xpY2tQb2ludC54IC0gY2VudGVyT2Zmc2V0LngpIC8gRklYRURfU1BBQ0lORyk7XG4gICAgY29uc3QgZ3JvdXBZID0gTWF0aC5mbG9vcigoY2xpY2tQb2ludC55IC0gY2VudGVyT2Zmc2V0LnkpIC8gRklYRURfU1BBQ0lORyk7XG4gICAgXG4gICAgLy8gR2V0IHRoZSBpbmRpY2VzIG9mIHRoZSBmb3VyIGNlbGxzIGluIHRoZSAyeDIgZ3JvdXBcbiAgICBjb25zdCBibEluZGV4ID0gZ2V0SW5kZXgoZ3JvdXBZLCBncm91cFgsIGNvbnRyb2xzLkdSSURfV0lEVEgpO1xuICAgIGNvbnN0IGJySW5kZXggPSBnZXRJbmRleChncm91cFksIGdyb3VwWCArIDEsIGNvbnRyb2xzLkdSSURfV0lEVEgpO1xuICAgIGNvbnN0IHRsSW5kZXggPSBnZXRJbmRleChncm91cFkgKyAxLCBncm91cFgsIGNvbnRyb2xzLkdSSURfV0lEVEgpO1xuICAgIGNvbnN0IHRySW5kZXggPSBnZXRJbmRleChncm91cFkgKyAxLCBncm91cFggKyAxLCBjb250cm9scy5HUklEX1dJRFRIKTtcbiAgICBcbiAgICAvLyBDaGVjayB3aGljaCBjZWxscyBhcmUgd2l0aGluIGdyaWQgYm91bmRzXG4gICAgY29uc3QgaXNWYWxpZEdyb3VwID0gXG4gICAgICBncm91cFggPj0gMCAmJiBncm91cFggPCBjb250cm9scy5HUklEX1dJRFRIIC0gMSAmJiBcbiAgICAgIGdyb3VwWSA+PSAwICYmIGdyb3VwWSA8IGNvbnRyb2xzLkdSSURfSEVJR0hUIC0gMTtcbiAgICBcbiAgICBpZiAoIWlzVmFsaWRHcm91cCkgcmV0dXJuO1xuICAgIFxuICAgIC8vIEdldCBhY3RpdmF0aW9uIHN0YXRlcyBmb3IgdGhlIGZvdXIgY2VsbHNcbiAgICBjb25zdCBibEFjdGl2ZSA9IGFjdGl2YXRpb25TdGF0ZVtibEluZGV4XSA9PT0gMS4wO1xuICAgIGNvbnN0IGJyQWN0aXZlID0gYWN0aXZhdGlvblN0YXRlW2JySW5kZXhdID09PSAxLjA7XG4gICAgY29uc3QgdGxBY3RpdmUgPSBhY3RpdmF0aW9uU3RhdGVbdGxJbmRleF0gPT09IDEuMDtcbiAgICBjb25zdCB0ckFjdGl2ZSA9IGFjdGl2YXRpb25TdGF0ZVt0ckluZGV4XSA9PT0gMS4wO1xuICAgIFxuICAgIC8vIEdldCB0aGUgd29ybGQgcG9zaXRpb25zIG9mIHRoZSBjZWxsIGNlbnRlcnNcbiAgICBjb25zdCBibFBvcyA9IGdldFdvcmxkUG9zaXRpb24oZ3JvdXBZLCBncm91cFgsIGNvbnRyb2xzLkdSSURfV0lEVEgsIGNvbnRyb2xzLkdSSURfSEVJR0hULCBGSVhFRF9TUEFDSU5HLCBjZW50ZXJPZmZzZXQpO1xuICAgIGNvbnN0IGJyUG9zID0gZ2V0V29ybGRQb3NpdGlvbihncm91cFksIGdyb3VwWCArIDEsIGNvbnRyb2xzLkdSSURfV0lEVEgsIGNvbnRyb2xzLkdSSURfSEVJR0hULCBGSVhFRF9TUEFDSU5HLCBjZW50ZXJPZmZzZXQpO1xuICAgIGNvbnN0IHRsUG9zID0gZ2V0V29ybGRQb3NpdGlvbihncm91cFkgKyAxLCBncm91cFgsIGNvbnRyb2xzLkdSSURfV0lEVEgsIGNvbnRyb2xzLkdSSURfSEVJR0hULCBGSVhFRF9TUEFDSU5HLCBjZW50ZXJPZmZzZXQpO1xuICAgIGNvbnN0IHRyUG9zID0gZ2V0V29ybGRQb3NpdGlvbihncm91cFkgKyAxLCBncm91cFggKyAxLCBjb250cm9scy5HUklEX1dJRFRILCBjb250cm9scy5HUklEX0hFSUdIVCwgRklYRURfU1BBQ0lORywgY2VudGVyT2Zmc2V0KTtcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgdGhlIGNlbnRlciBvZiB0aGUgMngyIGdyb3VwXG4gICAgY29uc3QgY2VudGVyWCA9IChibFBvcy54ICsgYnJQb3MueCArIHRsUG9zLnggKyB0clBvcy54KSAvIDQ7XG4gICAgY29uc3QgY2VudGVyWSA9IChibFBvcy55ICsgYnJQb3MueSArIHRsUG9zLnkgKyB0clBvcy55KSAvIDQ7XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIGRpc3RhbmNlIGZyb20gY2xpY2sgdG8gY2VudGVyIG9mIDJ4MiBncm91cFxuICAgIGNvbnN0IGRpc3RUb0NlbnRlciA9IE1hdGguc3FydChcbiAgICAgIE1hdGgucG93KGNsaWNrUG9pbnQueCAtIGNlbnRlclgsIDIpICsgXG4gICAgICBNYXRoLnBvdyhjbGlja1BvaW50LnkgLSBjZW50ZXJZLCAyKVxuICAgICk7XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgdGhlIGNsaWNrIGlzIGluIHRoZSBjZW50ZXIgem9uZSAoMzAlIG9mIGNlbGwgc3BhY2luZylcbiAgICBjb25zdCBpc0NlbnRlckNsaWNrID0gZGlzdFRvQ2VudGVyIDwgRklYRURfU1BBQ0lORyAqIDAuMyAqIGNvbnRyb2xzLnZpc3VhbFNjYWxlO1xuICAgIFxuICAgIC8vIEdldCB0aGUgcG9zc2libGUgZGlhZ29uYWwgY29ubmVjdG9yc1xuICAgIGNvbnN0IGNhblVzZURpYWdUTEJSID0gdGxBY3RpdmUgJiYgYnJBY3RpdmU7XG4gICAgY29uc3QgY2FuVXNlRGlhZ0JMVFIgPSBibEFjdGl2ZSAmJiB0ckFjdGl2ZTtcbiAgICBjb25zdCBoYXNEaWFnb25hbE9wdGlvbnMgPSBjYW5Vc2VEaWFnVExCUiB8fCBjYW5Vc2VEaWFnQkxUUjtcbiAgICBcbiAgICAvLyBHZXQgY3VycmVudCBpbnRlbmRlZCBjb25uZWN0b3JcbiAgICBjb25zdCBjdXJyZW50Q29ubmVjdG9yID0gZ2V0SW50ZW5kZWRDb25uZWN0b3IoZ3JvdXBYLCBncm91cFkpO1xuICAgIGNvbnN0IGdyb3VwS2V5ID0gZ2V0Q2VsbEdyb3VwS2V5KGdyb3VwWCwgZ3JvdXBZKTtcbiAgICBcbiAgICAvLyAtLS0gTkVXOiBDaGVjayBmb3IgYmxvY2tpbmcgaG9yaXpvbnRhbCBjb25uZWN0b3JzIC0tLVxuICAgIGNvbnN0IGhhc0hvcml6Q21kQmVsb3cgPSBjbWRIb3JpekNvbm5lY3RvcnNbZ2V0SG9yaXpDbWRDb25uZWN0b3JLZXkoZ3JvdXBYLCBncm91cFkpXSA9PT0gMTtcbiAgICBjb25zdCBoYXNIb3JpekNtZEFib3ZlID0gY21kSG9yaXpDb25uZWN0b3JzW2dldEhvcml6Q21kQ29ubmVjdG9yS2V5KGdyb3VwWCwgZ3JvdXBZICsgMSldID09PSAxO1xuICAgIGNvbnN0IGlzQmxvY2tlZEJ5SG9yaXogPSBoYXNIb3JpekNtZEJlbG93IHx8IGhhc0hvcml6Q21kQWJvdmU7XG4gICAgLy8gLS0tIEVuZCBORVcgQ2hlY2sgLS0tXG5cbiAgICBsZXQgbmV3Q29ubmVjdG9yID0gQ09OTkVDVE9SX05PTkU7IC8vIEluaXRpYWxpemUgcG90ZW50aWFsIG5ldyBzdGF0ZVxuICAgIGxldCBwb3RlbnRpYWxDb25uZWN0b3JUeXBlID0gQ09OTkVDVE9SX05PTkU7IC8vIFN0b3JlIHRoZSB0eXBlIGRldGVybWluZWQgYnkgY2xpY2sgbG9naWNcbiAgICBcbiAgICAvLyBJZiBjbGlja2VkIGluIHRoZSBjZW50ZXIgYW5kIGRpYWdvbmFsIGNvbm5lY3RvcnMgYXJlIGF2YWlsYWJsZSwgY3ljbGUgdGhyb3VnaCB0aGVtXG4gICAgaWYgKGlzQ2VudGVyQ2xpY2sgJiYgaGFzRGlhZ29uYWxPcHRpb25zKSB7XG4gICAgICBpZiAoY2FuVXNlRGlhZ1RMQlIgJiYgY2FuVXNlRGlhZ0JMVFIpIHtcbiAgICAgICAgLy8gQm90aCBkaWFnb25hbHMgYXJlIGF2YWlsYWJsZSwgY3ljbGUgdGhyb3VnaCB0aGUgb3B0aW9uczogTk9ORSAtPiBUTC1CUiAtPiBCTC1UUiAtPiBOT05FXG4gICAgICAgIGlmIChjdXJyZW50Q29ubmVjdG9yID09PSBDT05ORUNUT1JfTk9ORSkge1xuICAgICAgICAgIHBvdGVudGlhbENvbm5lY3RvclR5cGUgPSBDT05ORUNUT1JfRElBR19UTF9CUjtcbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50Q29ubmVjdG9yID09PSBDT05ORUNUT1JfRElBR19UTF9CUikge1xuICAgICAgICAgIHBvdGVudGlhbENvbm5lY3RvclR5cGUgPSBDT05ORUNUT1JfRElBR19CTF9UUjtcbiAgICAgICAgfSBlbHNlIHsgLy8gY3VycmVudCB3YXMgQkxfVFJcbiAgICAgICAgICBwb3RlbnRpYWxDb25uZWN0b3JUeXBlID0gQ09OTkVDVE9SX05PTkU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2FuVXNlRGlhZ1RMQlIpIHtcbiAgICAgICAgLy8gT25seSBUTC1CUiBkaWFnb25hbCBpcyBhdmFpbGFibGUsIHRvZ2dsZSBpdFxuICAgICAgICBwb3RlbnRpYWxDb25uZWN0b3JUeXBlID0gY3VycmVudENvbm5lY3RvciA9PT0gQ09OTkVDVE9SX0RJQUdfVExfQlIgPyBDT05ORUNUT1JfTk9ORSA6IENPTk5FQ1RPUl9ESUFHX1RMX0JSO1xuICAgICAgfSBlbHNlIHsgLy8gT25seSBjYW5Vc2VEaWFnQkxUUlxuICAgICAgICAvLyBPbmx5IEJMLVRSIGRpYWdvbmFsIGlzIGF2YWlsYWJsZSwgdG9nZ2xlIGl0XG4gICAgICAgIHBvdGVudGlhbENvbm5lY3RvclR5cGUgPSBjdXJyZW50Q29ubmVjdG9yID09PSBDT05ORUNUT1JfRElBR19CTF9UUiA/IENPTk5FQ1RPUl9OT05FIDogQ09OTkVDVE9SX0RJQUdfQkxfVFI7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghaXNDZW50ZXJDbGljaykgeyAvLyBDaGVjayBub24tY2VudGVyIGNsaWNrcyBvbmx5IGlmIG5vdCBhIGNlbnRlciBjbGlja1xuICAgICAgLy8gRm9yIGNsaWNrcyBvdXRzaWRlIHRoZSBjZW50ZXIsIGRldGVybWluZSB3aGljaCBkaWFnb25hbCB3YXMgY2xpY2tlZCAoaWYgYW55KVxuICAgICAgbGV0IGNsaWNrZWRUeXBlID0gQ09OTkVDVE9SX05PTkU7XG4gICAgICBcbiAgICAgIC8vIENhbGN1bGF0ZSBkaXN0YW5jZXMgZnJvbSBjbGljayB0byBlYWNoIGRpYWdvbmFsXG4gICAgICBjb25zdCBkaXN0VG9CTFRSID0gTWF0aC5hYnMoKGNsaWNrUG9pbnQueCAtIGJsUG9zLngpICogKHRyUG9zLnkgLSBibFBvcy55KSAtIChjbGlja1BvaW50LnkgLSBibFBvcy55KSAqICh0clBvcy54IC0gYmxQb3MueCkpIC8gXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLnNxcnQoTWF0aC5wb3codHJQb3MueCAtIGJsUG9zLngsIDIpICsgTWF0aC5wb3codHJQb3MueSAtIGJsUG9zLnksIDIpKTtcbiAgICAgIGNvbnN0IGRpc3RUb1RMQlIgPSBNYXRoLmFicygoY2xpY2tQb2ludC54IC0gdGxQb3MueCkgKiAoYnJQb3MueSAtIHRsUG9zLnkpIC0gKGNsaWNrUG9pbnQueSAtIHRsUG9zLnkpICogKGJyUG9zLnggLSB0bFBvcy54KSkgLyBcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguc3FydChNYXRoLnBvdyhiclBvcy54IC0gdGxQb3MueCwgMikgKyBNYXRoLnBvdyhiclBvcy55IC0gdGxQb3MueSwgMikpO1xuICAgICAgICAgICAgXG4gICAgICBpZiAoZGlzdFRvQkxUUiA8IGRpc3RUb1RMQlIpIHtcbiAgICAgICAgLy8gQ2xvc2VyIHRvIEJMLVRSIGRpYWdvbmFsICgvKVxuICAgICAgICBpZiAoY2FuVXNlRGlhZ0JMVFIpIHsgLy8gQ2hlY2sgaWYgcG9zc2libGVcbiAgICAgICAgICBjbGlja2VkVHlwZSA9IENPTk5FQ1RPUl9ESUFHX0JMX1RSO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDbG9zZXIgdG8gVEwtQlIgZGlhZ29uYWwgKFxcKVxuICAgICAgICBpZiAoY2FuVXNlRGlhZ1RMQlIpIHsgLy8gQ2hlY2sgaWYgcG9zc2libGVcbiAgICAgICAgICBjbGlja2VkVHlwZSA9IENPTk5FQ1RPUl9ESUFHX1RMX0JSO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFRvZ2dsZSBsb2dpYyAtIGlmIHRoZSBjbGlja2VkIGNvbm5lY3RvciBpcyBhbHJlYWR5IGFjdGl2ZSwgdHVybiBpdCBvZmZcbiAgICAgIC8vIE90aGVyd2lzZSwgdHVybiBvbiB0aGUgY2xpY2tlZCBvbmVcbiAgICAgIGlmIChjdXJyZW50Q29ubmVjdG9yID09PSBjbGlja2VkVHlwZSkge1xuICAgICAgICBwb3RlbnRpYWxDb25uZWN0b3JUeXBlID0gQ09OTkVDVE9SX05PTkU7IC8vIFRvZ2dsZSBvZmZcbiAgICAgIH0gZWxzZSBpZiAoY2xpY2tlZFR5cGUgIT09IENPTk5FQ1RPUl9OT05FKSB7XG4gICAgICAgIHBvdGVudGlhbENvbm5lY3RvclR5cGUgPSBjbGlja2VkVHlwZTsgLy8gVG9nZ2xlIG9uIG5ldyBjb25uZWN0b3JcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAtLS0gQXBwbHkgQmxvY2tpbmcgTG9naWMgLS0tXG4gICAgaWYgKGlzQmxvY2tlZEJ5SG9yaXogJiYgKHBvdGVudGlhbENvbm5lY3RvclR5cGUgPT09IENPTk5FQ1RPUl9ESUFHX1RMX0JSIHx8IHBvdGVudGlhbENvbm5lY3RvclR5cGUgPT09IENPTk5FQ1RPUl9ESUFHX0JMX1RSKSkge1xuICAgICAgbmV3Q29ubmVjdG9yID0gQ09OTkVDVE9SX05PTkU7IC8vIEZvcmNlIHRvIE5PTkUgaWYgYmxvY2tlZCBieSBob3Jpem9udGFsXG4gICAgICBjb25zb2xlLmxvZyhgRGlhZ29uYWwgY29ubmVjdG9yIGJsb2NrZWQgYnkgZXhpc3RpbmcgaG9yaXpvbnRhbCBjb25uZWN0b3IgYXQgZ3JvdXAgKCR7Z3JvdXBYfSwke2dyb3VwWX0pYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0Nvbm5lY3RvciA9IHBvdGVudGlhbENvbm5lY3RvclR5cGU7IC8vIE90aGVyd2lzZSwgdXNlIHRoZSB0eXBlIGRldGVybWluZWQgYnkgY2xpY2sgbG9naWNcbiAgICB9XG4gICAgLy8gLS0tIEVuZCBCbG9ja2luZyBMb2dpYyAtLS1cbiAgICBcbiAgICAvLyBVcGRhdGUgdGhlIGludGVuZGVkIGNvbm5lY3RvciBzdGF0ZVxuICAgIHNldEludGVuZGVkQ29ubmVjdG9ycyhwcmV2ID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKGBDb25uZWN0b3IgdXBkYXRlIGF0ICgke2dyb3VwWH0sJHtncm91cFl9KTogcHJldmlvdXM9JHtwcmV2W2dyb3VwS2V5XX0gLT4gbmV3PSR7bmV3Q29ubmVjdG9yfWApO1xuICAgICAgY29uc3QgdXBkYXRlZCA9IHtcbiAgICAgICAgLi4ucHJldixcbiAgICAgICAgW2dyb3VwS2V5XTogbmV3Q29ubmVjdG9yXG4gICAgICB9O1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgdGhlIHJlZiB0byB0cmFjayB0aGUgbGF0ZXN0IHN0YXRlXG4gICAgICBpbnRlbmRlZENvbm5lY3RvcnNSZWYuY3VycmVudCA9IHVwZGF0ZWQ7XG4gICAgICBcbiAgICAgIC8vIExvZyB0aGUgY2hhbmdlIHRoYXQgd2FzIG1hZGVcbiAgICAgIGlmIChwcmV2W2dyb3VwS2V5XSAhPT0gbmV3Q29ubmVjdG9yKSB7XG4gICAgICAgIGlmIChuZXdDb25uZWN0b3IgPT09IENPTk5FQ1RPUl9OT05FKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYFJlbW92ZWQgY29ubmVjdG9yIGF0ICgke2dyb3VwWH0sJHtncm91cFl9KWApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHR5cGVTdHIgPSBcbiAgICAgICAgICAgIG5ld0Nvbm5lY3RvciA9PT0gQ09OTkVDVE9SX0RJQUdfVExfQlIgPyBcIkRJQUdfVExfQlIgKFxcXFwpXCIgOlxuICAgICAgICAgICAgbmV3Q29ubmVjdG9yID09PSBDT05ORUNUT1JfRElBR19CTF9UUiA/IFwiRElBR19CTF9UUiAoLylcIiA6XG4gICAgICAgICAgICBuZXdDb25uZWN0b3IgPT09IENPTk5FQ1RPUl9IT1JJWl9UID8gXCJIT1JJWl9UXCIgOlxuICAgICAgICAgICAgbmV3Q29ubmVjdG9yID09PSBDT05ORUNUT1JfSE9SSVpfQiA/IFwiSE9SSVpfQlwiIDpcbiAgICAgICAgICAgIGB1bmtub3duICgke25ld0Nvbm5lY3Rvcn0pYDtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgQWRkZWQgJHt0eXBlU3RyfSBjb25uZWN0b3IgYXQgKCR7Z3JvdXBYfSwke2dyb3VwWX0pYCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gTG9nIHVwZGF0ZWQgY29ubmVjdG9yIHN0YXRlIHRvIGhlbHAgd2l0aCBkZWJ1Z2dpbmdcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIk5ldyBjb25uZWN0b3Igc3RhdGU6XCIsIHVwZGF0ZWQpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiQ29ubmVjdG9yIGtleXM6XCIsIE9iamVjdC5rZXlzKHVwZGF0ZWQpKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIk5vbi16ZXJvIGNvbm5lY3RvcnM6XCIsIE9iamVjdC5lbnRyaWVzKHVwZGF0ZWQpLmZpbHRlcigoW18sIHZdKSA9PiB2ICE9PSBDT05ORUNUT1JfTk9ORSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiB1cGRhdGVkO1xuICAgIH0pO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKGBDbGlja2VkIGNlbGwgZ3JvdXAgKCR7Z3JvdXBYfSwke2dyb3VwWX0pLCBzZXR0aW5nIGNvbm5lY3RvciB0byAke25ld0Nvbm5lY3Rvcn1gKTtcbiAgICBcbiAgfSwgW2NvbnRyb2xzLkdSSURfV0lEVEgsIGNvbnRyb2xzLkdSSURfSEVJR0hULCBGSVhFRF9TUEFDSU5HLCBjZW50ZXJPZmZzZXQsIGFjdGl2YXRpb25TdGF0ZSwgaW50ZW5kZWRDb25uZWN0b3JzLCBjb250cm9scy52aXN1YWxTY2FsZSwgc2V0Q21kSG9yaXpDb25uZWN0b3JzLCBjbWRIb3JpekNvbm5lY3RvcnNdKTsgLy8gRGVwZW5kZW5jaWVzIGFyZSBjb3JyZWN0IG5vd1xuXG4gIC8vIFJlc2V0IGNvbm5lY3RvciBpbnRlbnQgd2hlbiBhIGNpcmNsZSBpcyBkZWFjdGl2YXRlZFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIENoZWNrIGFsbCBjZWxsIGdyb3Vwc1xuICAgIGNvbnN0IG5ld0ludGVuZGVkQ29ubmVjdG9ycyA9IHsgLi4uaW50ZW5kZWRDb25uZWN0b3JzIH07XG4gICAgY29uc3QgbmV3Q21kSG9yaXpDb25uZWN0b3JzID0geyAuLi5jbWRIb3JpekNvbm5lY3RvcnMgfTtcbiAgICBsZXQgaGFzQ2hhbmdlcyA9IGZhbHNlO1xuICAgIGxldCBoYXNDbWRIb3JpekNoYW5nZXMgPSBmYWxzZTtcbiAgICBcbiAgICAvLyBGaXJzdCBjaGVjayByZWd1bGFyIGNvbm5lY3RvcnNcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBpbnRlbmRlZENvbm5lY3RvcnMpIHtcbiAgICAgIGNvbnN0IGNvbm5lY3RvciA9IGludGVuZGVkQ29ubmVjdG9yc1trZXldO1xuICAgICAgaWYgKGNvbm5lY3RvciA9PT0gQ09OTkVDVE9SX05PTkUpIGNvbnRpbnVlO1xuICAgICAgXG4gICAgICAvLyBQYXJzZSB4LHkgZnJvbSBrZXlcbiAgICAgIGNvbnN0IFt4LCB5XSA9IGtleS5zcGxpdCgnLCcpLm1hcChOdW1iZXIpO1xuICAgICAgXG4gICAgICAvLyBHZXQgdGhlIGluZGljZXMgb2YgdGhlIGZvdXIgY2VsbHNcbiAgICAgIGNvbnN0IGJsSW5kZXggPSBnZXRJbmRleCh5LCB4LCBjb250cm9scy5HUklEX1dJRFRIKTtcbiAgICAgIGNvbnN0IGJySW5kZXggPSBnZXRJbmRleCh5LCB4ICsgMSwgY29udHJvbHMuR1JJRF9XSURUSCk7XG4gICAgICBjb25zdCB0bEluZGV4ID0gZ2V0SW5kZXgoeSArIDEsIHgsIGNvbnRyb2xzLkdSSURfV0lEVEgpO1xuICAgICAgY29uc3QgdHJJbmRleCA9IGdldEluZGV4KHkgKyAxLCB4ICsgMSwgY29udHJvbHMuR1JJRF9XSURUSCk7XG4gICAgICBcbiAgICAgIC8vIEdldCBhY3RpdmF0aW9uIHN0YXRlc1xuICAgICAgY29uc3QgYmxBY3RpdmUgPSBhY3RpdmF0aW9uU3RhdGVbYmxJbmRleF0gPT09IDEuMDtcbiAgICAgIGNvbnN0IGJyQWN0aXZlID0gYWN0aXZhdGlvblN0YXRlW2JySW5kZXhdID09PSAxLjA7XG4gICAgICBjb25zdCB0bEFjdGl2ZSA9IGFjdGl2YXRpb25TdGF0ZVt0bEluZGV4XSA9PT0gMS4wO1xuICAgICAgY29uc3QgdHJBY3RpdmUgPSBhY3RpdmF0aW9uU3RhdGVbdHJJbmRleF0gPT09IDEuMDtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgdGhlIGNvbm5lY3RvciBpcyBzdGlsbCB2YWxpZFxuICAgICAgbGV0IGlzVmFsaWQgPSB0cnVlO1xuICAgICAgXG4gICAgICBzd2l0Y2ggKGNvbm5lY3Rvcikge1xuICAgICAgICBjYXNlIENPTk5FQ1RPUl9ESUFHX1RMX0JSOlxuICAgICAgICAgIGlzVmFsaWQgPSB0bEFjdGl2ZSAmJiBickFjdGl2ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBDT05ORUNUT1JfRElBR19CTF9UUjpcbiAgICAgICAgICBpc1ZhbGlkID0gYmxBY3RpdmUgJiYgdHJBY3RpdmU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ09OTkVDVE9SX0hPUklaX1Q6XG4gICAgICAgICAgaXNWYWxpZCA9IHRsQWN0aXZlICYmIHRyQWN0aXZlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIENPTk5FQ1RPUl9IT1JJWl9COlxuICAgICAgICAgIGlzVmFsaWQgPSBibEFjdGl2ZSAmJiBickFjdGl2ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICAgIG5ld0ludGVuZGVkQ29ubmVjdG9yc1trZXldID0gQ09OTkVDVE9SX05PTkU7XG4gICAgICAgIGhhc0NoYW5nZXMgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE5vdyBjaGVjayBjbWQtY2xpY2sgaG9yaXpvbnRhbCBjb25uZWN0b3JzXG4gICAgZm9yIChjb25zdCBrZXkgaW4gY21kSG9yaXpDb25uZWN0b3JzKSB7XG4gICAgICBpZiAoY21kSG9yaXpDb25uZWN0b3JzW2tleV0gPT09IDApIGNvbnRpbnVlO1xuXG4gICAgICAvLyBQYXJzZSB4LHkgZnJvbSBrZXkgKHJlbW92ZSAnaGNtZDonIHByZWZpeClcbiAgICAgIGNvbnN0IFt4LCB5XSA9IGtleS5zdWJzdHJpbmcoNSkuc3BsaXQoJywnKS5tYXAoTnVtYmVyKTtcblxuICAgICAgLy8gR2V0IGluZGljZXMgZm9yIGxlZnQgYW5kIHJpZ2h0IGNpcmNsZXNcbiAgICAgIGNvbnN0IGxlZnRJbmRleCA9IGdldEluZGV4KHksIHgsIGNvbnRyb2xzLkdSSURfV0lEVEgpO1xuICAgICAgY29uc3QgcmlnaHRJbmRleCA9IGdldEluZGV4KHksIHggKyAxLCBjb250cm9scy5HUklEX1dJRFRIKTtcblxuICAgICAgLy8gQ2hlY2sgaWYgYm90aCBjaXJjbGVzIGFyZSBzdGlsbCBhY3RpdmVcbiAgICAgIGNvbnN0IGxlZnRBY3RpdmUgPSBhY3RpdmF0aW9uU3RhdGVbbGVmdEluZGV4XSA9PT0gMS4wO1xuICAgICAgY29uc3QgcmlnaHRBY3RpdmUgPSBhY3RpdmF0aW9uU3RhdGVbcmlnaHRJbmRleF0gPT09IDEuMDtcblxuICAgICAgaWYgKCFsZWZ0QWN0aXZlIHx8ICFyaWdodEFjdGl2ZSkge1xuICAgICAgICBuZXdDbWRIb3JpekNvbm5lY3RvcnNba2V5XSA9IDA7XG4gICAgICAgIGhhc0NtZEhvcml6Q2hhbmdlcyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGlmIChoYXNDaGFuZ2VzKSB7XG4gICAgICBzZXRJbnRlbmRlZENvbm5lY3RvcnMobmV3SW50ZW5kZWRDb25uZWN0b3JzKTtcbiAgICB9XG4gICAgaWYgKGhhc0NtZEhvcml6Q2hhbmdlcykge1xuICAgICAgc2V0Q21kSG9yaXpDb25uZWN0b3JzKG5ld0NtZEhvcml6Q29ubmVjdG9ycyk7XG4gICAgfVxuICB9LCBbYWN0aXZhdGlvblN0YXRlLCBjb250cm9scy5HUklEX1dJRFRILCBpbnRlbmRlZENvbm5lY3RvcnMsIGNtZEhvcml6Q29ubmVjdG9yc10pO1xuXG4gIC8vIENyZWF0ZSBhIGRhdGEgdGV4dHVyZSBmb3IgaW50ZW5kZWQgY29ubmVjdG9yc1xuICBjb25zdCBpbnRlbmRlZENvbm5lY3RvclRleHR1cmUgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBjb25zb2xlLmxvZyhgQ3JlYXRpbmcgaW50ZW5kZWQgY29ubmVjdG9yIHRleHR1cmU6ICR7Y29udHJvbHMuR1JJRF9XSURUSC0xfXgke2NvbnRyb2xzLkdSSURfSEVJR0hULTF9YCk7XG4gICAgXG4gICAgLy8gVGV4dHVyZSBoYXMgb25lIHBpeGVsIHBlciAyeDIgY2VsbCBncm91cCAoZ3JpZCBjZWxscyBtaW51cyAxIGluIGVhY2ggZGltZW5zaW9uKVxuICAgIGNvbnN0IHdpZHRoID0gTWF0aC5tYXgoMSwgY29udHJvbHMuR1JJRF9XSURUSCAtIDEpO1xuICAgIGNvbnN0IGhlaWdodCA9IE1hdGgubWF4KDEsIGNvbnRyb2xzLkdSSURfSEVJR0hUIC0gMSk7XG4gICAgXG4gICAgY29uc3QgdGV4dHVyZSA9IG5ldyBUSFJFRS5EYXRhVGV4dHVyZShcbiAgICAgIG5ldyBGbG9hdDMyQXJyYXkod2lkdGggKiBoZWlnaHQpLmZpbGwoMC4wKSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgVEhSRUUuUmVkRm9ybWF0LFxuICAgICAgVEhSRUUuRmxvYXRUeXBlXG4gICAgKTtcbiAgICBcbiAgICB0ZXh0dXJlLm1pbkZpbHRlciA9IFRIUkVFLk5lYXJlc3RGaWx0ZXI7XG4gICAgdGV4dHVyZS5tYWdGaWx0ZXIgPSBUSFJFRS5OZWFyZXN0RmlsdGVyO1xuICAgIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIFxuICAgIHJldHVybiB0ZXh0dXJlO1xuICB9LCBbY29udHJvbHMuR1JJRF9XSURUSCwgY29udHJvbHMuR1JJRF9IRUlHSFRdKTtcbiAgXG4gIC8vIFVwZGF0ZSB0aGUgaW50ZW5kZWQgY29ubmVjdG9yIHRleHR1cmUgd2hlbiBzdGF0ZSBjaGFuZ2VzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3Qgd2lkdGggPSBNYXRoLm1heCgxLCBjb250cm9scy5HUklEX1dJRFRIIC0gMSk7XG4gICAgY29uc3QgZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkod2lkdGggKiBNYXRoLm1heCgxLCBjb250cm9scy5HUklEX0hFSUdIVCAtIDEpKTtcbiAgICBcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGNvbnRyb2xzLkdSSURfSEVJR0hUIC0gMTsgeSsrKSB7XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IGNvbnRyb2xzLkdSSURfV0lEVEggLSAxOyB4KyspIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB5ICogd2lkdGggKyB4O1xuICAgICAgICBjb25zdCBjb25uZWN0b3IgPSBnZXRJbnRlbmRlZENvbm5lY3Rvcih4LCB5KTtcbiAgICAgICAgZGF0YVtpbmRleF0gPSBjb25uZWN0b3I7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGlmIChpbnRlbmRlZENvbm5lY3RvclRleHR1cmUgJiYgZGF0YS5sZW5ndGggPT09IGludGVuZGVkQ29ubmVjdG9yVGV4dHVyZS5pbWFnZS5kYXRhLmxlbmd0aCkge1xuICAgICAgaW50ZW5kZWRDb25uZWN0b3JUZXh0dXJlLmltYWdlLmRhdGEuc2V0KGRhdGEpO1xuICAgICAgaW50ZW5kZWRDb25uZWN0b3JUZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gIH0sIFtpbnRlbmRlZENvbm5lY3RvcnMsIGNvbnRyb2xzLkdSSURfV0lEVEgsIGNvbnRyb2xzLkdSSURfSEVJR0hULCBpbnRlbmRlZENvbm5lY3RvclRleHR1cmVdKTtcblxuICAvLyBDcmVhdGUgaG9yaXpvbnRhbCBjbWQtY2xpY2sgY29ubmVjdG9yIHRleHR1cmVcbiAgY29uc3QgY21kSG9yaXpDb25uZWN0b3JUZXh0dXJlID0gdXNlTWVtbygoKSA9PiB7XG4gICAgY29uc29sZS5sb2coYENyZWF0aW5nIGNtZC1jbGljayBob3Jpem9udGFsIGNvbm5lY3RvciB0ZXh0dXJlOiAke2NvbnRyb2xzLkdSSURfV0lEVEgtMX14JHtjb250cm9scy5HUklEX0hFSUdIVH1gKTtcbiAgICBcbiAgICAvLyBUZXh0dXJlIGhhcyBvbmUgcGl4ZWwgcGVyIGhvcml6b250YWwgY29ubmVjdGlvbiBwb3NzaWJpbGl0eVxuICAgIGNvbnN0IHdpZHRoID0gTWF0aC5tYXgoMSwgY29udHJvbHMuR1JJRF9XSURUSCAtIDEpO1xuICAgIGNvbnN0IGhlaWdodCA9IGNvbnRyb2xzLkdSSURfSEVJR0hUO1xuICAgIFxuICAgIGNvbnN0IHRleHR1cmUgPSBuZXcgVEhSRUUuRGF0YVRleHR1cmUoXG4gICAgICBuZXcgRmxvYXQzMkFycmF5KHdpZHRoICogaGVpZ2h0KS5maWxsKDAuMCksXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIFRIUkVFLlJlZEZvcm1hdCxcbiAgICAgIFRIUkVFLkZsb2F0VHlwZVxuICAgICk7XG4gICAgXG4gICAgdGV4dHVyZS5taW5GaWx0ZXIgPSBUSFJFRS5OZWFyZXN0RmlsdGVyO1xuICAgIHRleHR1cmUubWFnRmlsdGVyID0gVEhSRUUuTmVhcmVzdEZpbHRlcjtcbiAgICB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICBcbiAgICByZXR1cm4gdGV4dHVyZTtcbiAgfSwgW2NvbnRyb2xzLkdSSURfV0lEVEgsIGNvbnRyb2xzLkdSSURfSEVJR0hUXSk7XG4gIFxuICAvLyBVcGRhdGUgdGhlIGNtZC1jbGljayBob3Jpem9udGFsIGNvbm5lY3RvciB0ZXh0dXJlIHdoZW4gc3RhdGUgY2hhbmdlc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHdpZHRoID0gTWF0aC5tYXgoMSwgY29udHJvbHMuR1JJRF9XSURUSCAtIDEpO1xuICAgIGNvbnN0IGRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KHdpZHRoICogY29udHJvbHMuR1JJRF9IRUlHSFQpO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKCdVcGRhdGluZyBjbWQtaG9yaXogY29ubmVjdG9yIHRleHR1cmU6Jywge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQ6IGNvbnRyb2xzLkdSSURfSEVJR0hULFxuICAgICAgY29ubmVjdG9yczogY21kSG9yaXpDb25uZWN0b3JzXG4gICAgfSk7XG4gICAgXG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBjb250cm9scy5HUklEX0hFSUdIVDsgeSsrKSB7XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0gZ2V0SG9yaXpDbWRDb25uZWN0b3JLZXkoeCwgeSk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gY21kSG9yaXpDb25uZWN0b3JzW2tleV0gfHwgMDtcbiAgICAgICAgZGF0YVt5ICogd2lkdGggKyB4XSA9IHZhbHVlO1xuICAgICAgICBcbiAgICAgICAgaWYgKHZhbHVlID4gMCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdGb3VuZCBhY3RpdmUgY29ubmVjdG9yOicsIHsgeCwgeSwga2V5LCB2YWx1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBpZiAoY21kSG9yaXpDb25uZWN0b3JUZXh0dXJlICYmIGRhdGEubGVuZ3RoID09PSBjbWRIb3JpekNvbm5lY3RvclRleHR1cmUuaW1hZ2UuZGF0YS5sZW5ndGgpIHtcbiAgICAgIGNtZEhvcml6Q29ubmVjdG9yVGV4dHVyZS5pbWFnZS5kYXRhLnNldChkYXRhKTtcbiAgICAgIGNtZEhvcml6Q29ubmVjdG9yVGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICBjb25zb2xlLmxvZygnVXBkYXRlZCBjbWQtaG9yaXogY29ubmVjdG9yIHRleHR1cmUgZGF0YScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1NraXBwaW5nIGNtZC1ob3JpeiB0ZXh0dXJlIHVwZGF0ZTogc2l6ZSBtaXNtYXRjaCBvciB0ZXh0dXJlIG5vdCByZWFkeScsIHtcbiAgICAgICAgdGV4dHVyZVNpemU6IGNtZEhvcml6Q29ubmVjdG9yVGV4dHVyZT8uaW1hZ2UuZGF0YS5sZW5ndGgsXG4gICAgICAgIGRhdGFTaXplOiBkYXRhLmxlbmd0aFxuICAgICAgfSk7XG4gICAgfVxuICB9LCBbY21kSG9yaXpDb25uZWN0b3JzLCBjb250cm9scy5HUklEX1dJRFRILCBjb250cm9scy5HUklEX0hFSUdIVCwgY21kSG9yaXpDb25uZWN0b3JUZXh0dXJlXSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIW1lc2hSZWYuY3VycmVudCkgcmV0dXJuO1xuICAgIFxuICAgIC8vIEVuYWJsZSBmcnVzdHVtIGN1bGxpbmdcbiAgICBtZXNoUmVmLmN1cnJlbnQuZnJ1c3R1bUN1bGxlZCA9IHRydWU7XG4gICAgXG4gICAgLy8gVXBkYXRlIGJvdW5kaW5nIHNwaGVyZSBmb3IgYmV0dGVyIGN1bGxpbmdcbiAgICBpZiAobWVzaFJlZi5jdXJyZW50Lmdlb21ldHJ5KSB7XG4gICAgICBtZXNoUmVmLmN1cnJlbnQuZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG4gICAgICBpZiAobWVzaFJlZi5jdXJyZW50Lmdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlKSB7XG4gICAgICAgIG1lc2hSZWYuY3VycmVudC5nZW9tZXRyeS5ib3VuZGluZ1NwaGVyZS5yYWRpdXMgKj0gTWF0aC5tYXgoY29udHJvbHMudmlzdWFsU2NhbGUsIDEuMCk7XG4gICAgICB9XG4gICAgfVxuICB9LCBbY29udHJvbHMudmlzdWFsU2NhbGVdKTtcblxuICAvLyAtLS0gUGVyZm9ybWFuY2UgTW9uaXRvcmluZyBTZXR1cCAtLS1cbiAgY29uc3Qgc3RhdHNSZWYgPSB1c2VSZWY8YW55IHwgbnVsbD4obnVsbCk7IC8vIFVzZSB1c2VSZWYgdG8gaG9sZCB0aGUgaW5zdGFuY2VcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIFN0YXRzIGlzIGRpc2FibGVkIGZvciBub3cgZHVlIHRvIGltcG9ydCBpc3N1ZXNcbiAgICAvLyBJbml0aWFsaXplIFN0YXRzLmpzIG9uIGNvbXBvbmVudCBtb3VudFxuICAgIC8qXG4gICAgc3RhdHNSZWYuY3VycmVudCA9IG5ldyBTdGF0cygpO1xuICAgIHN0YXRzUmVmLmN1cnJlbnQuc2hvd1BhbmVsKDApOyAvLyAwOiBmcHMsIDE6IG1zLCAyOiBtYiwgMys6IGN1c3RvbVxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc3RhdHNSZWYuY3VycmVudC5kb20pO1xuICAgICovXG5cbiAgICAvLyBDbGVhbnVwIGZ1bmN0aW9uIHRvIHJlbW92ZSBTdGF0cy5qcyBvbiB1bm1vdW50XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChzdGF0c1JlZi5jdXJyZW50KSB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoc3RhdHNSZWYuY3VycmVudC5kb20pO1xuICAgICAgICBzdGF0c1JlZi5jdXJyZW50ID0gbnVsbDsgLy8gQ2xlYXIgdGhlIHJlZlxuICAgICAgfVxuICAgIH07XG4gIH0sIFtdKTsgLy8gRW1wdHkgZGVwZW5kZW5jeSBhcnJheSBlbnN1cmVzIHRoaXMgcnVucyBvbmx5IG9uY2Ugb24gbW91bnQvdW5tb3VudFxuXG4gIC8vIEZyYW1lIHVwZGF0ZSBsb2dpYyAoaW5jbHVkaW5nIHN0YXRzKVxuICB1c2VGcmFtZSgoc3RhdGUpID0+IHtcbiAgICBpZiAoc3RhdHNSZWYuY3VycmVudCkgeyAvLyBDaGVjayBpZiBzdGF0c1JlZi5jdXJyZW50IGV4aXN0c1xuICAgICAgc3RhdHNSZWYuY3VycmVudC51cGRhdGUoKTsgLy8gVXBkYXRlIEZQUyBjb3VudGVyXG4gICAgfVxuXG4gICAgLy8gT3B0aW9uYWw6IExvZyBmcmFtZSB0aW1lIHBlcmlvZGljYWxseVxuICAgIC8vIGlmIChzdGF0ZS5jbG9jay5lbGFwc2VkVGltZSAlIDUgPCBzdGF0ZS5jbG9jay5nZXREZWx0YSgpKSB7IC8vIENoZWNrIGV2ZXJ5IDVzXG4gICAgLy8gICBjb25zb2xlLmxvZygnRnJhbWUgdGltZTonLCBzdGF0ZS5jbG9jay5nZXREZWx0YSgpICogMTAwMCwgJ21zJyk7XG4gICAgLy8gfVxuICB9KTtcblxuICAvLyBTYXZlIHdpdGggZGlyZWN0IHZhbHVlc1xuICBjb25zdCBzYXZlR3JpZFN0YXRlV2l0aERpcmVjdFZhbHVlcyA9IHVzZUNhbGxiYWNrKChcbiAgICBjdXJyZW50QWN0aXZhdGlvbjogRmxvYXQzMkFycmF5LFxuICAgIGRpcmVjdEludGVuZGVkQ29ubmVjdG9yczogUmVjb3JkPHN0cmluZywgbnVtYmVyPixcbiAgICBkaXJlY3RDbWRIb3JpekNvbm5lY3RvcnM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4sXG4gICAgZ3JpZFdpZHRoOiBudW1iZXIsXG4gICAgZ3JpZEhlaWdodDogbnVtYmVyXG4gICkgPT4ge1xuICAgIGNvbnNvbGUubG9nKFwiPT09PT09PT09PSBTQVZFIERJQUdOT1NUSUNTIFNUQVJUID09PT09PT09PT1cIik7XG4gICAgY29uc29sZS5sb2coXCJTdGFydGluZyBkaXJlY3Qgc2F2ZSBncmlkIHN0YXRlIHdpdGggZGF0YTpcIik7XG4gICAgXG4gICAgY29uc29sZS5sb2coYEN1cnJlbnQgZ3JpZCBkaW1lbnNpb25zOiAke2dyaWRXaWR0aH0geCAke2dyaWRIZWlnaHR9YCk7XG4gICAgXG4gICAgLy8gTG9nIHRoZSBzdGF0ZSBkZXRhaWxzXG4gICAgY29uc29sZS5sb2coXCItIEN1cnJlbnQgYWN0aXZhdGlvbiBzdGF0ZSBoYXMgbGVuZ3RoOlwiLCBjdXJyZW50QWN0aXZhdGlvbi5sZW5ndGgpO1xuICAgIGNvbnNvbGUubG9nKFwiLSBBY3RpdmUgbm9kZXMgY291bnQ6XCIsIEFycmF5LmZyb20oY3VycmVudEFjdGl2YXRpb24pLmZpbHRlcih2YWwgPT4gdmFsID09PSAxLjApLmxlbmd0aCk7XG4gICAgXG4gICAgLy8gTG9nIHRoZSByYXcgc3RhdGUgZm9yIGRlYnVnZ2luZ1xuICAgIGNvbnNvbGUubG9nKFwiUkFXIGludGVuZGVkQ29ubmVjdG9yczpcIiwgZGlyZWN0SW50ZW5kZWRDb25uZWN0b3JzKTtcbiAgICBjb25zb2xlLmxvZyhcIlJBVyBjbWRIb3JpekNvbm5lY3RvcnM6XCIsIGRpcmVjdENtZEhvcml6Q29ubmVjdG9ycyk7XG4gICAgXG4gICAgLy8gTWFrZSBkZWVwIGNvcGllcyB0byBlbnN1cmUgd2UgZG9uJ3QgbXV0YXRlIHRoZSBvcmlnaW5hbCBvYmplY3RzXG4gICAgY29uc3QgaW50ZW5kZWRDb25uZWN0b3JzQ29weSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZGlyZWN0SW50ZW5kZWRDb25uZWN0b3JzKSk7XG4gICAgY29uc3QgY21kSG9yaXpDb25uZWN0b3JzQ29weSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZGlyZWN0Q21kSG9yaXpDb25uZWN0b3JzKSk7XG4gICAgXG4gICAgLy8gREVCVUc6IExvZyB0aGUgaW50ZW5kZWQgY29ubmVjdG9ycyBpbiBkZXRhaWxcbiAgICBjb25zb2xlLmxvZyhcIi0gSW50ZW5kZWQgY29ubmVjdG9ycyAoZGlyZWN0KSBrZXlzOlwiLCBPYmplY3Qua2V5cyhpbnRlbmRlZENvbm5lY3RvcnNDb3B5KSk7XG4gICAgY29uc29sZS5sb2coXCItIEludGVuZGVkIGNvbm5lY3RvcnMgKGRpcmVjdCkgY291bnQ6XCIsIE9iamVjdC5rZXlzKGludGVuZGVkQ29ubmVjdG9yc0NvcHkpLmxlbmd0aCk7XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgY29ubmVjdG9ycyBoYXZlIGFjdHVhbCB2YWx1ZXMgb3IgYXJlIGp1c3QgZW1wdHkgb2JqZWN0c1xuICAgIGNvbnN0IG5vblplcm9JbnRlbmRlZENvbm5lY3RvcnMgPSBPYmplY3QuZW50cmllcyhpbnRlbmRlZENvbm5lY3RvcnNDb3B5KS5maWx0ZXIoKFtrZXksIHZhbHVlXSkgPT4gdmFsdWUgIT09IENPTk5FQ1RPUl9OT05FKTtcbiAgICBjb25zb2xlLmxvZyhcIi0gTm9uLXplcm8gaW50ZW5kZWQgY29ubmVjdG9yczpcIiwgbm9uWmVyb0ludGVuZGVkQ29ubmVjdG9ycy5sZW5ndGgpO1xuICAgIGNvbnNvbGUubG9nKFwiLSBOb24temVybyBpbnRlbmRlZCBjb25uZWN0b3JzIGRhdGE6XCIsIG5vblplcm9JbnRlbmRlZENvbm5lY3RvcnMpO1xuICAgIFxuICAgIC8vIERFQlVHOiBMb2cgdGhlIGNtZCBob3JpeiBjb25uZWN0b3JzIGluIGRldGFpbFxuICAgIGNvbnNvbGUubG9nKFwiLSBDbWQgaG9yaXogY29ubmVjdG9ycyAoZGlyZWN0KSBrZXlzOlwiLCBPYmplY3Qua2V5cyhjbWRIb3JpekNvbm5lY3RvcnNDb3B5KSk7XG4gICAgY29uc29sZS5sb2coXCItIENtZCBob3JpeiBjb25uZWN0b3JzIGNvdW50OlwiLCBPYmplY3Qua2V5cyhjbWRIb3JpekNvbm5lY3RvcnNDb3B5KS5sZW5ndGgpO1xuICAgIFxuICAgIC8vIENoZWNrIGlmIGNtZCBob3JpeiBjb25uZWN0b3JzIGhhdmUgYWN0dWFsIHZhbHVlcyBvciBhcmUganVzdCBlbXB0eSBvYmplY3RzXG4gICAgY29uc3QgYWN0aXZlSG9yaXpDb25uZWN0b3JzID0gT2JqZWN0LmVudHJpZXMoY21kSG9yaXpDb25uZWN0b3JzQ29weSkuZmlsdGVyKChba2V5LCB2YWx1ZV0pID0+IHZhbHVlID09PSAxKTtcbiAgICBjb25zb2xlLmxvZyhcIi0gQWN0aXZlIGhvcml6IGNvbm5lY3RvcnM6XCIsIGFjdGl2ZUhvcml6Q29ubmVjdG9ycy5sZW5ndGgpO1xuICAgIGNvbnNvbGUubG9nKFwiLSBBY3RpdmUgaG9yaXogY29ubmVjdG9ycyBkYXRhOlwiLCBhY3RpdmVIb3JpekNvbm5lY3RvcnMpO1xuICAgIFxuICAgIC8vIEZpbmQgYWxsIGFjdGl2ZSBub2Rlc1xuICAgIGNvbnN0IG5vZGVzOiBHcmlkTm9kZVtdID0gW107XG4gICAgLy8gRW5zdXJlIGxvb3AgdXNlcyB0aGUgY29ycmVjdCBsZW5ndGggYmFzZWQgb24gYWN0dWFsIGFjdGl2YXRpb24gYXJyYXksXG4gICAgLy8gYnV0IGNvb3JkaW5hdGUgY2FsY3VsYXRpb24gdXNlcyBwYXNzZWQgZGltZW5zaW9uc1xuICAgIGNvbnN0IGV4cGVjdGVkTGVuZ3RoID0gZ3JpZFdpZHRoICogZ3JpZEhlaWdodDtcbiAgICBpZiAoY3VycmVudEFjdGl2YXRpb24ubGVuZ3RoICE9PSBleHBlY3RlZExlbmd0aCkge1xuICAgICAgICBjb25zb2xlLndhcm4oYEFjdGl2YXRpb24gYXJyYXkgbGVuZ3RoICgke2N1cnJlbnRBY3RpdmF0aW9uLmxlbmd0aH0pIGRvZXNuJ3QgbWF0Y2ggZXhwZWN0ZWQgKCR7ZXhwZWN0ZWRMZW5ndGh9KSBiYXNlZCBvbiBwYXNzZWQgZGltZW5zaW9ucyEgVXNpbmcgYXJyYXkgbGVuZ3RoIGZvciBsb29wLCBidXQgY29vcmRpbmF0ZXMgbWlnaHQgYmUgd3JvbmcuYCk7XG4gICAgfVxuICAgIFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVudEFjdGl2YXRpb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChjdXJyZW50QWN0aXZhdGlvbltpXSA9PT0gMS4wKSB7XG4gICAgICAgIC8vIFVzZSBwYXNzZWQgZ3JpZFdpZHRoIGZvciBjb29yZGluYXRlIGNhbGN1bGF0aW9uXG4gICAgICAgIGNvbnN0IHJvdyA9IE1hdGguZmxvb3IoaSAvIGdyaWRXaWR0aCk7IFxuICAgICAgICBjb25zdCBjb2wgPSBpICUgZ3JpZFdpZHRoO1xuICAgICAgICAvLyBBZGQgYm91bmRzIGNoZWNrIGp1c3QgaW4gY2FzZSBhY3RpdmF0aW9uIGFycmF5IGxlbmd0aCBtaXNtYXRjaGVzXG4gICAgICAgIGlmIChjb2wgPj0gMCAmJiBjb2wgPCBncmlkV2lkdGggJiYgcm93ID49IDAgJiYgcm93IDwgZ3JpZEhlaWdodCkge1xuICAgICAgICAgIG5vZGVzLnB1c2goeyB4OiBjb2wsIHk6IHJvdyB9KTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgRm91bmQgYWN0aXZlIG5vZGUgYXQgKCR7Y29sfSwgJHtyb3d9KWApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2FybihgQ2FsY3VsYXRlZCBub2RlIGNvb3JkcyAoJHtjb2x9LCAke3Jvd30pIGZvciBpbmRleCAke2l9IGFyZSBvdXQgb2YgYm91bmRzIGZvciBwYXNzZWQgZGltZW5zaW9ucyAke2dyaWRXaWR0aH14JHtncmlkSGVpZ2h0fS4gU2tpcHBpbmcuYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc29sZS5sb2coYFRvdGFsIGFjdGl2ZSBub2RlcyBmb3VuZDogJHtub2Rlcy5sZW5ndGh9YCk7XG5cbiAgICAvLyBGaW5kIGFsbCBlZGdlcyAtIGNvbm5lY3RvcnMgYmV0d2VlbiBhY3RpdmUgbm9kZXNcbiAgICBjb25zdCBlZGdlczogR3JpZEVkZ2VbXSA9IFtdO1xuICAgIFxuICAgIC8vIFByb2Nlc3MgaW50ZW5kZWQgY29ubmVjdG9ycyAoZGlhZ29uYWxzLCBldGMuKVxuICAgIGNvbnNvbGUubG9nKFwiUHJvY2Vzc2luZyBpbnRlbmRlZCBjb25uZWN0b3JzLi4uXCIpO1xuICAgIC8vIEluc3RlYWQgb2YgaXRlcmF0aW5nIHRocm91Z2ggYWxsIHBvc2l0aW9ucywgZGlyZWN0bHkgaXRlcmF0ZSBvdmVyIHRoZSBrZXlzIGluIHRoZSBjb25uZWN0b3JzIG9iamVjdFxuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGludGVuZGVkQ29ubmVjdG9yc0NvcHkpKSB7XG4gICAgICBjb25zdCB0eXBlID0gaW50ZW5kZWRDb25uZWN0b3JzQ29weVtrZXldO1xuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlID09PSBDT05ORUNUT1JfTk9ORSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gRXh0cmFjdCB4LHkgZnJvbSB0aGUga2V5ICh3aGljaCBpcyBpbiBmb3JtYXQgXCJ4LHlcIilcbiAgICAgIGNvbnN0IFt4LCB5XSA9IGtleS5zcGxpdCgnLCcpLm1hcChOdW1iZXIpO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiBleHRyYWN0ZWQgY29vcmRpbmF0ZXMgYXJlIHZhbGlkIGZvciB0aGUgY3VycmVudCBncmlkIGRpbWVuc2lvbnNcbiAgICAgIGlmICh4IDwgMCB8fCB4ID49IGdyaWRXaWR0aCAtIDEgfHwgeSA8IDAgfHwgeSA+PSBncmlkSGVpZ2h0IC0gMSkge1xuICAgICAgICBjb25zb2xlLndhcm4oYENvbm5lY3RvciBhdCAoJHt4fSwke3l9KSBpcyBvdXQgb2YgYm91bmRzIGZvciBjdXJyZW50IGdyaWQgc2l6ZSAoJHtncmlkV2lkdGh9eCR7Z3JpZEhlaWdodH0pLCBza2lwcGluZy5gKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGBGb3VuZCBjb25uZWN0b3IgYXQgKCR7eH0sJHt5fSkgd2l0aCBrZXkgJHtrZXl9LCB0eXBlPSR7dHlwZX1gKTtcbiAgICAgIFxuICAgICAgLy8gTWFwIHRoZSBudW1lcmljIGNvbm5lY3RvciB0eXBlIHRvIHRoZSBzdHJpbmcgdHlwZSBmb3IgdGhlIEpTT05cbiAgICAgIGxldCBlZGdlVHlwZTogR3JpZEVkZ2VbJ3R5cGUnXSB8IG51bGwgPSBudWxsO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgQ09OTkVDVE9SX0RJQUdfVExfQlI6IFxuICAgICAgICAgIGVkZ2VUeXBlID0gJ2RpYWdfdGxfYnInOyBcbiAgICAgICAgICBjb25zb2xlLmxvZyhgQ29udmVydGluZyBDT05ORUNUT1JfRElBR19UTF9CUiAoJHtDT05ORUNUT1JfRElBR19UTF9CUn0pIHRvICdkaWFnX3RsX2JyJ2ApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIENPTk5FQ1RPUl9ESUFHX0JMX1RSOiBcbiAgICAgICAgICBlZGdlVHlwZSA9ICdkaWFnX2JsX3RyJzsgXG4gICAgICAgICAgY29uc29sZS5sb2coYENvbnZlcnRpbmcgQ09OTkVDVE9SX0RJQUdfQkxfVFIgKCR7Q09OTkVDVE9SX0RJQUdfQkxfVFJ9KSB0byAnZGlhZ19ibF90cidgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBDT05ORUNUT1JfSE9SSVpfVDogXG4gICAgICAgICAgZWRnZVR5cGUgPSAnaG9yaXpfdCc7IFxuICAgICAgICAgIGNvbnNvbGUubG9nKGBDb252ZXJ0aW5nIENPTk5FQ1RPUl9IT1JJWl9UICgke0NPTk5FQ1RPUl9IT1JJWl9UfSkgdG8gJ2hvcml6X3QnYCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ09OTkVDVE9SX0hPUklaX0I6IFxuICAgICAgICAgIGVkZ2VUeXBlID0gJ2hvcml6X2InOyBcbiAgICAgICAgICBjb25zb2xlLmxvZyhgQ29udmVydGluZyBDT05ORUNUT1JfSE9SSVpfQiAoJHtDT05ORUNUT1JfSE9SSVpfQn0pIHRvICdob3Jpel9iJ2ApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNvbnNvbGUud2FybihgVW5rbm93biBjb25uZWN0b3IgdHlwZSBpZ25vcmVkOiAke3R5cGV9YCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChlZGdlVHlwZSkge1xuICAgICAgICBlZGdlcy5wdXNoKHsgdHlwZTogZWRnZVR5cGUsIHgsIHkgfSk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBBZGRlZCAke2VkZ2VUeXBlfSBjb25uZWN0b3IgYXQgKCR7eH0sICR7eX0pIHRvIGVkZ2VzIGFycmF5YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUHJvY2VzcyBjbWQtaG9yaXpvbnRhbCBjb25uZWN0b3JzXG4gICAgY29uc29sZS5sb2coXCJQcm9jZXNzaW5nIGNtZC1ob3Jpem9udGFsIGNvbm5lY3RvcnMuLi5cIik7XG4gICAgLy8gSW5zdGVhZCBvZiBpdGVyYXRpbmcgdGhyb3VnaCBhbGwgcG9zaXRpb25zLCBkaXJlY3RseSBpdGVyYXRlIG92ZXIgdGhlIGtleXMgaW4gdGhlIGNtZEhvcml6Q29ubmVjdG9ycyBvYmplY3RcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhjbWRIb3JpekNvbm5lY3RvcnNDb3B5KSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBjbWRIb3JpekNvbm5lY3RvcnNDb3B5W2tleV07XG4gICAgICBpZiAodmFsdWUgIT09IDEpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEV4dHJhY3QgeCx5IGZyb20gdGhlIGtleSAoZm9ybWF0IGlzIFwiaGNtZDp4LHlcIilcbiAgICAgIGNvbnN0IFt4LCB5XSA9IGtleS5zdWJzdHJpbmcoNSkuc3BsaXQoJywnKS5tYXAoTnVtYmVyKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgZXh0cmFjdGVkIGNvb3JkaW5hdGVzIGFyZSB2YWxpZCBmb3IgdGhlIGN1cnJlbnQgZ3JpZCBkaW1lbnNpb25zXG4gICAgICBpZiAoeCA8IDAgfHwgeCA+PSBncmlkV2lkdGggLSAxIHx8IHkgPCAwIHx8IHkgPj0gZ3JpZEhlaWdodCkge1xuICAgICAgICBjb25zb2xlLndhcm4oYENNRC1ob3JpeiBjb25uZWN0b3IgYXQgKCR7eH0sJHt5fSkgaXMgb3V0IG9mIGJvdW5kcyBmb3IgY3VycmVudCBncmlkIHNpemUgKCR7Z3JpZFdpZHRofXgke2dyaWRIZWlnaHR9KSwgc2tpcHBpbmcuYCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgXG4gICAgICBlZGdlcy5wdXNoKHsgdHlwZTogJ2NtZF9ob3JpeicsIHgsIHkgfSk7XG4gICAgICBjb25zb2xlLmxvZyhgQWRkZWQgY21kX2hvcml6IGNvbm5lY3RvciBhdCAoJHt4fSwgJHt5fSkgdG8gZWRnZXMgYXJyYXlgKTtcbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coYFRvdGFsIGVkZ2VzIGZvdW5kOiAke2VkZ2VzLmxlbmd0aH1gKTtcblxuICAgIC8vIENyZWF0ZSB0aGUgZmluYWwgSlNPTiBkYXRhIHN0cnVjdHVyZVxuICAgIGNvbnN0IGRhdGE6IEFkamFjZW5jeUxpc3REYXRhID0ge1xuICAgICAgZ3JpZFdpZHRoLFxuICAgICAgZ3JpZEhlaWdodCxcbiAgICAgIG5vZGVzLFxuICAgICAgZWRnZXMsXG4gICAgfTtcblxuICAgIC8vIENyZWF0ZSBKU09OIHN0cmluZ1xuICAgIGNvbnN0IGRhdGFTdHIgPSBKU09OLnN0cmluZ2lmeShkYXRhLCBudWxsLCAyKTtcbiAgICBjb25zb2xlLmxvZygnR3JpZCBTdGF0ZSBKU09OOicsIGRhdGFTdHIpO1xuICAgIGNvbnNvbGUubG9nKFwiPT09PT09PT09PSBTQVZFIERJQUdOT1NUSUNTIEVORCA9PT09PT09PT09XCIpO1xuXG4gICAgLy8gVHJpZ2dlciBkb3dubG9hZFxuICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbZGF0YVN0cl0sIHsgdHlwZTogJ2FwcGxpY2F0aW9uL2pzb24nIH0pO1xuICAgIGNvbnN0IHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgY29uc3QgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICBhLmhyZWYgPSB1cmw7XG4gICAgYS5kb3dubG9hZCA9IGBncmlkX3N0YXRlXyR7Z3JpZFdpZHRofXgke2dyaWRIZWlnaHR9Lmpzb25gO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYSk7XG4gICAgYS5jbGljaygpO1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoYSk7XG4gICAgVVJMLnJldm9rZU9iamVjdFVSTCh1cmwpO1xuICB9LCBbXSk7XG5cbiAgLy8gLS0tIFNhdmUgR3JpZCBTdGF0ZSBGdW5jdGlvbiAtLS1cbiAgY29uc3Qgc2F2ZUdyaWRTdGF0ZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zb2xlLmxvZyhcIlN0YXJ0aW5nIHNhdmUgZ3JpZCBzdGF0ZSB3aXRoIGRhdGE6XCIpO1xuICAgIFxuICAgIC8vIEdldCB0aGUgY3VycmVudCBhY3RpdmF0aW9uIHN0YXRlIGRpcmVjdGx5IGZyb20gdGhlIGJ1ZmZlciBhdHRyaWJ1dGVcbiAgICAvLyB3aGljaCBpcyB0aGUgbW9zdCB1cC10by1kYXRlIHNvdXJjZSBvZiB0cnV0aFxuICAgIGxldCBjdXJyZW50QWN0aXZhdGlvbjogRmxvYXQzMkFycmF5O1xuICAgIGlmIChhY3RpdmF0aW9uQXR0cmlidXRlUmVmLmN1cnJlbnQgJiYgYWN0aXZhdGlvbkF0dHJpYnV0ZVJlZi5jdXJyZW50LmFycmF5KSB7XG4gICAgICBjdXJyZW50QWN0aXZhdGlvbiA9IGFjdGl2YXRpb25BdHRyaWJ1dGVSZWYuY3VycmVudC5hcnJheSBhcyBGbG9hdDMyQXJyYXk7XG4gICAgICBjb25zb2xlLmxvZyhcIi0gVXNpbmcgYWN0aXZhdGlvbiBzdGF0ZSBmcm9tIGJ1ZmZlciBhdHRyaWJ1dGVcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRBY3RpdmF0aW9uID0gYWN0aXZhdGlvblN0YXRlO1xuICAgICAgY29uc29sZS5sb2coXCItIFVzaW5nIGFjdGl2YXRpb24gc3RhdGUgZnJvbSBSZWFjdCBzdGF0ZSAoZmFsbGJhY2spXCIpO1xuICAgIH1cblxuICAgIC8vIFVzZSB0aGUgcmVmIHZhbHVlcyB3aGljaCBzaG91bGQgYmUgaW4gc3luYyB3aXRoIHN0YXRlXG4gICAgY29uc3QgY3VycmVudEludGVuZGVkQ29ubmVjdG9ycyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoaW50ZW5kZWRDb25uZWN0b3JzUmVmLmN1cnJlbnQgfHwge30pKTtcbiAgICBjb25zdCBjdXJyZW50Q21kSG9yaXpDb25uZWN0b3JzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShjbWRIb3JpekNvbm5lY3RvcnNSZWYuY3VycmVudCB8fCB7fSkpO1xuXG4gICAgLy8gRGVidWcgY3VycmVudCBzdGF0ZVxuICAgIGNvbnNvbGUubG9nKFwiQ3VycmVudCBpbnRlbmRlZCBjb25uZWN0b3JzIGJlZm9yZSBzYXZlOlwiLCBjdXJyZW50SW50ZW5kZWRDb25uZWN0b3JzKTtcbiAgICBjb25zb2xlLmxvZyhcIktleXMgaW4gaW50ZW5kZWQgY29ubmVjdG9yczpcIiwgT2JqZWN0LmtleXMoY3VycmVudEludGVuZGVkQ29ubmVjdG9ycykpO1xuICAgIGNvbnNvbGUubG9nKFwiQWN0aXZlIGludGVuZGVkIGNvbm5lY3RvcnM6XCIsIE9iamVjdC5lbnRyaWVzKGN1cnJlbnRJbnRlbmRlZENvbm5lY3RvcnMpLmZpbHRlcigoW18sIHZdKSA9PiB2ICE9PSBDT05ORUNUT1JfTk9ORSkpO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKFwiQ3VycmVudCBjbWQgaG9yaXogY29ubmVjdG9ycyBiZWZvcmUgc2F2ZTpcIiwgY3VycmVudENtZEhvcml6Q29ubmVjdG9ycyk7XG4gICAgY29uc29sZS5sb2coXCJBY3RpdmUgY21kIGhvcml6IGNvbm5lY3RvcnM6XCIsIE9iamVjdC5lbnRyaWVzKGN1cnJlbnRDbWRIb3JpekNvbm5lY3RvcnMpLmZpbHRlcigoW18sIHZdKSA9PiB2ID09PSAxKSk7XG5cbiAgICBjb25zb2xlLmxvZyhcIlVzaW5nIGRpcmVjdCBzYXZlIG1ldGhvZCB0byBlbnN1cmUgdXAtdG8tZGF0ZSBzdGF0ZSBjYXB0dXJlXCIpO1xuICAgIHNhdmVHcmlkU3RhdGVXaXRoRGlyZWN0VmFsdWVzKGN1cnJlbnRBY3RpdmF0aW9uLCBjdXJyZW50SW50ZW5kZWRDb25uZWN0b3JzLCBjdXJyZW50Q21kSG9yaXpDb25uZWN0b3JzLCBjb250cm9scy5HUklEX1dJRFRILCBjb250cm9scy5HUklEX0hFSUdIVCk7XG4gICAgXG4gIH0sIFtjb250cm9scywgYWN0aXZhdGlvblN0YXRlLCBhY3RpdmF0aW9uQXR0cmlidXRlUmVmXSk7XG5cbiAgLy8gRGVidWcgZnVuY3Rpb24gdG8gY3JlYXRlIGEgdGVzdCBwYXR0ZXJuIHNpbWlsYXIgdG8gd2hhdCdzIGluIHRoZSBpbWFnZVxuICBjb25zdCBjcmVhdGVUZXN0UGF0dGVybiA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zb2xlLmxvZyhcIj09PT09PT09PT0gVEVTVCBQQVRURVJOIENSRUFUSU9OIFNUQVJUID09PT09PT09PT1cIik7XG4gICAgY29uc29sZS5sb2coXCJDcmVhdGluZyB0ZXN0IHBhdHRlcm5cIik7XG4gICAgLy8gQ3JlYXRlIGEgbmV3IGFjdGl2YXRpb24gc3RhdGUgYXJyYXlcbiAgICBjb25zdCBuZXdBY3RpdmF0aW9uU3RhdGUgPSBuZXcgRmxvYXQzMkFycmF5KFRPVEFMX0NJUkNMRVMpLmZpbGwoMC4wKTtcbiAgICBcbiAgICAvLyBBY3RpdmF0ZSBub2RlcyBpbiBhIHBhdHRlcm4gc2ltaWxhciB0byB0aGUgaW1hZ2VcbiAgICAvLyBUaGUgcGF0dGVybiBzaG93cyBhIHZlcnRpY2FsIGxpbmUgd2l0aCBzb21lIGhvcml6b250YWwgY29ubmVjdG9ycyBhbmQgZGlhZ29uYWwgYnJhbmNoZXNcbiAgICBjb25zdCBwYXR0ZXJuID0gW1xuICAgICAgLy8gVmVydGljYWwgY2VudHJhbCBjb2x1bW4gKHRvcCB0byBib3R0b20pXG4gICAgICB7IHg6IDUsIHk6IDIgfSwgLy8gVG9wIG5vZGVcbiAgICAgIHsgeDogNSwgeTogMyB9LCBcbiAgICAgIHsgeDogNSwgeTogNCB9LCBcbiAgICAgIHsgeDogNSwgeTogNSB9LCBcbiAgICAgIHsgeDogNSwgeTogNiB9LCBcbiAgICAgIHsgeDogNSwgeTogNyB9LCAvLyBCb3R0b20gbm9kZVxuICAgICAgXG4gICAgICAvLyBIb3Jpem9udGFsIGNvbm5lY3Rpb24gaW4gdGhlIG1pZGRsZSByb3dcbiAgICAgIHsgeDogNCwgeTogNCB9LCAvLyBMZWZ0IG5vZGUgb24gbWlkZGxlIHJvd1xuICAgICAgeyB4OiA2LCB5OiA0IH0sIC8vIFJpZ2h0IG5vZGUgb24gbWlkZGxlIHJvd1xuICAgICAgXG4gICAgICAvLyBEaWFnb25hbCBjbHVzdGVyIGF0IGJvdHRvbVxuICAgICAgeyB4OiA0LCB5OiA2IH0sIC8vIEJvdHRvbSBsZWZ0XG4gICAgICB7IHg6IDYsIHk6IDYgfSwgLy8gQm90dG9tIHJpZ2h0XG4gICAgICBcbiAgICAgIC8vIERpYWdvbmFsIG5vZGUgYXQgdG9wXG4gICAgICB7IHg6IDYsIHk6IDMgfSwgLy8gVG9wIHJpZ2h0IGRpYWdvbmFsXG4gICAgXTtcbiAgICBcbiAgICAvLyBTZXQgYWN0aXZlIG5vZGVzXG4gICAgcGF0dGVybi5mb3JFYWNoKCh7eCwgeX0pID0+IHtcbiAgICAgIGlmICh4ID49IDAgJiYgeCA8IGNvbnRyb2xzLkdSSURfV0lEVEggJiYgeSA+PSAwICYmIHkgPCBjb250cm9scy5HUklEX0hFSUdIVCkge1xuICAgICAgICBjb25zdCBpbmRleCA9IGdldEluZGV4KHksIHgsIGNvbnRyb2xzLkdSSURfV0lEVEgpO1xuICAgICAgICBuZXdBY3RpdmF0aW9uU3RhdGVbaW5kZXhdID0gMS4wO1xuICAgICAgICBjb25zb2xlLmxvZyhgU2V0dGluZyBhY3RpdmUgbm9kZSBhdCAoJHt4fSwgJHt5fSksIGluZGV4OiAke2luZGV4fWApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIC8vIENyZWF0ZSBjb25uZWN0b3JzXG4gICAgY29uc3QgbmV3SW50ZW5kZWRDb25uZWN0b3JzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge1xuICAgICAgLy8gRGlhZ29uYWwgY29ubmVjdGlvbnMgLSB0aGV5IHVzZSBib3R0b20tbGVmdCBjb29yZGluYXRlcyBvZiB0aGUgMngyIGdyb3VwXG4gICAgICBcIjUsMlwiOiBDT05ORUNUT1JfRElBR19CTF9UUiwgLy8gRGlhZ29uYWwgZnJvbSAoNSwzKSB0byAoNiwyKSAtIHRvcFxuICAgICAgXCI0LDVcIjogQ09OTkVDVE9SX0RJQUdfQkxfVFIsIC8vIERpYWdvbmFsIGZyb20gKDQsNSkgdG8gKDUsNikgLSBib3R0b20gbGVmdFxuICAgICAgXCI1LDVcIjogQ09OTkVDVE9SX0RJQUdfVExfQlIgIC8vIERpYWdvbmFsIGZyb20gKDUsNikgdG8gKDYsNSkgLSBib3R0b20gcmlnaHRcbiAgICB9O1xuICAgIFxuICAgIC8vIENyZWF0ZSBjbWQtaG9yaXogY29ubmVjdG9ycyAtIHRoZXNlIGNvbm5lY3QgZG90cyBob3Jpem9udGFsbHkgd2l0aCBjbWQtY2xpY2tcbiAgICBjb25zdCBuZXdDbWRIb3JpekNvbm5lY3RvcnM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7XG4gICAgICAvLyBNaWRkbGUgcm93IGhvcml6b250YWwgY29ubmVjdG9yXG4gICAgICBbXCJoY21kOjQsNFwiXTogMSAgLy8gSG9yaXpvbnRhbCBjb25uZWN0b3IgZnJvbSAoNCw0KSB0byAoNSw0KVxuICAgIH07XG4gICAgXG4gICAgLy8gTG9nIGRldGFpbHMgb2YgdGhlIHRlc3QgcGF0dGVyblxuICAgIGNvbnNvbGUubG9nKFwiVGVzdCBwYXR0ZXJuIGRldGFpbHM6XCIpO1xuICAgIGNvbnNvbGUubG9nKFwiLSBUb3RhbCBhY3RpdmUgbm9kZXM6XCIsIHBhdHRlcm4ubGVuZ3RoKTtcbiAgICBcbiAgICAvLyBMb2cgZGlhZ29uYWwgY29ubmVjdG9yIGRldGFpbHMgXG4gICAgT2JqZWN0LmVudHJpZXMobmV3SW50ZW5kZWRDb25uZWN0b3JzKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIGNvbnN0IHR5cGUgPSB2YWx1ZSA9PT0gQ09OTkVDVE9SX0RJQUdfQkxfVFIgPyBcImRpYWdvbmFsIEJMLVRSICgvKVwiIDogXG4gICAgICAgICAgICAgICAgICAgdmFsdWUgPT09IENPTk5FQ1RPUl9ESUFHX1RMX0JSID8gXCJkaWFnb25hbCBUTC1CUiAoXFxcXClcIiA6IFxuICAgICAgICAgICAgICAgICAgIGB1bmtub3duIHR5cGUgJHt2YWx1ZX1gO1xuICAgICAgY29uc29sZS5sb2coYC0gRGlhZ29uYWwgY29ubmVjdG9yIGF0ICR7a2V5fTogJHt0eXBlfSAodmFsdWU6ICR7dmFsdWV9KWApO1xuICAgIH0pO1xuICAgIFxuICAgIC8vIExvZyBjbWQtaG9yaXogY29ubmVjdG9yIGRldGFpbHNcbiAgICBPYmplY3QuZW50cmllcyhuZXdDbWRIb3JpekNvbm5lY3RvcnMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgaWYgKHZhbHVlID09PSAxKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGAtIENtZC1ob3JpeiBjb25uZWN0b3IgYXQgJHtrZXkuc3Vic3RyaW5nKDUpfTogYWN0aXZlYCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgLy8gU2V0IHN0YXRlc1xuICAgIGNvbnNvbGUubG9nKFwiU2V0dGluZyBhY3RpdmF0aW9uIHN0YXRlLCBpbnRlbmRlZCBjb25uZWN0b3JzLCBhbmQgY21kLWhvcml6IGNvbm5lY3RvcnMuLi5cIik7XG4gICAgc2V0QWN0aXZhdGlvblN0YXRlKG5ld0FjdGl2YXRpb25TdGF0ZSk7XG4gICAgc2V0SW50ZW5kZWRDb25uZWN0b3JzKG5ld0ludGVuZGVkQ29ubmVjdG9ycyk7XG4gICAgc2V0Q21kSG9yaXpDb25uZWN0b3JzKG5ld0NtZEhvcml6Q29ubmVjdG9ycyk7XG4gICAgXG4gICAgY29uc29sZS5sb2coXCJUZXN0IHBhdHRlcm4gY3JlYXRlZFwiKTtcbiAgICBcbiAgICAvLyBBZGQgY2hlY2sgYWZ0ZXIgc21hbGwgZGVsYXkgdG8gdmVyaWZ5IHN0YXRlIHdhcyB1cGRhdGVkXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZyhcIlZlcmlmaWNhdGlvbiBvZiBzdGF0ZSB1cGRhdGU6XCIpO1xuICAgICAgY29uc29sZS5sb2coXCItIGludGVuZGVkQ29ubmVjdG9yczpcIiwgaW50ZW5kZWRDb25uZWN0b3JzKTtcbiAgICAgIGNvbnNvbGUubG9nKFwiLSBub256ZXJvIGludGVuZGVkQ29ubmVjdG9yczpcIiwgT2JqZWN0LmVudHJpZXMoaW50ZW5kZWRDb25uZWN0b3JzKS5maWx0ZXIoKFtfLCB2XSkgPT4gdiAhPT0gQ09OTkVDVE9SX05PTkUpKTtcbiAgICAgIGNvbnNvbGUubG9nKFwiLSBjbWRIb3JpekNvbm5lY3RvcnM6XCIsIGNtZEhvcml6Q29ubmVjdG9ycyk7XG4gICAgICBjb25zb2xlLmxvZyhcIi0gYWN0aXZlIGNtZEhvcml6Q29ubmVjdG9yczpcIiwgT2JqZWN0LmVudHJpZXMoY21kSG9yaXpDb25uZWN0b3JzKS5maWx0ZXIoKFtfLCB2XSkgPT4gdiA9PT0gMSkpO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiBvdXIgZXhwZWN0YXRpb24gbWF0Y2hlcyByZWFsaXR5XG4gICAgICBjb25zdCBhbGxDb25uZWN0b3JzTWF0Y2ggPSBcbiAgICAgICAgT2JqZWN0LmtleXMobmV3SW50ZW5kZWRDb25uZWN0b3JzKS5sZW5ndGggPT09IFxuICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGludGVuZGVkQ29ubmVjdG9ycykuZmlsdGVyKChbXywgdl0pID0+IHYgIT09IENPTk5FQ1RPUl9OT05FKS5sZW5ndGggJiZcbiAgICAgICAgT2JqZWN0LmtleXMobmV3Q21kSG9yaXpDb25uZWN0b3JzKS5maWx0ZXIoayA9PiBuZXdDbWRIb3JpekNvbm5lY3RvcnNba10gPT09IDEpLmxlbmd0aCA9PT1cbiAgICAgICAgICBPYmplY3QuZW50cmllcyhjbWRIb3JpekNvbm5lY3RvcnMpLmZpbHRlcigoW18sIHZdKSA9PiB2ID09PSAxKS5sZW5ndGg7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKFwiQWxsIGNvbm5lY3RvcnMgc2V0IGNvcnJlY3RseTpcIiwgYWxsQ29ubmVjdG9yc01hdGNoID8gXCJZRVNcIiA6IFwiTk9cIik7XG4gICAgfSwgMTAwKTtcbiAgICBcbiAgICAvLyBBdXRvbWF0aWNhbGx5IHRyaWdnZXIgY3VzdG9tIHNhdmUgYWZ0ZXIgYSBkZWxheVxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgY29uc29sZS5sb2coXCI9PT09PT09PT09IEFVVE8tU0FWRSBURVNUIFBBVFRFUk4gU1RBUlQgPT09PT09PT09PVwiKTtcbiAgICAgIGNvbnNvbGUubG9nKFwiQXV0by1zYXZpbmcgdGVzdCBwYXR0ZXJuIHdpdGggZGlyZWN0IHJlZmVyZW5jZSB0byBuZXcgc3RhdGVzLi4uXCIpO1xuICAgICAgXG4gICAgICAvLyBHZXQgdGhlIENVUlJFTlQgc3RhdGUgYXQgdGhlIG1vbWVudCBvZiBhdXRvLXNhdmVcbiAgICAgIGNvbnN0IGN1cnJlbnRDb250cm9scyA9IHsgLi4uY29udHJvbHMgfTsgLy8gTWFrZSBhIGZyZXNoIGNvcHkgb2YgdGhlIGNvbnRyb2xzIG9iamVjdFxuICAgICAgY29uc29sZS5sb2coYEN1cnJlbnQgY29udHJvbHMgZGltZW5zaW9uczogJHtjdXJyZW50Q29udHJvbHMuR1JJRF9XSURUSH14JHtjdXJyZW50Q29udHJvbHMuR1JJRF9IRUlHSFR9YCk7XG4gICAgICBcbiAgICAgIC8vIEdldCB0aGUgY3VycmVudCBhY3RpdmF0aW9uIHN0YXRlIGRpcmVjdGx5IGZyb20gdGhlIGJ1ZmZlciBhdHRyaWJ1dGVcbiAgICAgIGxldCBjdXJyZW50QWN0aXZhdGlvbjogRmxvYXQzMkFycmF5O1xuICAgICAgaWYgKGFjdGl2YXRpb25BdHRyaWJ1dGVSZWYuY3VycmVudCAmJiBhY3RpdmF0aW9uQXR0cmlidXRlUmVmLmN1cnJlbnQuYXJyYXkpIHtcbiAgICAgICAgY3VycmVudEFjdGl2YXRpb24gPSBhY3RpdmF0aW9uQXR0cmlidXRlUmVmLmN1cnJlbnQuYXJyYXkgYXMgRmxvYXQzMkFycmF5O1xuICAgICAgICBjb25zb2xlLmxvZyhcIi0gVXNpbmcgYWN0aXZhdGlvbiBzdGF0ZSBmcm9tIGJ1ZmZlciBhdHRyaWJ1dGVcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50QWN0aXZhdGlvbiA9IGFjdGl2YXRpb25TdGF0ZTtcbiAgICAgICAgY29uc29sZS5sb2coXCItIFVzaW5nIGFjdGl2YXRpb24gc3RhdGUgZnJvbSBSZWFjdCBzdGF0ZSAoZmFsbGJhY2spXCIpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBVc2UgdGhlIHJlZiB2YWx1ZXMgd2hpY2ggc2hvdWxkIGhhdmUgdGhlIG1vc3QgdXAtdG8tZGF0ZSBzdGF0ZVxuICAgICAgY29uc3QgY3VycmVudEludGVuZGVkQ29ubmVjdG9ycyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoaW50ZW5kZWRDb25uZWN0b3JzUmVmLmN1cnJlbnQgfHwge30pKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRDbWRIb3JpekNvbm5lY3RvcnMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGNtZEhvcml6Q29ubmVjdG9yc1JlZi5jdXJyZW50IHx8IHt9KSk7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKFwiUmVmIHZhbHVlcyBmb3IgY29ubmVjdG9yczpcIiwge1xuICAgICAgICBpbnRlbmRlZDogY3VycmVudEludGVuZGVkQ29ubmVjdG9ycyxcbiAgICAgICAgY21kSG9yaXo6IGN1cnJlbnRDbWRIb3JpekNvbm5lY3RvcnNcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBTYXZlIHVzaW5nIGRpcmVjdCB2YWx1ZXMgd2l0aCBjdXJyZW50IGRpbWVuc2lvbnNcbiAgICAgIHNhdmVHcmlkU3RhdGVXaXRoRGlyZWN0VmFsdWVzKFxuICAgICAgICBjdXJyZW50QWN0aXZhdGlvbixcbiAgICAgICAgY3VycmVudEludGVuZGVkQ29ubmVjdG9ycyxcbiAgICAgICAgY3VycmVudENtZEhvcml6Q29ubmVjdG9ycyxcbiAgICAgICAgY3VycmVudENvbnRyb2xzLkdSSURfV0lEVEgsXG4gICAgICAgIGN1cnJlbnRDb250cm9scy5HUklEX0hFSUdIVFxuICAgICAgKTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coXCI9PT09PT09PT09IEFVVE8tU0FWRSBURVNUIFBBVFRFUk4gRU5EID09PT09PT09PT1cIik7XG4gICAgfSwgNTAwKTsgLy8gNTAwbXMgZGVsYXkgc2hvdWxkIGJlIHN1ZmZpY2llbnRcbiAgICBcbiAgICBjb25zb2xlLmxvZyhcIj09PT09PT09PT0gVEVTVCBQQVRURVJOIENSRUFUSU9OIEVORCA9PT09PT09PT09XCIpO1xuICB9LCBbVE9UQUxfQ0lSQ0xFUywgY29udHJvbHMsIHNldEFjdGl2YXRpb25TdGF0ZSwgc2V0SW50ZW5kZWRDb25uZWN0b3JzLCBzZXRDbWRIb3JpekNvbm5lY3RvcnMsIGludGVuZGVkQ29ubmVjdG9ycywgY21kSG9yaXpDb25uZWN0b3JzXSk7XG4gIFxuICAvLyBEZWJ1ZyBmdW5jdGlvbiB0byBjbGVhciBldmVyeXRoaW5nXG4gIGNvbnN0IGNsZWFyQWxsID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKFwiQ2xlYXJpbmcgYWxsIHN0YXRlXCIpO1xuICAgIHNldEFjdGl2YXRpb25TdGF0ZShuZXcgRmxvYXQzMkFycmF5KFRPVEFMX0NJUkNMRVMpLmZpbGwoMC4wKSk7XG4gICAgc2V0SW50ZW5kZWRDb25uZWN0b3JzKHt9KTtcbiAgICBzZXRDbWRIb3JpekNvbm5lY3RvcnMoe30pO1xuICAgIFxuICAgIC8vIEFsc28gY2xlYXIgdGhlIHJlZnNcbiAgICBpbnRlbmRlZENvbm5lY3RvcnNSZWYuY3VycmVudCA9IHt9O1xuICAgIGNtZEhvcml6Q29ubmVjdG9yc1JlZi5jdXJyZW50ID0ge307XG4gIH0sIFtUT1RBTF9DSVJDTEVTLCBzZXRBY3RpdmF0aW9uU3RhdGUsIHNldEludGVuZGVkQ29ubmVjdG9ycywgc2V0Q21kSG9yaXpDb25uZWN0b3JzXSk7XG4gIFxuICAvLyBOb3cgdGhhdCB3ZSd2ZSBkZWZpbmVkIHRoZSBkZWJ1ZyBmdW5jdGlvbnMsIGFkZCB0aGUgZGVidWcgY29udHJvbHNcbiAgdXNlQ29udHJvbHMoJ0RlYnVnJywgKCkgPT4gKHtcbiAgICBjcmVhdGVUZXN0UGF0dGVybjogYnV0dG9uKCgpID0+IGNyZWF0ZVRlc3RQYXR0ZXJuKCkpLFxuICAgIGNsZWFyQWxsOiBidXR0b24oKCkgPT4gY2xlYXJBbGwoKSksXG4gICAgZGlyZWN0U2F2ZTogYnV0dG9uKCgpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKFwiRGlyZWN0IHNhdmUgdHJpZ2dlcmVkIG1hbnVhbGx5XCIpO1xuICAgICAgXG4gICAgICAvLyBHZXQgdGhlIENVUlJFTlQgc3RhdGUgYXQgdGhlIG1vbWVudCB0aGUgYnV0dG9uIGlzIGNsaWNrZWRcbiAgICAgIGNvbnN0IGN1cnJlbnRDb250cm9scyA9IHsgLi4uY29udHJvbHMgfTsgLy8gTWFrZSBhIGZyZXNoIGNvcHkgb2YgdGhlIGNvbnRyb2xzIG9iamVjdFxuICAgICAgY29uc29sZS5sb2coYEN1cnJlbnQgY29udHJvbHMgZGltZW5zaW9uczogJHtjdXJyZW50Q29udHJvbHMuR1JJRF9XSURUSH14JHtjdXJyZW50Q29udHJvbHMuR1JJRF9IRUlHSFR9YCk7XG4gICAgICBcbiAgICAgIC8vIEdldCB0aGUgY3VycmVudCBhY3RpdmF0aW9uIHN0YXRlIGRpcmVjdGx5IGZyb20gdGhlIGJ1ZmZlciBhdHRyaWJ1dGVcbiAgICAgIGxldCBjdXJyZW50QWN0aXZhdGlvbjogRmxvYXQzMkFycmF5O1xuICAgICAgaWYgKGFjdGl2YXRpb25BdHRyaWJ1dGVSZWYuY3VycmVudCAmJiBhY3RpdmF0aW9uQXR0cmlidXRlUmVmLmN1cnJlbnQuYXJyYXkpIHtcbiAgICAgICAgY3VycmVudEFjdGl2YXRpb24gPSBhY3RpdmF0aW9uQXR0cmlidXRlUmVmLmN1cnJlbnQuYXJyYXkgYXMgRmxvYXQzMkFycmF5O1xuICAgICAgICBjb25zb2xlLmxvZyhcIi0gVXNpbmcgYWN0aXZhdGlvbiBzdGF0ZSBmcm9tIGJ1ZmZlciBhdHRyaWJ1dGVcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50QWN0aXZhdGlvbiA9IGFjdGl2YXRpb25TdGF0ZTtcbiAgICAgICAgY29uc29sZS5sb2coXCItIFVzaW5nIGFjdGl2YXRpb24gc3RhdGUgZnJvbSBSZWFjdCBzdGF0ZSAoZmFsbGJhY2spXCIpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBVc2UgdGhlIHJlZiB2YWx1ZXMgd2hpY2ggc2hvdWxkIGhhdmUgdGhlIG1vc3QgdXAtdG8tZGF0ZSBzdGF0ZVxuICAgICAgY29uc3QgY3VycmVudEludGVuZGVkQ29ubmVjdG9ycyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoaW50ZW5kZWRDb25uZWN0b3JzUmVmLmN1cnJlbnQgfHwge30pKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRDbWRIb3JpekNvbm5lY3RvcnMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGNtZEhvcml6Q29ubmVjdG9yc1JlZi5jdXJyZW50IHx8IHt9KSk7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKFwiUmVmIHZhbHVlcyBmb3IgY29ubmVjdG9yczpcIiwge1xuICAgICAgICBpbnRlbmRlZDogY3VycmVudEludGVuZGVkQ29ubmVjdG9ycyxcbiAgICAgICAgY21kSG9yaXo6IGN1cnJlbnRDbWRIb3JpekNvbm5lY3RvcnNcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBTYXZlIHVzaW5nIGRpcmVjdCB2YWx1ZXMgd2l0aCBjdXJyZW50IGRpbWVuc2lvbnNcbiAgICAgIHNhdmVHcmlkU3RhdGVXaXRoRGlyZWN0VmFsdWVzKFxuICAgICAgICBjdXJyZW50QWN0aXZhdGlvbixcbiAgICAgICAgY3VycmVudEludGVuZGVkQ29ubmVjdG9ycyxcbiAgICAgICAgY3VycmVudENtZEhvcml6Q29ubmVjdG9ycyxcbiAgICAgICAgY3VycmVudENvbnRyb2xzLkdSSURfV0lEVEgsXG4gICAgICAgIGN1cnJlbnRDb250cm9scy5HUklEX0hFSUdIVFxuICAgICAgKTtcbiAgICB9KVxuICB9KSk7XG5cbiAgcmV0dXJuIChcbiAgICA8Z3JvdXA+XG4gICAgICA8aW5zdGFuY2VkTWVzaCBcbiAgICAgICAgcmVmPXttZXNoUmVmfSBcbiAgICAgICAgYXJncz17W3VuZGVmaW5lZCwgdW5kZWZpbmVkLCBUT1RBTF9DSVJDTEVTXX1cbiAgICAgICAga2V5PXtgY2lyY2xlcy0ke1RPVEFMX0NJUkNMRVN9YH1cbiAgICAgICAgb25DbGljaz17aGFuZGxlQ2lyY2xlQ2xpY2t9IC8vIEF0dGFjaCBjbGljayBoYW5kbGVyXG4gICAgICAgIHBvc2l0aW9uPXtbMCwgMCwgLTAuMV19IC8vIFBvc2l0aW9uIGNpcmNsZXMgYmVoaW5kIGNvbm5lY3RvcnNcbiAgICAgID5cbiAgICAgICAgey8qIFBhc3MgYXJncyBkaXJlY3RseSB0byBmaXggVHlwZVNjcmlwdCBlcnJvciAqL31cbiAgICAgICAgPHBsYW5lR2VvbWV0cnkgYXJncz17WzEsIDFdfT4gXG4gICAgICAgICAgey8qIEF0dGFjaCB0aGUgaW5zdGFuY2VkIGJ1ZmZlciBhdHRyaWJ1dGUgZm9yIGFjdGl2YXRpb24gc3RhdGUgKi99XG4gICAgICAgICAgPGluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZVxuICAgICAgICAgICAgcmVmPXthY3RpdmF0aW9uQXR0cmlidXRlUmVmfVxuICAgICAgICAgICAgYXR0YWNoPVwiYXR0cmlidXRlcy1hX2FjdGl2YXRlZFwiXG4gICAgICAgICAgICBhcmdzPXtbYWN0aXZhdGlvblN0YXRlLCAxXX0gLy8gUGFzcyBpbml0aWFsIHN0YXRlLCBpdGVtIHNpemUgMVxuICAgICAgICAgICAgdXNhZ2U9e1RIUkVFLkR5bmFtaWNEcmF3VXNhZ2V9IC8vIE1hcmsgYXMgZHluYW1pY1xuICAgICAgICAgIC8+XG4gICAgICAgIDwvcGxhbmVHZW9tZXRyeT4gXG4gICAgICAgIDxjaXJjbGVNYXRlcmlhbCBcbiAgICAgICAgICAgIHJlZj17bWF0ZXJpYWxSZWZ9IFxuICAgICAgICAgICAgdHJhbnNwYXJlbnQ9e3RydWV9IFxuICAgICAgICAgICAga2V5PXtDaXJjbGVNYXRlcmlhbC5rZXl9IC8vIEFkZCBrZXkgZm9yIG1hdGVyaWFsIGhvdHN3YXBwaW5nIGlmIG5lZWRlZFxuICAgICAgICAvPlxuICAgICAgPC9pbnN0YW5jZWRNZXNoPlxuXG4gICAgICB7LyogTWFpbiBDb25uZWN0b3IgUGxhbmUgKEV4aXN0aW5nKSAqL31cbiAgICAgIDxtZXNoXG4gICAgICAgIHBvc2l0aW9uPXtbMCwgMCwgMC4xXX0gLy8gS2VlcCB0aGlzIHNsaWdodGx5IGluIGZyb250IG9mIGNpcmNsZXNcbiAgICAgICAga2V5PXtgY29ubmVjdG9yLXBsYW5lLSR7Y29udHJvbHMuR1JJRF9XSURUSH0tJHtjb250cm9scy5HUklEX0hFSUdIVH0tJHtjb250cm9scy52aXN1YWxTY2FsZX1gfVxuICAgICAgICBvbkNsaWNrPXtoYW5kbGVDb25uZWN0b3JDbGlja30gXG4gICAgICA+XG4gICAgICAgIDxwbGFuZUdlb21ldHJ5IGFyZ3M9e1twbGFuZVdpZHRoLCBwbGFuZUhlaWdodF19IC8+XG4gICAgICAgIDxjb25uZWN0b3JNYXRlcmlhbCBcbiAgICAgICAgICByZWY9e2Nvbm5lY3Rvck1hdGVyaWFsUmVmfVxuICAgICAgICAgIGtleT17Q29ubmVjdG9yTWF0ZXJpYWwua2V5fVxuICAgICAgICAgIHRyYW5zcGFyZW50PXt0cnVlfSBcbiAgICAgICAgICBzaWRlPXtUSFJFRS5Eb3VibGVTaWRlfSBcbiAgICAgICAgICAvLyBQYXNzIHJlcXVpcmVkIHVuaWZvcm1zIChjbWRIb3JpeiB0ZXh0dXJlIHJlbW92ZWQpXG4gICAgICAgICAgdV9zdGF0ZVRleHR1cmU9e3N0YXRlVGV4dHVyZX0gXG4gICAgICAgICAgdV9pbnRlbmRlZENvbm5lY3RvclRleHR1cmU9e2ludGVuZGVkQ29ubmVjdG9yVGV4dHVyZX1cbiAgICAgICAgICAvLyB1X2NtZEhvcml6Q29ubmVjdG9yVGV4dHVyZSByZW1vdmVkXG4gICAgICAgICAgdV9ncmlkRGltZW5zaW9ucz17W2NvbnRyb2xzLkdSSURfV0lEVEgsIGNvbnRyb2xzLkdSSURfSEVJR0hUXX1cbiAgICAgICAgICB1X3RleHR1cmVSZXNvbHV0aW9uPXtbY29udHJvbHMuR1JJRF9XSURUSCwgY29udHJvbHMuR1JJRF9IRUlHSFRdfSBcbiAgICAgICAgICB1X3JhZGl1c0E9e0JBU0VfUkFESVVTX0F9XG4gICAgICAgICAgdV9yYWRpdXNCPXtCQVNFX1JBRElVU19CfVxuICAgICAgICAgIHVfZ3JpZFNwYWNpbmc9e2NvbnRyb2xzLnZpc3VhbFNjYWxlfVxuICAgICAgICAgIHVfY2VudGVyT2Zmc2V0PXtbY2VudGVyT2Zmc2V0LngsIGNlbnRlck9mZnNldC55XX1cbiAgICAgICAgICB1X3BsYW5lU2l6ZT17W3BsYW5lV2lkdGgsIHBsYW5lSGVpZ2h0XX1cbiAgICAgICAgLz5cbiAgICAgIDwvbWVzaD5cblxuICAgICAgey8qIE5ldyBDbWQtQ2xpY2sgSG9yaXpvbnRhbCBDb25uZWN0b3IgUGxhbmUgKi99XG4gICAgICA8bWVzaFxuICAgICAgICBwb3NpdGlvbj17WzAsIDAsIDAuMl19IC8vIFBvc2l0aW9uIHRoaXMgc2xpZ2h0bHkgaW4gZnJvbnQgb2YgdGhlIG1haW4gY29ubmVjdG9yc1xuICAgICAgICBrZXk9e2BjbWQtaG9yaXotY29ubmVjdG9yLXBsYW5lLSR7Y29udHJvbHMuR1JJRF9XSURUSH0tJHtjb250cm9scy5HUklEX0hFSUdIVH0tJHtjb250cm9scy52aXN1YWxTY2FsZX1gfVxuICAgICAgICAvLyBObyBjbGljayBoYW5kbGVyIG5lZWRlZCBoZXJlLCBpbnRlcmFjdGlvbiBpcyB2aWEgY2lyY2xlc1xuICAgICAgPlxuICAgICAgICB7LyogVXNlIHRoZSBzYW1lIHBsYW5lIGdlb21ldHJ5IGRpbWVuc2lvbnMgKi99XG4gICAgICAgIDxwbGFuZUdlb21ldHJ5IGFyZ3M9e1twbGFuZVdpZHRoLCBwbGFuZUhlaWdodF19IC8+IFxuICAgICAgICA8Y21kSG9yaXpDb25uZWN0b3JNYXRlcmlhbFxuICAgICAgICAgIHJlZj17Y21kSG9yaXpNYXRlcmlhbFJlZn1cbiAgICAgICAgICBrZXk9e0NtZEhvcml6Q29ubmVjdG9yTWF0ZXJpYWwua2V5fVxuICAgICAgICAgIHRyYW5zcGFyZW50PXt0cnVlfVxuICAgICAgICAgIHNpZGU9e1RIUkVFLkRvdWJsZVNpZGV9XG4gICAgICAgICAgLy8gUGFzcyBuZWNlc3NhcnkgdW5pZm9ybXMgZm9yIHRoaXMgc3BlY2lmaWMgbWF0ZXJpYWxcbiAgICAgICAgICB1X3N0YXRlVGV4dHVyZT17c3RhdGVUZXh0dXJlfSAgICAgICAgICAgICAgICAgLy8gTmVlZCBmb3IgY2hlY2tpbmcgYWN0aXZlIGNpcmNsZXNcbiAgICAgICAgICB1X2NtZEhvcml6Q29ubmVjdG9yVGV4dHVyZT17Y21kSG9yaXpDb25uZWN0b3JUZXh0dXJlfSAvLyBUaGUgdGV4dHVyZSB3aXRoIGNtZC1ob3JpeiBzdGF0ZVxuICAgICAgICAgIHVfZ3JpZERpbWVuc2lvbnM9e1tjb250cm9scy5HUklEX1dJRFRILCBjb250cm9scy5HUklEX0hFSUdIVF19ICAvLyBHcmlkIGRpbWVuc2lvbnNcbiAgICAgICAgICB1X3RleHR1cmVSZXNvbHV0aW9uPXtbY29udHJvbHMuR1JJRF9XSURUSCwgY29udHJvbHMuR1JJRF9IRUlHSFRdfSAvLyBTdGF0ZSB0ZXh0dXJlIHJlc29sdXRpb25cbiAgICAgICAgICB1X3JhZGl1c0E9e0JBU0VfUkFESVVTX0F9ICAgICAgICAgICAgICAgICAgICAgLy8gQmFzZSByYWRpaVxuICAgICAgICAgIHVfcmFkaXVzQj17QkFTRV9SQURJVVNfQn1cbiAgICAgICAgICB1X2dyaWRTcGFjaW5nPXtjb250cm9scy52aXN1YWxTY2FsZX0gICAgICAgICAgICAgICAgICAgLy8gQ3VycmVudCB2aXN1YWwgc2NhbGVcbiAgICAgICAgICB1X2ZpeGVkU3BhY2luZz17RklYRURfU1BBQ0lOR30gICAgICAgICAgICAgICAgLy8gUGFzcyB0aGUgYmFzZSBmaXhlZCBzcGFjaW5nXG4gICAgICAgICAgdV9jZW50ZXJPZmZzZXQ9e1tjZW50ZXJPZmZzZXQueCwgY2VudGVyT2Zmc2V0LnldfSAvLyBHcmlkIG9mZnNldFxuICAgICAgICAgIHVfcGxhbmVTaXplPXtbcGxhbmVXaWR0aCwgcGxhbmVIZWlnaHRdfSAgICAgICAvLyBQbGFuZSBkaW1lbnNpb25zXG4gICAgICAgIC8+XG4gICAgICA8L21lc2g+XG5cbiAgICA8L2dyb3VwPlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgR3JpZFNjZW5lOyAiXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VNZW1vIiwidXNlUmVmIiwidXNlRWZmZWN0IiwidXNlU3RhdGUiLCJ1c2VDYWxsYmFjayIsIlRIUkVFIiwidXNlQ29udHJvbHMiLCJidXR0b24iLCJmb2xkZXIiLCJ1c2VGcmFtZSIsIkNpcmNsZU1hdGVyaWFsIiwiQ29ubmVjdG9yTWF0ZXJpYWwiLCJDbWRIb3JpekNvbm5lY3Rvck1hdGVyaWFsIiwiRklYRURfU1BBQ0lORyIsIkJBU0VfUkFESVVTX0EiLCJCQVNFX1JBRElVU19CIiwiQ09OTkVDVE9SX05PTkUiLCJDT05ORUNUT1JfRElBR19UTF9CUiIsIkNPTk5FQ1RPUl9ESUFHX0JMX1RSIiwiQ09OTkVDVE9SX0hPUklaX1QiLCJDT05ORUNUT1JfSE9SSVpfQiIsIkJBU0VfR1JJRF9TUEFDSU5HIiwiZ2V0SW5kZXgiLCJyb3ciLCJjb2wiLCJncmlkV2lkdGgiLCJnZXRDb29yZHMiLCJpbmRleCIsIk1hdGgiLCJmbG9vciIsImdldENlbnRlck9mZnNldCIsImdyaWRIZWlnaHQiLCJzcGFjaW5nIiwidG90YWxXaWR0aCIsInRvdGFsSGVpZ2h0IiwiVmVjdG9yMiIsImdldFdvcmxkUG9zaXRpb24iLCJjZW50ZXJPZmZzZXQiLCJ4IiwieSIsImR1bW15IiwiT2JqZWN0M0QiLCJ0ZW1wTWF0cml4IiwiTWF0cml4NCIsInRlbXBWZWMiLCJWZWN0b3IzIiwiZ2V0SG9yaXpDbWRDb25uZWN0b3JLZXkiLCJnZXRDZWxsR3JvdXBLZXkiLCJjZWxsWCIsImNlbGxZIiwiR3JpZFNjZW5lIiwiY29udHJvbHMiLCJzZXRMZXZhQ29udHJvbCIsIkdSSURfV0lEVEgiLCJ2YWx1ZSIsIm1pbiIsIm1heCIsInN0ZXAiLCJHUklEX0hFSUdIVCIsInZpc3VhbFNjYWxlIiwibGFiZWwiLCJzYXZlU3RhdGUiLCJjb25zb2xlIiwibG9nIiwiY3VycmVudENvbnRyb2xzIiwiY3VycmVudEFjdGl2YXRpb24iLCJhY3RpdmF0aW9uQXR0cmlidXRlUmVmIiwiY3VycmVudCIsImFycmF5IiwiYWN0aXZhdGlvblN0YXRlIiwiY3VycmVudEludGVuZGVkQ29ubmVjdG9ycyIsIkpTT04iLCJwYXJzZSIsInN0cmluZ2lmeSIsImludGVuZGVkQ29ubmVjdG9yc1JlZiIsImN1cnJlbnRDbWRIb3JpekNvbm5lY3RvcnMiLCJjbWRIb3JpekNvbm5lY3RvcnNSZWYiLCJpbnRlbmRlZCIsImNtZEhvcml6Iiwic2F2ZUdyaWRTdGF0ZVdpdGhEaXJlY3RWYWx1ZXMiLCJsb2FkU3RhdGUiLCJqc29uSW5wdXQiLCJwcm9tcHQiLCJkYXRhIiwiQXJyYXkiLCJpc0FycmF5Iiwibm9kZXMiLCJlZGdlcyIsIkVycm9yIiwibGVuZ3RoIiwic2V0VGltZW91dCIsIm5ld1RvdGFsQ2lyY2xlcyIsIm5ld0FjdGl2YXRpb25TdGF0ZSIsIkZsb2F0MzJBcnJheSIsImZpbGwiLCJmb3JFYWNoIiwibm9kZSIsIndhcm4iLCJuZXdJbnRlbmRlZENvbm5lY3RvcnMiLCJuZXdDbWRIb3JpekNvbm5lY3RvcnMiLCJlZGdlIiwiY29ubmVjdG9yVHlwZSIsImlzVmFsaWQiLCJ0eXBlIiwia2V5IiwiT2JqZWN0IiwidmFsdWVzIiwiZmlsdGVyIiwidiIsInNldEFjdGl2YXRpb25TdGF0ZSIsImtleXMiLCJzZXRJbnRlbmRlZENvbm5lY3RvcnMiLCJzZXRDbWRIb3JpekNvbm5lY3RvcnMiLCJlbnRyaWVzIiwiaW50ZW5kZWRDb25uZWN0b3JzIiwiXyIsImNtZEhvcml6Q29ubmVjdG9ycyIsImVycm9yIiwiYWxlcnQiLCJtZXNzYWdlIiwiU3RyaW5nIiwiVE9UQUxfQ0lSQ0xFUyIsInBsYW5lV2lkdGgiLCJwbGFuZUhlaWdodCIsInRvdGFsIiwib2Zmc2V0Iiwid2lkdGgiLCJoZWlnaHQiLCJtZXNoUmVmIiwibWF0ZXJpYWxSZWYiLCJjb25uZWN0b3JNYXRlcmlhbFJlZiIsImNtZEhvcml6TWF0ZXJpYWxSZWYiLCJnZXRJbnRlbmRlZENvbm5lY3RvciIsIm5lZWRzVXBkYXRlIiwicG9zaXRpb24iLCJzZXQiLCJjdXJyZW50TWF0cml4IiwiZ2V0TWF0cml4QXQiLCJxdWF0ZXJuaW9uIiwiUXVhdGVybmlvbiIsInNjYWxlVmVjIiwiZGVjb21wb3NlIiwibWF0cml4IiwiY29tcG9zZSIsInNldE1hdHJpeEF0IiwiaW5zdGFuY2VNYXRyaXgiLCJ1bmlmb3JtcyIsInVfcmFkaXVzQSIsInVfcmFkaXVzQiIsInNjYWxlIiwidG9GaXhlZCIsInNldEZyb21NYXRyaXhQb3NpdGlvbiIsInNldEZyb21Sb3RhdGlvbk1hdHJpeCIsImhhbmRsZUNpcmNsZUNsaWNrIiwiZXZlbnQiLCJzdG9wUHJvcGFnYXRpb24iLCJpbnN0YW5jZUlkIiwidW5kZWZpbmVkIiwiaXNDbWRDbGljayIsIm1ldGFLZXkiLCJjdHJsS2V5IiwicG9pbnQiLCJjdXJyZW50U3RhdGUiLCJpbnN0YW5jZUNlbnRlciIsImRpc3RGcm9tQ2VudGVyIiwiZGlzdGFuY2VUbyIsImN1cnJlbnRJbm5lclJhZGl1cyIsImlzSW5zaWRlIiwicmlnaHRJbmRleCIsImNhbkNvbm5lY3RCYXNlIiwiY29ubmVjdG9yQmVsb3ciLCJjb25uZWN0b3JBZGphY2VudCIsImlzQmxvY2tlZEJ5RGlhZ29uYWwiLCJsZWZ0QWN0aXZlIiwicmlnaHRBY3RpdmUiLCJjb25uZWN0b3JLZXkiLCJwcmV2IiwibmV3VmFsdWUiLCJuZXdTdGF0ZSIsImFsbENvbm5lY3RvcnMiLCJhY3RpdmVDb25uZWN0b3JzIiwib2xkVmFsdWUiLCJzdGF0ZVRleHR1cmUiLCJ0ZXh0dXJlIiwiRGF0YVRleHR1cmUiLCJSZWRGb3JtYXQiLCJGbG9hdFR5cGUiLCJtaW5GaWx0ZXIiLCJOZWFyZXN0RmlsdGVyIiwibWFnRmlsdGVyIiwiaW1hZ2UiLCJoYW5kbGVDb25uZWN0b3JDbGljayIsImNsaWNrUG9pbnQiLCJncmlkWCIsInJvdW5kIiwiZ3JpZFkiLCJjZWxsQ2VudGVyIiwic3FydCIsInBvdyIsIm5ld0Nvbm5lY3RvcnMiLCJncm91cFgiLCJncm91cFkiLCJibEluZGV4IiwiYnJJbmRleCIsInRsSW5kZXgiLCJ0ckluZGV4IiwiaXNWYWxpZEdyb3VwIiwiYmxBY3RpdmUiLCJickFjdGl2ZSIsInRsQWN0aXZlIiwidHJBY3RpdmUiLCJibFBvcyIsImJyUG9zIiwidGxQb3MiLCJ0clBvcyIsImNlbnRlclgiLCJjZW50ZXJZIiwiZGlzdFRvQ2VudGVyIiwiaXNDZW50ZXJDbGljayIsImNhblVzZURpYWdUTEJSIiwiY2FuVXNlRGlhZ0JMVFIiLCJoYXNEaWFnb25hbE9wdGlvbnMiLCJjdXJyZW50Q29ubmVjdG9yIiwiZ3JvdXBLZXkiLCJoYXNIb3JpekNtZEJlbG93IiwiaGFzSG9yaXpDbWRBYm92ZSIsImlzQmxvY2tlZEJ5SG9yaXoiLCJuZXdDb25uZWN0b3IiLCJwb3RlbnRpYWxDb25uZWN0b3JUeXBlIiwiY2xpY2tlZFR5cGUiLCJkaXN0VG9CTFRSIiwiYWJzIiwiZGlzdFRvVExCUiIsInVwZGF0ZWQiLCJ0eXBlU3RyIiwiaGFzQ2hhbmdlcyIsImhhc0NtZEhvcml6Q2hhbmdlcyIsImNvbm5lY3RvciIsInNwbGl0IiwibWFwIiwiTnVtYmVyIiwic3Vic3RyaW5nIiwibGVmdEluZGV4IiwiaW50ZW5kZWRDb25uZWN0b3JUZXh0dXJlIiwiY21kSG9yaXpDb25uZWN0b3JUZXh0dXJlIiwiY29ubmVjdG9ycyIsInRleHR1cmVTaXplIiwiZGF0YVNpemUiLCJmcnVzdHVtQ3VsbGVkIiwiZ2VvbWV0cnkiLCJjb21wdXRlQm91bmRpbmdTcGhlcmUiLCJib3VuZGluZ1NwaGVyZSIsInJhZGl1cyIsInN0YXRzUmVmIiwiZG9jdW1lbnQiLCJib2R5IiwicmVtb3ZlQ2hpbGQiLCJkb20iLCJzdGF0ZSIsInVwZGF0ZSIsImRpcmVjdEludGVuZGVkQ29ubmVjdG9ycyIsImRpcmVjdENtZEhvcml6Q29ubmVjdG9ycyIsImZyb20iLCJ2YWwiLCJpbnRlbmRlZENvbm5lY3RvcnNDb3B5IiwiY21kSG9yaXpDb25uZWN0b3JzQ29weSIsIm5vblplcm9JbnRlbmRlZENvbm5lY3RvcnMiLCJhY3RpdmVIb3JpekNvbm5lY3RvcnMiLCJleHBlY3RlZExlbmd0aCIsImkiLCJwdXNoIiwiZWRnZVR5cGUiLCJkYXRhU3RyIiwiYmxvYiIsIkJsb2IiLCJ1cmwiLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJhIiwiY3JlYXRlRWxlbWVudCIsImhyZWYiLCJkb3dubG9hZCIsImFwcGVuZENoaWxkIiwiY2xpY2siLCJyZXZva2VPYmplY3RVUkwiLCJzYXZlR3JpZFN0YXRlIiwiY3JlYXRlVGVzdFBhdHRlcm4iLCJwYXR0ZXJuIiwiYWxsQ29ubmVjdG9yc01hdGNoIiwiayIsImNsZWFyQWxsIiwiZGlyZWN0U2F2ZSIsImdyb3VwIiwiaW5zdGFuY2VkTWVzaCIsInJlZiIsImFyZ3MiLCJvbkNsaWNrIiwicGxhbmVHZW9tZXRyeSIsImluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSIsImF0dGFjaCIsInVzYWdlIiwiRHluYW1pY0RyYXdVc2FnZSIsImNpcmNsZU1hdGVyaWFsIiwidHJhbnNwYXJlbnQiLCJtZXNoIiwiY29ubmVjdG9yTWF0ZXJpYWwiLCJzaWRlIiwiRG91YmxlU2lkZSIsInVfc3RhdGVUZXh0dXJlIiwidV9pbnRlbmRlZENvbm5lY3RvclRleHR1cmUiLCJ1X2dyaWREaW1lbnNpb25zIiwidV90ZXh0dXJlUmVzb2x1dGlvbiIsInVfZ3JpZFNwYWNpbmciLCJ1X2NlbnRlck9mZnNldCIsInVfcGxhbmVTaXplIiwiY21kSG9yaXpDb25uZWN0b3JNYXRlcmlhbCIsInVfY21kSG9yaXpDb25uZWN0b3JUZXh0dXJlIiwidV9maXhlZFNwYWNpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/GridScene.tsx\n");

/***/ }),

/***/ "./components/constants.ts":
/*!*********************************!*\
  !*** ./components/constants.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BASE_RADIUS_A: () => (/* binding */ BASE_RADIUS_A),\n/* harmony export */   BASE_RADIUS_B: () => (/* binding */ BASE_RADIUS_B),\n/* harmony export */   CONNECTOR_DIAG_BL_TR: () => (/* binding */ CONNECTOR_DIAG_BL_TR),\n/* harmony export */   CONNECTOR_DIAG_TL_BR: () => (/* binding */ CONNECTOR_DIAG_TL_BR),\n/* harmony export */   CONNECTOR_HORIZ_B: () => (/* binding */ CONNECTOR_HORIZ_B),\n/* harmony export */   CONNECTOR_HORIZ_CMD: () => (/* binding */ CONNECTOR_HORIZ_CMD),\n/* harmony export */   CONNECTOR_HORIZ_T: () => (/* binding */ CONNECTOR_HORIZ_T),\n/* harmony export */   CONNECTOR_NONE: () => (/* binding */ CONNECTOR_NONE),\n/* harmony export */   FIXED_SPACING: () => (/* binding */ FIXED_SPACING)\n/* harmony export */ });\n// Base geometry values\nconst BASE_RADIUS_A = 0.5; // Outer radius\nconst BASE_RADIUS_B = 0.4; // Inner radius\n// Calculated fixed spacing based on desired overlap\nconst FIXED_SPACING = BASE_RADIUS_A + BASE_RADIUS_B; // 0.5 + 0.4 = 0.9 \n// Define connector types as constants\nconst CONNECTOR_NONE = 0;\nconst CONNECTOR_DIAG_TL_BR = 1; // Diagonal \\\nconst CONNECTOR_DIAG_BL_TR = 2; // Diagonal /\nconst CONNECTOR_HORIZ_T = 3; // Horizontal Top\nconst CONNECTOR_HORIZ_B = 4; // Horizontal Bottom\nconst CONNECTOR_HORIZ_CMD = 5; // Cmd-click horizontal connector \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL2NvbnN0YW50cy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQSx1QkFBdUI7QUFDaEIsTUFBTUEsZ0JBQWdCLElBQUksQ0FBQyxlQUFlO0FBQzFDLE1BQU1DLGdCQUFnQixJQUFJLENBQUMsZUFBZTtBQUVqRCxvREFBb0Q7QUFDN0MsTUFBTUMsZ0JBQWdCRixnQkFBZ0JDLGNBQWMsQ0FBQyxtQkFBbUI7QUFFL0Usc0NBQXNDO0FBQy9CLE1BQU1FLGlCQUFpQixFQUFFO0FBQ3pCLE1BQU1DLHVCQUF1QixFQUFFLENBQUMsYUFBYTtBQUM3QyxNQUFNQyx1QkFBdUIsRUFBRSxDQUFDLGFBQWE7QUFDN0MsTUFBTUMsb0JBQW9CLEVBQUUsQ0FBSSxpQkFBaUI7QUFDakQsTUFBTUMsb0JBQW9CLEVBQUUsQ0FBSSxvQkFBb0I7QUFDcEQsTUFBTUMsc0JBQXNCLEVBQUUsQ0FBRSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWJnbC1kb3QtZ3JpZC1tdnAvLi9jb21wb25lbnRzL2NvbnN0YW50cy50cz83N2FjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEJhc2UgZ2VvbWV0cnkgdmFsdWVzXG5leHBvcnQgY29uc3QgQkFTRV9SQURJVVNfQSA9IDAuNTsgLy8gT3V0ZXIgcmFkaXVzXG5leHBvcnQgY29uc3QgQkFTRV9SQURJVVNfQiA9IDAuNDsgLy8gSW5uZXIgcmFkaXVzXG5cbi8vIENhbGN1bGF0ZWQgZml4ZWQgc3BhY2luZyBiYXNlZCBvbiBkZXNpcmVkIG92ZXJsYXBcbmV4cG9ydCBjb25zdCBGSVhFRF9TUEFDSU5HID0gQkFTRV9SQURJVVNfQSArIEJBU0VfUkFESVVTX0I7IC8vIDAuNSArIDAuNCA9IDAuOSBcblxuLy8gRGVmaW5lIGNvbm5lY3RvciB0eXBlcyBhcyBjb25zdGFudHNcbmV4cG9ydCBjb25zdCBDT05ORUNUT1JfTk9ORSA9IDA7XG5leHBvcnQgY29uc3QgQ09OTkVDVE9SX0RJQUdfVExfQlIgPSAxOyAvLyBEaWFnb25hbCBcXFxuZXhwb3J0IGNvbnN0IENPTk5FQ1RPUl9ESUFHX0JMX1RSID0gMjsgLy8gRGlhZ29uYWwgL1xuZXhwb3J0IGNvbnN0IENPTk5FQ1RPUl9IT1JJWl9UID0gMzsgICAgLy8gSG9yaXpvbnRhbCBUb3BcbmV4cG9ydCBjb25zdCBDT05ORUNUT1JfSE9SSVpfQiA9IDQ7ICAgIC8vIEhvcml6b250YWwgQm90dG9tXG5leHBvcnQgY29uc3QgQ09OTkVDVE9SX0hPUklaX0NNRCA9IDU7ICAvLyBDbWQtY2xpY2sgaG9yaXpvbnRhbCBjb25uZWN0b3IgIl0sIm5hbWVzIjpbIkJBU0VfUkFESVVTX0EiLCJCQVNFX1JBRElVU19CIiwiRklYRURfU1BBQ0lORyIsIkNPTk5FQ1RPUl9OT05FIiwiQ09OTkVDVE9SX0RJQUdfVExfQlIiLCJDT05ORUNUT1JfRElBR19CTF9UUiIsIkNPTk5FQ1RPUl9IT1JJWl9UIiwiQ09OTkVDVE9SX0hPUklaX0IiLCJDT05ORUNUT1JfSE9SSVpfQ01EIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./components/constants.ts\n");

/***/ }),

/***/ "./pages/index.js":
/*!************************!*\
  !*** ./pages/index.js ***!
  \************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-three/fiber */ \"@react-three/fiber\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-three/drei */ \"@react-three/drei\");\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_react_three_drei__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var leva__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! leva */ \"leva\");\n/* harmony import */ var leva__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(leva__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _components_GridScene__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../components/GridScene */ \"./components/GridScene.tsx\");\n/* harmony import */ var _styles_Home_module_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../styles/Home.module.css */ \"./styles/Home.module.css\");\n/* harmony import */ var _styles_Home_module_css__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_6__);\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_components_GridScene__WEBPACK_IMPORTED_MODULE_5__]);\n_components_GridScene__WEBPACK_IMPORTED_MODULE_5__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n\n\n // Adjust path if necessary\n // Assuming you have this for styling\nconst App = ()=>{\n    // Leva controls for camera zoom\n    const { cameraZoom } = (0,leva__WEBPACK_IMPORTED_MODULE_4__.useControls)({\n        cameraZoom: {\n            value: 50,\n            min: 10,\n            max: 200,\n            step: 1\n        }\n    });\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_6___default().container),\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(leva__WEBPACK_IMPORTED_MODULE_4__.Leva, {\n                collapsed: true\n            }, void 0, false, {\n                fileName: \"/Users/ian/cursor_projects/webGL_meta/pages/index.js\",\n                lineNumber: 16,\n                columnNumber: 7\n            }, undefined),\n            \" \",\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.Canvas, {\n                style: {\n                    position: \"absolute\",\n                    top: 0,\n                    left: 0,\n                    width: \"100%\",\n                    height: \"100%\"\n                },\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_react_three_drei__WEBPACK_IMPORTED_MODULE_3__.OrthographicCamera, {\n                        makeDefault: true,\n                        zoom: cameraZoom,\n                        position: [\n                            0,\n                            0,\n                            100\n                        ],\n                        near: 0.1,\n                        far: 1000\n                    }, void 0, false, {\n                        fileName: \"/Users/ian/cursor_projects/webGL_meta/pages/index.js\",\n                        lineNumber: 21,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ambientLight\", {\n                        intensity: 1.0\n                    }, void 0, false, {\n                        fileName: \"/Users/ian/cursor_projects/webGL_meta/pages/index.js\",\n                        lineNumber: 28,\n                        columnNumber: 9\n                    }, undefined),\n                    \" \",\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_GridScene__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {}, void 0, false, {\n                        fileName: \"/Users/ian/cursor_projects/webGL_meta/pages/index.js\",\n                        lineNumber: 31,\n                        columnNumber: 9\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/ian/cursor_projects/webGL_meta/pages/index.js\",\n                lineNumber: 17,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/ian/cursor_projects/webGL_meta/pages/index.js\",\n        lineNumber: 15,\n        columnNumber: 5\n    }, undefined);\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (App);\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWdlcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMEI7QUFDa0I7QUFDVztBQUNkO0FBQ08sQ0FBQywyQkFBMkI7QUFDN0IsQ0FBQyxxQ0FBcUM7QUFFckYsTUFBTU8sTUFBTTtJQUNWLGdDQUFnQztJQUNoQyxNQUFNLEVBQUVDLFVBQVUsRUFBRSxHQUFHSixpREFBV0EsQ0FBQztRQUNqQ0ksWUFBWTtZQUFFQyxPQUFPO1lBQUlDLEtBQUs7WUFBSUMsS0FBSztZQUFLQyxNQUFNO1FBQUU7SUFDdEQ7SUFFQSxxQkFDRSw4REFBQ0M7UUFBSUMsV0FBV1IsMEVBQWdCOzswQkFDOUIsOERBQUNILHNDQUFJQTtnQkFBQ2EsU0FBUzs7Ozs7O1lBQUc7MEJBQ2xCLDhEQUFDZixzREFBTUE7Z0JBQ0xnQixPQUFPO29CQUFFQyxVQUFVO29CQUFZQyxLQUFLO29CQUFHQyxNQUFNO29CQUFHQyxPQUFPO29CQUFRQyxRQUFRO2dCQUFPOztrQ0FHOUUsOERBQUNwQixpRUFBa0JBO3dCQUNqQnFCLFdBQVc7d0JBQ1hDLE1BQU1oQjt3QkFDTlUsVUFBVTs0QkFBQzs0QkFBRzs0QkFBRzt5QkFBSTt3QkFDckJPLE1BQU07d0JBQ05DLEtBQUs7Ozs7OztrQ0FFUCw4REFBQ0M7d0JBQWFDLFdBQVc7Ozs7OztvQkFBTztrQ0FHaEMsOERBQUN2Qiw2REFBU0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBT2xCO0FBRUEsaUVBQWVFLEdBQUdBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWJnbC1kb3QtZ3JpZC1tdnAvLi9wYWdlcy9pbmRleC5qcz9iZWU3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBDYW52YXMgfSBmcm9tICdAcmVhY3QtdGhyZWUvZmliZXInO1xuaW1wb3J0IHsgT3J0aG9ncmFwaGljQ2FtZXJhIH0gZnJvbSAnQHJlYWN0LXRocmVlL2RyZWknO1xuaW1wb3J0IHsgTGV2YSwgdXNlQ29udHJvbHMgfSBmcm9tICdsZXZhJztcbmltcG9ydCBHcmlkU2NlbmUgZnJvbSAnLi4vY29tcG9uZW50cy9HcmlkU2NlbmUnOyAvLyBBZGp1c3QgcGF0aCBpZiBuZWNlc3NhcnlcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi4vc3R5bGVzL0hvbWUubW9kdWxlLmNzcyc7IC8vIEFzc3VtaW5nIHlvdSBoYXZlIHRoaXMgZm9yIHN0eWxpbmdcblxuY29uc3QgQXBwID0gKCkgPT4ge1xuICAvLyBMZXZhIGNvbnRyb2xzIGZvciBjYW1lcmEgem9vbVxuICBjb25zdCB7IGNhbWVyYVpvb20gfSA9IHVzZUNvbnRyb2xzKHtcbiAgICBjYW1lcmFab29tOiB7IHZhbHVlOiA1MCwgbWluOiAxMCwgbWF4OiAyMDAsIHN0ZXA6IDEgfSxcbiAgfSk7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmNvbnRhaW5lcn0+XG4gICAgICA8TGV2YSBjb2xsYXBzZWQgLz4gey8qIExldmEgcGFuZWwgZm9yIGNvbnRyb2xzICovfVxuICAgICAgPENhbnZhc1xuICAgICAgICBzdHlsZT17eyBwb3NpdGlvbjogJ2Fic29sdXRlJywgdG9wOiAwLCBsZWZ0OiAwLCB3aWR0aDogJzEwMCUnLCBoZWlnaHQ6ICcxMDAlJyB9fVxuICAgICAgPlxuICAgICAgICB7LyogVXNlIE9ydGhvZ3JhcGhpY0NhbWVyYSBmb3IgMkQgdmlldyAqL31cbiAgICAgICAgPE9ydGhvZ3JhcGhpY0NhbWVyYVxuICAgICAgICAgIG1ha2VEZWZhdWx0IC8vIFNldHMgdGhpcyBjYW1lcmEgYXMgdGhlIGRlZmF1bHRcbiAgICAgICAgICB6b29tPXtjYW1lcmFab29tfVxuICAgICAgICAgIHBvc2l0aW9uPXtbMCwgMCwgMTAwXX0gLy8gUG9zaXRpb25lZCB0byBsb29rIGFsb25nIC1aIGF4aXNcbiAgICAgICAgICBuZWFyPXswLjF9XG4gICAgICAgICAgZmFyPXsxMDAwfVxuICAgICAgICAvPlxuICAgICAgICA8YW1iaWVudExpZ2h0IGludGVuc2l0eT17MS4wfSAvPiB7LyogQmFzaWMgbGlnaHRpbmcgKi99XG4gICAgICAgIFxuICAgICAgICB7LyogUmVuZGVyIHRoZSBtYWluIHNjZW5lIGNvbXBvbmVudCAqL31cbiAgICAgICAgPEdyaWRTY2VuZSAvPiBcbiAgICAgICAgXG4gICAgICAgIHsvKiBPcHRpb25hbDogQWRkIE9yYml0Q29udHJvbHMgaWYgbmVlZGVkIGZvciBkZWJ1Z2dpbmcvbmF2aWdhdGlvbiAqL31cbiAgICAgICAgey8qIDxPcmJpdENvbnRyb2xzIGVuYWJsZVJvdGF0ZT17ZmFsc2V9IC8+ICovfVxuICAgICAgPC9DYW52YXM+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBBcHA7ICJdLCJuYW1lcyI6WyJSZWFjdCIsIkNhbnZhcyIsIk9ydGhvZ3JhcGhpY0NhbWVyYSIsIkxldmEiLCJ1c2VDb250cm9scyIsIkdyaWRTY2VuZSIsInN0eWxlcyIsIkFwcCIsImNhbWVyYVpvb20iLCJ2YWx1ZSIsIm1pbiIsIm1heCIsInN0ZXAiLCJkaXYiLCJjbGFzc05hbWUiLCJjb250YWluZXIiLCJjb2xsYXBzZWQiLCJzdHlsZSIsInBvc2l0aW9uIiwidG9wIiwibGVmdCIsIndpZHRoIiwiaGVpZ2h0IiwibWFrZURlZmF1bHQiLCJ6b29tIiwibmVhciIsImZhciIsImFtYmllbnRMaWdodCIsImludGVuc2l0eSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./pages/index.js\n");

/***/ }),

/***/ "@react-three/drei":
/*!************************************!*\
  !*** external "@react-three/drei" ***!
  \************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@react-three/drei");

/***/ }),

/***/ "@react-three/fiber":
/*!*************************************!*\
  !*** external "@react-three/fiber" ***!
  \*************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@react-three/fiber");

/***/ }),

/***/ "leva":
/*!***********************!*\
  !*** external "leva" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("leva");

/***/ }),

/***/ "next/dist/compiled/next-server/pages.runtime.dev.js":
/*!**********************************************************************!*\
  !*** external "next/dist/compiled/next-server/pages.runtime.dev.js" ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/next-server/pages.runtime.dev.js");

/***/ }),

/***/ "react":
/*!************************!*\
  !*** external "react" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("react");

/***/ }),

/***/ "react/jsx-dev-runtime":
/*!****************************************!*\
  !*** external "react/jsx-dev-runtime" ***!
  \****************************************/
/***/ ((module) => {

"use strict";
module.exports = require("react/jsx-dev-runtime");

/***/ }),

/***/ "three":
/*!************************!*\
  !*** external "three" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = import("three");;

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next","vendor-chunks/@swc"], () => (__webpack_exec__("./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES&page=%2F&preferredRegion=&absolutePagePath=.%2Fpages%2Findex.js&absoluteAppPath=private-next-pages%2F_app&absoluteDocumentPath=private-next-pages%2F_document&middlewareConfigBase64=e30%3D!")));
module.exports = __webpack_exports__;

})();